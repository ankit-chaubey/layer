# This file is AUTO-GENERATED by layer/codegen/generator.py
# DO NOT EDIT MANUALLY — run `python -m layer.codegen.generator` to regenerate.
# Layer: 222
# Source: api.tl

from __future__ import annotations

from typing import Optional, TYPE_CHECKING
from ..mtproto.core import (
    ByteBuffer, ByteReader, TLObject, TLFunction,
    DeserializeError, UnknownConstructorError,
)

def _deser_vector(reader, item_fn):
    cid = reader.read_u32()
    if cid != 0x1CB5C415:
        raise DeserializeError(f"Expected Vector 0x1cb5c415, got 0x{cid:08x}")
    n = reader.read_i32()
    return [item_fn(reader) for _ in range(n)]

def _deser_bare_vector(reader, item_fn):
    n = reader.read_i32()
    return [item_fn(reader) for _ in range(n)]

from . import types
# ruff: noqa
# isort: skip_file


class AccountDaysTtl(TLObject):
    """
    Boxed TL type ``AccountDaysTTL`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB8D0AFDF: types.AccountDaysTtl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AccountDaysTtl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_account_days_ttl(self) -> bool:
        return isinstance(self._inner, types.AccountDaysTtl)

    def as_account_days_ttl(self) -> Optional[types.AccountDaysTtl]:
        return self._inner if self.is_account_days_ttl() else None

    def __repr__(self) -> str:
        return f'AccountDaysTtl({self._inner!r})'


class AttachMenuBot(TLObject):
    """
    Boxed TL type ``AttachMenuBot`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD90D8DFE: types.AttachMenuBot,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AttachMenuBot':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_attach_menu_bot(self) -> bool:
        return isinstance(self._inner, types.AttachMenuBot)

    def as_attach_menu_bot(self) -> Optional[types.AttachMenuBot]:
        return self._inner if self.is_attach_menu_bot() else None

    def __repr__(self) -> str:
        return f'AttachMenuBot({self._inner!r})'


class AttachMenuBotIcon(TLObject):
    """
    Boxed TL type ``AttachMenuBotIcon`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB2A7386B: types.AttachMenuBotIcon,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AttachMenuBotIcon':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_attach_menu_bot_icon(self) -> bool:
        return isinstance(self._inner, types.AttachMenuBotIcon)

    def as_attach_menu_bot_icon(self) -> Optional[types.AttachMenuBotIcon]:
        return self._inner if self.is_attach_menu_bot_icon() else None

    def __repr__(self) -> str:
        return f'AttachMenuBotIcon({self._inner!r})'


class AttachMenuBotIconColor(TLObject):
    """
    Boxed TL type ``AttachMenuBotIconColor`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4576F3F0: types.AttachMenuBotIconColor,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AttachMenuBotIconColor':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_attach_menu_bot_icon_color(self) -> bool:
        return isinstance(self._inner, types.AttachMenuBotIconColor)

    def as_attach_menu_bot_icon_color(self) -> Optional[types.AttachMenuBotIconColor]:
        return self._inner if self.is_attach_menu_bot_icon_color() else None

    def __repr__(self) -> str:
        return f'AttachMenuBotIconColor({self._inner!r})'


class AttachMenuBots(TLObject):
    """
    Boxed TL type ``AttachMenuBots`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF1D88A5C: types.AttachMenuBotsNotModified,
        0x3C4301C0: types.AttachMenuBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AttachMenuBots':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.AttachMenuBotsNotModified)

    def as_not_modified(self) -> Optional[types.AttachMenuBotsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_attach_menu_bots(self) -> bool:
        return isinstance(self._inner, types.AttachMenuBots)

    def as_attach_menu_bots(self) -> Optional[types.AttachMenuBots]:
        return self._inner if self.is_attach_menu_bots() else None

    def __repr__(self) -> str:
        return f'AttachMenuBots({self._inner!r})'


class AttachMenuBotsBot(TLObject):
    """
    Boxed TL type ``AttachMenuBotsBot`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x93BF667F: types.AttachMenuBotsBot,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AttachMenuBotsBot':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_attach_menu_bots_bot(self) -> bool:
        return isinstance(self._inner, types.AttachMenuBotsBot)

    def as_attach_menu_bots_bot(self) -> Optional[types.AttachMenuBotsBot]:
        return self._inner if self.is_attach_menu_bots_bot() else None

    def __repr__(self) -> str:
        return f'AttachMenuBotsBot({self._inner!r})'


class AttachMenuPeerType(TLObject):
    """
    Boxed TL type ``AttachMenuPeerType`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7D6BE90E: types.AttachMenuPeerTypeSameBotPm,
        0xC32BFA1A: types.AttachMenuPeerTypeBotPm,
        0xF146D31F: types.AttachMenuPeerTypePm,
        0x0509113F: types.AttachMenuPeerTypeChat,
        0x7BFBDEFC: types.AttachMenuPeerTypeBroadcast,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AttachMenuPeerType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_same_bot_pm(self) -> bool:
        return isinstance(self._inner, types.AttachMenuPeerTypeSameBotPm)

    def as_same_bot_pm(self) -> Optional[types.AttachMenuPeerTypeSameBotPm]:
        return self._inner if self.is_same_bot_pm() else None

    def is_bot_pm(self) -> bool:
        return isinstance(self._inner, types.AttachMenuPeerTypeBotPm)

    def as_bot_pm(self) -> Optional[types.AttachMenuPeerTypeBotPm]:
        return self._inner if self.is_bot_pm() else None

    def is_pm(self) -> bool:
        return isinstance(self._inner, types.AttachMenuPeerTypePm)

    def as_pm(self) -> Optional[types.AttachMenuPeerTypePm]:
        return self._inner if self.is_pm() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.AttachMenuPeerTypeChat)

    def as_chat(self) -> Optional[types.AttachMenuPeerTypeChat]:
        return self._inner if self.is_chat() else None

    def is_broadcast(self) -> bool:
        return isinstance(self._inner, types.AttachMenuPeerTypeBroadcast)

    def as_broadcast(self) -> Optional[types.AttachMenuPeerTypeBroadcast]:
        return self._inner if self.is_broadcast() else None

    def __repr__(self) -> str:
        return f'AttachMenuPeerType({self._inner!r})'


class AuctionBidLevel(TLObject):
    """
    Boxed TL type ``AuctionBidLevel`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x310240CC: types.AuctionBidLevel,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AuctionBidLevel':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_auction_bid_level(self) -> bool:
        return isinstance(self._inner, types.AuctionBidLevel)

    def as_auction_bid_level(self) -> Optional[types.AuctionBidLevel]:
        return self._inner if self.is_auction_bid_level() else None

    def __repr__(self) -> str:
        return f'AuctionBidLevel({self._inner!r})'


class Authorization(TLObject):
    """
    Boxed TL type ``Authorization`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAD01D61D: types.Authorization,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Authorization':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_authorization(self) -> bool:
        return isinstance(self._inner, types.Authorization)

    def as_authorization(self) -> Optional[types.Authorization]:
        return self._inner if self.is_authorization() else None

    def __repr__(self) -> str:
        return f'Authorization({self._inner!r})'


class AutoDownloadSettings(TLObject):
    """
    Boxed TL type ``AutoDownloadSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBAA57628: types.AutoDownloadSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AutoDownloadSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_auto_download_settings(self) -> bool:
        return isinstance(self._inner, types.AutoDownloadSettings)

    def as_auto_download_settings(self) -> Optional[types.AutoDownloadSettings]:
        return self._inner if self.is_auto_download_settings() else None

    def __repr__(self) -> str:
        return f'AutoDownloadSettings({self._inner!r})'


class AutoSaveException(TLObject):
    """
    Boxed TL type ``AutoSaveException`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x81602D47: types.AutoSaveException,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AutoSaveException':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_auto_save_exception(self) -> bool:
        return isinstance(self._inner, types.AutoSaveException)

    def as_auto_save_exception(self) -> Optional[types.AutoSaveException]:
        return self._inner if self.is_auto_save_exception() else None

    def __repr__(self) -> str:
        return f'AutoSaveException({self._inner!r})'


class AutoSaveSettings(TLObject):
    """
    Boxed TL type ``AutoSaveSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC84834CE: types.AutoSaveSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AutoSaveSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_auto_save_settings(self) -> bool:
        return isinstance(self._inner, types.AutoSaveSettings)

    def as_auto_save_settings(self) -> Optional[types.AutoSaveSettings]:
        return self._inner if self.is_auto_save_settings() else None

    def __repr__(self) -> str:
        return f'AutoSaveSettings({self._inner!r})'


class AvailableEffect(TLObject):
    """
    Boxed TL type ``AvailableEffect`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x93C3E27E: types.AvailableEffect,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AvailableEffect':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_available_effect(self) -> bool:
        return isinstance(self._inner, types.AvailableEffect)

    def as_available_effect(self) -> Optional[types.AvailableEffect]:
        return self._inner if self.is_available_effect() else None

    def __repr__(self) -> str:
        return f'AvailableEffect({self._inner!r})'


class AvailableReaction(TLObject):
    """
    Boxed TL type ``AvailableReaction`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC077EC01: types.AvailableReaction,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AvailableReaction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_available_reaction(self) -> bool:
        return isinstance(self._inner, types.AvailableReaction)

    def as_available_reaction(self) -> Optional[types.AvailableReaction]:
        return self._inner if self.is_available_reaction() else None

    def __repr__(self) -> str:
        return f'AvailableReaction({self._inner!r})'


class BankCardOpenUrl(TLObject):
    """
    Boxed TL type ``BankCardOpenUrl`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF568028A: types.BankCardOpenUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BankCardOpenUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bank_card_open_url(self) -> bool:
        return isinstance(self._inner, types.BankCardOpenUrl)

    def as_bank_card_open_url(self) -> Optional[types.BankCardOpenUrl]:
        return self._inner if self.is_bank_card_open_url() else None

    def __repr__(self) -> str:
        return f'BankCardOpenUrl({self._inner!r})'


class BaseTheme(TLObject):
    """
    Boxed TL type ``BaseTheme`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC3A12462: types.BaseThemeClassic,
        0xFBD81688: types.BaseThemeDay,
        0xB7B31EA8: types.BaseThemeNight,
        0x6D5F77EE: types.BaseThemeTinted,
        0x5B11125A: types.BaseThemeArctic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BaseTheme':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_classic(self) -> bool:
        return isinstance(self._inner, types.BaseThemeClassic)

    def as_classic(self) -> Optional[types.BaseThemeClassic]:
        return self._inner if self.is_classic() else None

    def is_day(self) -> bool:
        return isinstance(self._inner, types.BaseThemeDay)

    def as_day(self) -> Optional[types.BaseThemeDay]:
        return self._inner if self.is_day() else None

    def is_night(self) -> bool:
        return isinstance(self._inner, types.BaseThemeNight)

    def as_night(self) -> Optional[types.BaseThemeNight]:
        return self._inner if self.is_night() else None

    def is_tinted(self) -> bool:
        return isinstance(self._inner, types.BaseThemeTinted)

    def as_tinted(self) -> Optional[types.BaseThemeTinted]:
        return self._inner if self.is_tinted() else None

    def is_arctic(self) -> bool:
        return isinstance(self._inner, types.BaseThemeArctic)

    def as_arctic(self) -> Optional[types.BaseThemeArctic]:
        return self._inner if self.is_arctic() else None

    def __repr__(self) -> str:
        return f'BaseTheme({self._inner!r})'


class Birthday(TLObject):
    """
    Boxed TL type ``Birthday`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6C8E1E06: types.Birthday,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Birthday':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_birthday(self) -> bool:
        return isinstance(self._inner, types.Birthday)

    def as_birthday(self) -> Optional[types.Birthday]:
        return self._inner if self.is_birthday() else None

    def __repr__(self) -> str:
        return f'Birthday({self._inner!r})'


class Boost(TLObject):
    """
    Boxed TL type ``Boost`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4B3E14D6: types.Boost,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Boost':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_boost(self) -> bool:
        return isinstance(self._inner, types.Boost)

    def as_boost(self) -> Optional[types.Boost]:
        return self._inner if self.is_boost() else None

    def __repr__(self) -> str:
        return f'Boost({self._inner!r})'


class BotApp(TLObject):
    """
    Boxed TL type ``BotApp`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5DA674B7: types.BotAppNotModified,
        0x95FCD1D6: types.BotApp,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotApp':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.BotAppNotModified)

    def as_not_modified(self) -> Optional[types.BotAppNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_bot_app(self) -> bool:
        return isinstance(self._inner, types.BotApp)

    def as_bot_app(self) -> Optional[types.BotApp]:
        return self._inner if self.is_bot_app() else None

    def __repr__(self) -> str:
        return f'BotApp({self._inner!r})'


class BotAppSettings(TLObject):
    """
    Boxed TL type ``BotAppSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC99B1950: types.BotAppSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotAppSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_app_settings(self) -> bool:
        return isinstance(self._inner, types.BotAppSettings)

    def as_bot_app_settings(self) -> Optional[types.BotAppSettings]:
        return self._inner if self.is_bot_app_settings() else None

    def __repr__(self) -> str:
        return f'BotAppSettings({self._inner!r})'


class BotBusinessConnection(TLObject):
    """
    Boxed TL type ``BotBusinessConnection`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8F34B2F5: types.BotBusinessConnection,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotBusinessConnection':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_business_connection(self) -> bool:
        return isinstance(self._inner, types.BotBusinessConnection)

    def as_bot_business_connection(self) -> Optional[types.BotBusinessConnection]:
        return self._inner if self.is_bot_business_connection() else None

    def __repr__(self) -> str:
        return f'BotBusinessConnection({self._inner!r})'


class BotCommand(TLObject):
    """
    Boxed TL type ``BotCommand`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC27AC8C7: types.BotCommand,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotCommand':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_command(self) -> bool:
        return isinstance(self._inner, types.BotCommand)

    def as_bot_command(self) -> Optional[types.BotCommand]:
        return self._inner if self.is_bot_command() else None

    def __repr__(self) -> str:
        return f'BotCommand({self._inner!r})'


class BotCommandScope(TLObject):
    """
    Boxed TL type ``BotCommandScope`` — union of 7 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2F6CB2AB: types.BotCommandScopeDefault,
        0x3C4F04D8: types.BotCommandScopeUsers,
        0x6FE1A881: types.BotCommandScopeChats,
        0xB9AA606A: types.BotCommandScopeChatAdmins,
        0xDB9D897D: types.BotCommandScopePeer,
        0x3FD863D1: types.BotCommandScopePeerAdmins,
        0x0A1321F3: types.BotCommandScopePeerUser,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotCommandScope':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_default(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopeDefault)

    def as_default(self) -> Optional[types.BotCommandScopeDefault]:
        return self._inner if self.is_default() else None

    def is_users(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopeUsers)

    def as_users(self) -> Optional[types.BotCommandScopeUsers]:
        return self._inner if self.is_users() else None

    def is_chats(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopeChats)

    def as_chats(self) -> Optional[types.BotCommandScopeChats]:
        return self._inner if self.is_chats() else None

    def is_chat_admins(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopeChatAdmins)

    def as_chat_admins(self) -> Optional[types.BotCommandScopeChatAdmins]:
        return self._inner if self.is_chat_admins() else None

    def is_peer(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopePeer)

    def as_peer(self) -> Optional[types.BotCommandScopePeer]:
        return self._inner if self.is_peer() else None

    def is_peer_admins(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopePeerAdmins)

    def as_peer_admins(self) -> Optional[types.BotCommandScopePeerAdmins]:
        return self._inner if self.is_peer_admins() else None

    def is_peer_user(self) -> bool:
        return isinstance(self._inner, types.BotCommandScopePeerUser)

    def as_peer_user(self) -> Optional[types.BotCommandScopePeerUser]:
        return self._inner if self.is_peer_user() else None

    def __repr__(self) -> str:
        return f'BotCommandScope({self._inner!r})'


class BotInfo(TLObject):
    """
    Boxed TL type ``BotInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4D8A0299: types.BotInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_info(self) -> bool:
        return isinstance(self._inner, types.BotInfo)

    def as_bot_info(self) -> Optional[types.BotInfo]:
        return self._inner if self.is_bot_info() else None

    def __repr__(self) -> str:
        return f'BotInfo({self._inner!r})'


class BotInlineMessage(TLObject):
    """
    Boxed TL type ``BotInlineMessage`` — union of 7 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x764CF810: types.BotInlineMessageMediaAuto,
        0x8C7F65E2: types.BotInlineMessageText,
        0x051846FD: types.BotInlineMessageMediaGeo,
        0x8A86659C: types.BotInlineMessageMediaVenue,
        0x18D1CDC2: types.BotInlineMessageMediaContact,
        0x354A9B09: types.BotInlineMessageMediaInvoice,
        0x809AD9A6: types.BotInlineMessageMediaWebPage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotInlineMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_media_auto(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageMediaAuto)

    def as_media_auto(self) -> Optional[types.BotInlineMessageMediaAuto]:
        return self._inner if self.is_media_auto() else None

    def is_text(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageText)

    def as_text(self) -> Optional[types.BotInlineMessageText]:
        return self._inner if self.is_text() else None

    def is_media_geo(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageMediaGeo)

    def as_media_geo(self) -> Optional[types.BotInlineMessageMediaGeo]:
        return self._inner if self.is_media_geo() else None

    def is_media_venue(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageMediaVenue)

    def as_media_venue(self) -> Optional[types.BotInlineMessageMediaVenue]:
        return self._inner if self.is_media_venue() else None

    def is_media_contact(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageMediaContact)

    def as_media_contact(self) -> Optional[types.BotInlineMessageMediaContact]:
        return self._inner if self.is_media_contact() else None

    def is_media_invoice(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageMediaInvoice)

    def as_media_invoice(self) -> Optional[types.BotInlineMessageMediaInvoice]:
        return self._inner if self.is_media_invoice() else None

    def is_media_web_page(self) -> bool:
        return isinstance(self._inner, types.BotInlineMessageMediaWebPage)

    def as_media_web_page(self) -> Optional[types.BotInlineMessageMediaWebPage]:
        return self._inner if self.is_media_web_page() else None

    def __repr__(self) -> str:
        return f'BotInlineMessage({self._inner!r})'


class BotInlineResult(TLObject):
    """
    Boxed TL type ``BotInlineResult`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x11965F3A: types.BotInlineResult,
        0x17DB940B: types.BotInlineMediaResult,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotInlineResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_inline_result(self) -> bool:
        return isinstance(self._inner, types.BotInlineResult)

    def as_bot_inline_result(self) -> Optional[types.BotInlineResult]:
        return self._inner if self.is_bot_inline_result() else None

    def is_bot_inline_media_result(self) -> bool:
        return isinstance(self._inner, types.BotInlineMediaResult)

    def as_bot_inline_media_result(self) -> Optional[types.BotInlineMediaResult]:
        return self._inner if self.is_bot_inline_media_result() else None

    def __repr__(self) -> str:
        return f'BotInlineResult({self._inner!r})'


class BotMenuButton(TLObject):
    """
    Boxed TL type ``BotMenuButton`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7533A588: types.BotMenuButtonDefault,
        0x4258C205: types.BotMenuButtonCommands,
        0xC7B57CE6: types.BotMenuButton,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotMenuButton':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_default(self) -> bool:
        return isinstance(self._inner, types.BotMenuButtonDefault)

    def as_default(self) -> Optional[types.BotMenuButtonDefault]:
        return self._inner if self.is_default() else None

    def is_commands(self) -> bool:
        return isinstance(self._inner, types.BotMenuButtonCommands)

    def as_commands(self) -> Optional[types.BotMenuButtonCommands]:
        return self._inner if self.is_commands() else None

    def is_bot_menu_button(self) -> bool:
        return isinstance(self._inner, types.BotMenuButton)

    def as_bot_menu_button(self) -> Optional[types.BotMenuButton]:
        return self._inner if self.is_bot_menu_button() else None

    def __repr__(self) -> str:
        return f'BotMenuButton({self._inner!r})'


class BotPreviewMedia(TLObject):
    """
    Boxed TL type ``BotPreviewMedia`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x23E91BA3: types.BotPreviewMedia,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotPreviewMedia':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_preview_media(self) -> bool:
        return isinstance(self._inner, types.BotPreviewMedia)

    def as_bot_preview_media(self) -> Optional[types.BotPreviewMedia]:
        return self._inner if self.is_bot_preview_media() else None

    def __repr__(self) -> str:
        return f'BotPreviewMedia({self._inner!r})'


class BotVerification(TLObject):
    """
    Boxed TL type ``BotVerification`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF93CD45C: types.BotVerification,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotVerification':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_verification(self) -> bool:
        return isinstance(self._inner, types.BotVerification)

    def as_bot_verification(self) -> Optional[types.BotVerification]:
        return self._inner if self.is_bot_verification() else None

    def __repr__(self) -> str:
        return f'BotVerification({self._inner!r})'


class BotVerifierSettings(TLObject):
    """
    Boxed TL type ``BotVerifierSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB0CD6617: types.BotVerifierSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotVerifierSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_verifier_settings(self) -> bool:
        return isinstance(self._inner, types.BotVerifierSettings)

    def as_bot_verifier_settings(self) -> Optional[types.BotVerifierSettings]:
        return self._inner if self.is_bot_verifier_settings() else None

    def __repr__(self) -> str:
        return f'BotVerifierSettings({self._inner!r})'


class BusinessAwayMessage(TLObject):
    """
    Boxed TL type ``BusinessAwayMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEF156A5C: types.BusinessAwayMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessAwayMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_away_message(self) -> bool:
        return isinstance(self._inner, types.BusinessAwayMessage)

    def as_business_away_message(self) -> Optional[types.BusinessAwayMessage]:
        return self._inner if self.is_business_away_message() else None

    def __repr__(self) -> str:
        return f'BusinessAwayMessage({self._inner!r})'


class BusinessAwayMessageSchedule(TLObject):
    """
    Boxed TL type ``BusinessAwayMessageSchedule`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC9B9E2B9: types.BusinessAwayMessageScheduleAlways,
        0xC3F2F501: types.BusinessAwayMessageScheduleOutsideWorkHours,
        0xCC4D9ECC: types.BusinessAwayMessageScheduleCustom,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessAwayMessageSchedule':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_always(self) -> bool:
        return isinstance(self._inner, types.BusinessAwayMessageScheduleAlways)

    def as_always(self) -> Optional[types.BusinessAwayMessageScheduleAlways]:
        return self._inner if self.is_always() else None

    def is_outside_work_hours(self) -> bool:
        return isinstance(self._inner, types.BusinessAwayMessageScheduleOutsideWorkHours)

    def as_outside_work_hours(self) -> Optional[types.BusinessAwayMessageScheduleOutsideWorkHours]:
        return self._inner if self.is_outside_work_hours() else None

    def is_custom(self) -> bool:
        return isinstance(self._inner, types.BusinessAwayMessageScheduleCustom)

    def as_custom(self) -> Optional[types.BusinessAwayMessageScheduleCustom]:
        return self._inner if self.is_custom() else None

    def __repr__(self) -> str:
        return f'BusinessAwayMessageSchedule({self._inner!r})'


class BusinessBotRecipients(TLObject):
    """
    Boxed TL type ``BusinessBotRecipients`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB88CF373: types.BusinessBotRecipients,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessBotRecipients':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_bot_recipients(self) -> bool:
        return isinstance(self._inner, types.BusinessBotRecipients)

    def as_business_bot_recipients(self) -> Optional[types.BusinessBotRecipients]:
        return self._inner if self.is_business_bot_recipients() else None

    def __repr__(self) -> str:
        return f'BusinessBotRecipients({self._inner!r})'


class BusinessBotRights(TLObject):
    """
    Boxed TL type ``BusinessBotRights`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA0624CF7: types.BusinessBotRights,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessBotRights':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_bot_rights(self) -> bool:
        return isinstance(self._inner, types.BusinessBotRights)

    def as_business_bot_rights(self) -> Optional[types.BusinessBotRights]:
        return self._inner if self.is_business_bot_rights() else None

    def __repr__(self) -> str:
        return f'BusinessBotRights({self._inner!r})'


class BusinessChatLink(TLObject):
    """
    Boxed TL type ``BusinessChatLink`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB4AE666F: types.BusinessChatLink,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessChatLink':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_chat_link(self) -> bool:
        return isinstance(self._inner, types.BusinessChatLink)

    def as_business_chat_link(self) -> Optional[types.BusinessChatLink]:
        return self._inner if self.is_business_chat_link() else None

    def __repr__(self) -> str:
        return f'BusinessChatLink({self._inner!r})'


class BusinessGreetingMessage(TLObject):
    """
    Boxed TL type ``BusinessGreetingMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE519ABAB: types.BusinessGreetingMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessGreetingMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_greeting_message(self) -> bool:
        return isinstance(self._inner, types.BusinessGreetingMessage)

    def as_business_greeting_message(self) -> Optional[types.BusinessGreetingMessage]:
        return self._inner if self.is_business_greeting_message() else None

    def __repr__(self) -> str:
        return f'BusinessGreetingMessage({self._inner!r})'


class BusinessIntro(TLObject):
    """
    Boxed TL type ``BusinessIntro`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5A0A066D: types.BusinessIntro,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessIntro':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_intro(self) -> bool:
        return isinstance(self._inner, types.BusinessIntro)

    def as_business_intro(self) -> Optional[types.BusinessIntro]:
        return self._inner if self.is_business_intro() else None

    def __repr__(self) -> str:
        return f'BusinessIntro({self._inner!r})'


class BusinessLocation(TLObject):
    """
    Boxed TL type ``BusinessLocation`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAC5C1AF7: types.BusinessLocation,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessLocation':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_location(self) -> bool:
        return isinstance(self._inner, types.BusinessLocation)

    def as_business_location(self) -> Optional[types.BusinessLocation]:
        return self._inner if self.is_business_location() else None

    def __repr__(self) -> str:
        return f'BusinessLocation({self._inner!r})'


class BusinessRecipients(TLObject):
    """
    Boxed TL type ``BusinessRecipients`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x21108FF7: types.BusinessRecipients,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessRecipients':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_recipients(self) -> bool:
        return isinstance(self._inner, types.BusinessRecipients)

    def as_business_recipients(self) -> Optional[types.BusinessRecipients]:
        return self._inner if self.is_business_recipients() else None

    def __repr__(self) -> str:
        return f'BusinessRecipients({self._inner!r})'


class BusinessWeeklyOpen(TLObject):
    """
    Boxed TL type ``BusinessWeeklyOpen`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x120B1AB9: types.BusinessWeeklyOpen,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessWeeklyOpen':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_weekly_open(self) -> bool:
        return isinstance(self._inner, types.BusinessWeeklyOpen)

    def as_business_weekly_open(self) -> Optional[types.BusinessWeeklyOpen]:
        return self._inner if self.is_business_weekly_open() else None

    def __repr__(self) -> str:
        return f'BusinessWeeklyOpen({self._inner!r})'


class BusinessWorkHours(TLObject):
    """
    Boxed TL type ``BusinessWorkHours`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8C92B098: types.BusinessWorkHours,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessWorkHours':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_work_hours(self) -> bool:
        return isinstance(self._inner, types.BusinessWorkHours)

    def as_business_work_hours(self) -> Optional[types.BusinessWorkHours]:
        return self._inner if self.is_business_work_hours() else None

    def __repr__(self) -> str:
        return f'BusinessWorkHours({self._inner!r})'


class CdnConfig(TLObject):
    """
    Boxed TL type ``CdnConfig`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5725E40A: types.CdnConfig,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CdnConfig':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_cdn_config(self) -> bool:
        return isinstance(self._inner, types.CdnConfig)

    def as_cdn_config(self) -> Optional[types.CdnConfig]:
        return self._inner if self.is_cdn_config() else None

    def __repr__(self) -> str:
        return f'CdnConfig({self._inner!r})'


class CdnPublicKey(TLObject):
    """
    Boxed TL type ``CdnPublicKey`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC982EABA: types.CdnPublicKey,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CdnPublicKey':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_cdn_public_key(self) -> bool:
        return isinstance(self._inner, types.CdnPublicKey)

    def as_cdn_public_key(self) -> Optional[types.CdnPublicKey]:
        return self._inner if self.is_cdn_public_key() else None

    def __repr__(self) -> str:
        return f'CdnPublicKey({self._inner!r})'


class ChannelAdminLogEvent(TLObject):
    """
    Boxed TL type ``ChannelAdminLogEvent`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1FAD68CD: types.ChannelAdminLogEvent,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelAdminLogEvent':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_channel_admin_log_event(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEvent)

    def as_channel_admin_log_event(self) -> Optional[types.ChannelAdminLogEvent]:
        return self._inner if self.is_channel_admin_log_event() else None

    def __repr__(self) -> str:
        return f'ChannelAdminLogEvent({self._inner!r})'


class ChannelAdminLogEventAction(TLObject):
    """
    Boxed TL type ``ChannelAdminLogEventAction`` — union of 51 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE6DFB825: types.ChannelAdminLogEventActionChangeTitle,
        0x55188A2E: types.ChannelAdminLogEventActionChangeAbout,
        0x6A4AFC38: types.ChannelAdminLogEventActionChangeUsername,
        0x434BD2AF: types.ChannelAdminLogEventActionChangePhoto,
        0x1B7907AE: types.ChannelAdminLogEventActionToggleInvites,
        0x26AE0971: types.ChannelAdminLogEventActionToggleSignatures,
        0xE9E82C18: types.ChannelAdminLogEventActionUpdatePinned,
        0x709B2405: types.ChannelAdminLogEventActionEditMessage,
        0x42E047BB: types.ChannelAdminLogEventActionDeleteMessage,
        0x183040D3: types.ChannelAdminLogEventActionParticipantJoin,
        0xF89777F2: types.ChannelAdminLogEventActionParticipantLeave,
        0xE31C34D8: types.ChannelAdminLogEventActionParticipantInvite,
        0xE6D83D7E: types.ChannelAdminLogEventActionParticipantToggleBan,
        0xD5676710: types.ChannelAdminLogEventActionParticipantToggleAdmin,
        0xB1C3CAA7: types.ChannelAdminLogEventActionChangeStickerSet,
        0x5F5C95F1: types.ChannelAdminLogEventActionTogglePreHistoryHidden,
        0x2DF5FC0A: types.ChannelAdminLogEventActionDefaultBannedRights,
        0x8F079643: types.ChannelAdminLogEventActionStopPoll,
        0x050C7AC8: types.ChannelAdminLogEventActionChangeLinkedChat,
        0x0E6B76AE: types.ChannelAdminLogEventActionChangeLocation,
        0x53909779: types.ChannelAdminLogEventActionToggleSlowMode,
        0x23209745: types.ChannelAdminLogEventActionStartGroupCall,
        0xDB9F9140: types.ChannelAdminLogEventActionDiscardGroupCall,
        0xF92424D2: types.ChannelAdminLogEventActionParticipantMute,
        0xE64429C0: types.ChannelAdminLogEventActionParticipantUnmute,
        0x56D6A247: types.ChannelAdminLogEventActionToggleGroupCallSetting,
        0xFE9FC158: types.ChannelAdminLogEventActionParticipantJoinByInvite,
        0x5A50FCA4: types.ChannelAdminLogEventActionExportedInviteDelete,
        0x410A134E: types.ChannelAdminLogEventActionExportedInviteRevoke,
        0xE90EBB59: types.ChannelAdminLogEventActionExportedInviteEdit,
        0x3E7F6847: types.ChannelAdminLogEventActionParticipantVolume,
        0x6E941A38: types.ChannelAdminLogEventActionChangeHistoryTtl,
        0xAFB6144A: types.ChannelAdminLogEventActionParticipantJoinByRequest,
        0xCB2AC766: types.ChannelAdminLogEventActionToggleNoForwards,
        0x278F2868: types.ChannelAdminLogEventActionSendMessage,
        0xBE4E0EF8: types.ChannelAdminLogEventActionChangeAvailableReactions,
        0xF04FB3A9: types.ChannelAdminLogEventActionChangeUsernames,
        0x02CC6383: types.ChannelAdminLogEventActionToggleForum,
        0x58707D28: types.ChannelAdminLogEventActionCreateTopic,
        0xF06FE208: types.ChannelAdminLogEventActionEditTopic,
        0xAE168909: types.ChannelAdminLogEventActionDeleteTopic,
        0x5D8D353B: types.ChannelAdminLogEventActionPinTopic,
        0x64F36DFC: types.ChannelAdminLogEventActionToggleAntiSpam,
        0x5796E780: types.ChannelAdminLogEventActionChangePeerColor,
        0x5E477B25: types.ChannelAdminLogEventActionChangeProfilePeerColor,
        0x31BB5D52: types.ChannelAdminLogEventActionChangeWallpaper,
        0x3EA9FEB1: types.ChannelAdminLogEventActionChangeEmojiStatus,
        0x46D840AB: types.ChannelAdminLogEventActionChangeEmojiStickerSet,
        0x60A79C79: types.ChannelAdminLogEventActionToggleSignatureProfiles,
        0x64642DB3: types.ChannelAdminLogEventActionParticipantSubExtend,
        0xC517F77E: types.ChannelAdminLogEventActionToggleAutotranslation,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelAdminLogEventAction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_change_title(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeTitle)

    def as_change_title(self) -> Optional[types.ChannelAdminLogEventActionChangeTitle]:
        return self._inner if self.is_change_title() else None

    def is_change_about(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeAbout)

    def as_change_about(self) -> Optional[types.ChannelAdminLogEventActionChangeAbout]:
        return self._inner if self.is_change_about() else None

    def is_change_username(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeUsername)

    def as_change_username(self) -> Optional[types.ChannelAdminLogEventActionChangeUsername]:
        return self._inner if self.is_change_username() else None

    def is_change_photo(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangePhoto)

    def as_change_photo(self) -> Optional[types.ChannelAdminLogEventActionChangePhoto]:
        return self._inner if self.is_change_photo() else None

    def is_toggle_invites(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleInvites)

    def as_toggle_invites(self) -> Optional[types.ChannelAdminLogEventActionToggleInvites]:
        return self._inner if self.is_toggle_invites() else None

    def is_toggle_signatures(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleSignatures)

    def as_toggle_signatures(self) -> Optional[types.ChannelAdminLogEventActionToggleSignatures]:
        return self._inner if self.is_toggle_signatures() else None

    def is_update_pinned(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionUpdatePinned)

    def as_update_pinned(self) -> Optional[types.ChannelAdminLogEventActionUpdatePinned]:
        return self._inner if self.is_update_pinned() else None

    def is_edit_message(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionEditMessage)

    def as_edit_message(self) -> Optional[types.ChannelAdminLogEventActionEditMessage]:
        return self._inner if self.is_edit_message() else None

    def is_delete_message(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionDeleteMessage)

    def as_delete_message(self) -> Optional[types.ChannelAdminLogEventActionDeleteMessage]:
        return self._inner if self.is_delete_message() else None

    def is_participant_join(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantJoin)

    def as_participant_join(self) -> Optional[types.ChannelAdminLogEventActionParticipantJoin]:
        return self._inner if self.is_participant_join() else None

    def is_participant_leave(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantLeave)

    def as_participant_leave(self) -> Optional[types.ChannelAdminLogEventActionParticipantLeave]:
        return self._inner if self.is_participant_leave() else None

    def is_participant_invite(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantInvite)

    def as_participant_invite(self) -> Optional[types.ChannelAdminLogEventActionParticipantInvite]:
        return self._inner if self.is_participant_invite() else None

    def is_participant_toggle_ban(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantToggleBan)

    def as_participant_toggle_ban(self) -> Optional[types.ChannelAdminLogEventActionParticipantToggleBan]:
        return self._inner if self.is_participant_toggle_ban() else None

    def is_participant_toggle_admin(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantToggleAdmin)

    def as_participant_toggle_admin(self) -> Optional[types.ChannelAdminLogEventActionParticipantToggleAdmin]:
        return self._inner if self.is_participant_toggle_admin() else None

    def is_change_sticker_set(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeStickerSet)

    def as_change_sticker_set(self) -> Optional[types.ChannelAdminLogEventActionChangeStickerSet]:
        return self._inner if self.is_change_sticker_set() else None

    def is_toggle_pre_history_hidden(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionTogglePreHistoryHidden)

    def as_toggle_pre_history_hidden(self) -> Optional[types.ChannelAdminLogEventActionTogglePreHistoryHidden]:
        return self._inner if self.is_toggle_pre_history_hidden() else None

    def is_default_banned_rights(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionDefaultBannedRights)

    def as_default_banned_rights(self) -> Optional[types.ChannelAdminLogEventActionDefaultBannedRights]:
        return self._inner if self.is_default_banned_rights() else None

    def is_stop_poll(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionStopPoll)

    def as_stop_poll(self) -> Optional[types.ChannelAdminLogEventActionStopPoll]:
        return self._inner if self.is_stop_poll() else None

    def is_change_linked_chat(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeLinkedChat)

    def as_change_linked_chat(self) -> Optional[types.ChannelAdminLogEventActionChangeLinkedChat]:
        return self._inner if self.is_change_linked_chat() else None

    def is_change_location(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeLocation)

    def as_change_location(self) -> Optional[types.ChannelAdminLogEventActionChangeLocation]:
        return self._inner if self.is_change_location() else None

    def is_toggle_slow_mode(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleSlowMode)

    def as_toggle_slow_mode(self) -> Optional[types.ChannelAdminLogEventActionToggleSlowMode]:
        return self._inner if self.is_toggle_slow_mode() else None

    def is_start_group_call(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionStartGroupCall)

    def as_start_group_call(self) -> Optional[types.ChannelAdminLogEventActionStartGroupCall]:
        return self._inner if self.is_start_group_call() else None

    def is_discard_group_call(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionDiscardGroupCall)

    def as_discard_group_call(self) -> Optional[types.ChannelAdminLogEventActionDiscardGroupCall]:
        return self._inner if self.is_discard_group_call() else None

    def is_participant_mute(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantMute)

    def as_participant_mute(self) -> Optional[types.ChannelAdminLogEventActionParticipantMute]:
        return self._inner if self.is_participant_mute() else None

    def is_participant_unmute(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantUnmute)

    def as_participant_unmute(self) -> Optional[types.ChannelAdminLogEventActionParticipantUnmute]:
        return self._inner if self.is_participant_unmute() else None

    def is_toggle_group_call_setting(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleGroupCallSetting)

    def as_toggle_group_call_setting(self) -> Optional[types.ChannelAdminLogEventActionToggleGroupCallSetting]:
        return self._inner if self.is_toggle_group_call_setting() else None

    def is_participant_join_by_invite(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantJoinByInvite)

    def as_participant_join_by_invite(self) -> Optional[types.ChannelAdminLogEventActionParticipantJoinByInvite]:
        return self._inner if self.is_participant_join_by_invite() else None

    def is_exported_invite_delete(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionExportedInviteDelete)

    def as_exported_invite_delete(self) -> Optional[types.ChannelAdminLogEventActionExportedInviteDelete]:
        return self._inner if self.is_exported_invite_delete() else None

    def is_exported_invite_revoke(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionExportedInviteRevoke)

    def as_exported_invite_revoke(self) -> Optional[types.ChannelAdminLogEventActionExportedInviteRevoke]:
        return self._inner if self.is_exported_invite_revoke() else None

    def is_exported_invite_edit(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionExportedInviteEdit)

    def as_exported_invite_edit(self) -> Optional[types.ChannelAdminLogEventActionExportedInviteEdit]:
        return self._inner if self.is_exported_invite_edit() else None

    def is_participant_volume(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantVolume)

    def as_participant_volume(self) -> Optional[types.ChannelAdminLogEventActionParticipantVolume]:
        return self._inner if self.is_participant_volume() else None

    def is_change_history_ttl(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeHistoryTtl)

    def as_change_history_ttl(self) -> Optional[types.ChannelAdminLogEventActionChangeHistoryTtl]:
        return self._inner if self.is_change_history_ttl() else None

    def is_participant_join_by_request(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantJoinByRequest)

    def as_participant_join_by_request(self) -> Optional[types.ChannelAdminLogEventActionParticipantJoinByRequest]:
        return self._inner if self.is_participant_join_by_request() else None

    def is_toggle_no_forwards(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleNoForwards)

    def as_toggle_no_forwards(self) -> Optional[types.ChannelAdminLogEventActionToggleNoForwards]:
        return self._inner if self.is_toggle_no_forwards() else None

    def is_send_message(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionSendMessage)

    def as_send_message(self) -> Optional[types.ChannelAdminLogEventActionSendMessage]:
        return self._inner if self.is_send_message() else None

    def is_change_available_reactions(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeAvailableReactions)

    def as_change_available_reactions(self) -> Optional[types.ChannelAdminLogEventActionChangeAvailableReactions]:
        return self._inner if self.is_change_available_reactions() else None

    def is_change_usernames(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeUsernames)

    def as_change_usernames(self) -> Optional[types.ChannelAdminLogEventActionChangeUsernames]:
        return self._inner if self.is_change_usernames() else None

    def is_toggle_forum(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleForum)

    def as_toggle_forum(self) -> Optional[types.ChannelAdminLogEventActionToggleForum]:
        return self._inner if self.is_toggle_forum() else None

    def is_create_topic(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionCreateTopic)

    def as_create_topic(self) -> Optional[types.ChannelAdminLogEventActionCreateTopic]:
        return self._inner if self.is_create_topic() else None

    def is_edit_topic(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionEditTopic)

    def as_edit_topic(self) -> Optional[types.ChannelAdminLogEventActionEditTopic]:
        return self._inner if self.is_edit_topic() else None

    def is_delete_topic(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionDeleteTopic)

    def as_delete_topic(self) -> Optional[types.ChannelAdminLogEventActionDeleteTopic]:
        return self._inner if self.is_delete_topic() else None

    def is_pin_topic(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionPinTopic)

    def as_pin_topic(self) -> Optional[types.ChannelAdminLogEventActionPinTopic]:
        return self._inner if self.is_pin_topic() else None

    def is_toggle_anti_spam(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleAntiSpam)

    def as_toggle_anti_spam(self) -> Optional[types.ChannelAdminLogEventActionToggleAntiSpam]:
        return self._inner if self.is_toggle_anti_spam() else None

    def is_change_peer_color(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangePeerColor)

    def as_change_peer_color(self) -> Optional[types.ChannelAdminLogEventActionChangePeerColor]:
        return self._inner if self.is_change_peer_color() else None

    def is_change_profile_peer_color(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeProfilePeerColor)

    def as_change_profile_peer_color(self) -> Optional[types.ChannelAdminLogEventActionChangeProfilePeerColor]:
        return self._inner if self.is_change_profile_peer_color() else None

    def is_change_wallpaper(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeWallpaper)

    def as_change_wallpaper(self) -> Optional[types.ChannelAdminLogEventActionChangeWallpaper]:
        return self._inner if self.is_change_wallpaper() else None

    def is_change_emoji_status(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeEmojiStatus)

    def as_change_emoji_status(self) -> Optional[types.ChannelAdminLogEventActionChangeEmojiStatus]:
        return self._inner if self.is_change_emoji_status() else None

    def is_change_emoji_sticker_set(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionChangeEmojiStickerSet)

    def as_change_emoji_sticker_set(self) -> Optional[types.ChannelAdminLogEventActionChangeEmojiStickerSet]:
        return self._inner if self.is_change_emoji_sticker_set() else None

    def is_toggle_signature_profiles(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleSignatureProfiles)

    def as_toggle_signature_profiles(self) -> Optional[types.ChannelAdminLogEventActionToggleSignatureProfiles]:
        return self._inner if self.is_toggle_signature_profiles() else None

    def is_participant_sub_extend(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionParticipantSubExtend)

    def as_participant_sub_extend(self) -> Optional[types.ChannelAdminLogEventActionParticipantSubExtend]:
        return self._inner if self.is_participant_sub_extend() else None

    def is_toggle_autotranslation(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventActionToggleAutotranslation)

    def as_toggle_autotranslation(self) -> Optional[types.ChannelAdminLogEventActionToggleAutotranslation]:
        return self._inner if self.is_toggle_autotranslation() else None

    def __repr__(self) -> str:
        return f'ChannelAdminLogEventAction({self._inner!r})'


class ChannelAdminLogEventsFilter(TLObject):
    """
    Boxed TL type ``ChannelAdminLogEventsFilter`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEA107AE4: types.ChannelAdminLogEventsFilter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelAdminLogEventsFilter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_channel_admin_log_events_filter(self) -> bool:
        return isinstance(self._inner, types.ChannelAdminLogEventsFilter)

    def as_channel_admin_log_events_filter(self) -> Optional[types.ChannelAdminLogEventsFilter]:
        return self._inner if self.is_channel_admin_log_events_filter() else None

    def __repr__(self) -> str:
        return f'ChannelAdminLogEventsFilter({self._inner!r})'


class ChannelLocation(TLObject):
    """
    Boxed TL type ``ChannelLocation`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBFB5AD8B: types.ChannelLocationEmpty,
        0x209B82DB: types.ChannelLocation,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelLocation':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.ChannelLocationEmpty)

    def as_empty(self) -> Optional[types.ChannelLocationEmpty]:
        return self._inner if self.is_empty() else None

    def is_channel_location(self) -> bool:
        return isinstance(self._inner, types.ChannelLocation)

    def as_channel_location(self) -> Optional[types.ChannelLocation]:
        return self._inner if self.is_channel_location() else None

    def __repr__(self) -> str:
        return f'ChannelLocation({self._inner!r})'


class ChannelMessagesFilter(TLObject):
    """
    Boxed TL type ``ChannelMessagesFilter`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x94D42EE7: types.ChannelMessagesFilterEmpty,
        0xCD77D957: types.ChannelMessagesFilter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelMessagesFilter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.ChannelMessagesFilterEmpty)

    def as_empty(self) -> Optional[types.ChannelMessagesFilterEmpty]:
        return self._inner if self.is_empty() else None

    def is_channel_messages_filter(self) -> bool:
        return isinstance(self._inner, types.ChannelMessagesFilter)

    def as_channel_messages_filter(self) -> Optional[types.ChannelMessagesFilter]:
        return self._inner if self.is_channel_messages_filter() else None

    def __repr__(self) -> str:
        return f'ChannelMessagesFilter({self._inner!r})'


class ChannelParticipant(TLObject):
    """
    Boxed TL type ``ChannelParticipant`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCB397619: types.ChannelParticipant,
        0x4F607BEF: types.ChannelParticipantSelf,
        0x2FE601D3: types.ChannelParticipantCreator,
        0x34C3BB53: types.ChannelParticipantAdmin,
        0x6DF8014E: types.ChannelParticipantBanned,
        0x1B03F006: types.ChannelParticipantLeft,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelParticipant':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_channel_participant(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipant)

    def as_channel_participant(self) -> Optional[types.ChannelParticipant]:
        return self._inner if self.is_channel_participant() else None

    def is_self(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantSelf)

    def as_self(self) -> Optional[types.ChannelParticipantSelf]:
        return self._inner if self.is_self() else None

    def is_creator(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantCreator)

    def as_creator(self) -> Optional[types.ChannelParticipantCreator]:
        return self._inner if self.is_creator() else None

    def is_admin(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantAdmin)

    def as_admin(self) -> Optional[types.ChannelParticipantAdmin]:
        return self._inner if self.is_admin() else None

    def is_banned(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantBanned)

    def as_banned(self) -> Optional[types.ChannelParticipantBanned]:
        return self._inner if self.is_banned() else None

    def is_left(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantLeft)

    def as_left(self) -> Optional[types.ChannelParticipantLeft]:
        return self._inner if self.is_left() else None

    def __repr__(self) -> str:
        return f'ChannelParticipant({self._inner!r})'


class ChannelParticipantsFilter(TLObject):
    """
    Boxed TL type ``ChannelParticipantsFilter`` — union of 8 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDE3F3C79: types.ChannelParticipantsRecent,
        0xB4608969: types.ChannelParticipantsAdmins,
        0xA3B54985: types.ChannelParticipantsKicked,
        0xB0D1865B: types.ChannelParticipantsBots,
        0x1427A5E1: types.ChannelParticipantsBanned,
        0x0656AC4B: types.ChannelParticipantsSearch,
        0xBB6AE88D: types.ChannelParticipantsContacts,
        0xE04B5CEB: types.ChannelParticipantsMentions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelParticipantsFilter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_channel_participants_recent(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsRecent)

    def as_channel_participants_recent(self) -> Optional[types.ChannelParticipantsRecent]:
        return self._inner if self.is_channel_participants_recent() else None

    def is_channel_participants_admins(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsAdmins)

    def as_channel_participants_admins(self) -> Optional[types.ChannelParticipantsAdmins]:
        return self._inner if self.is_channel_participants_admins() else None

    def is_channel_participants_kicked(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsKicked)

    def as_channel_participants_kicked(self) -> Optional[types.ChannelParticipantsKicked]:
        return self._inner if self.is_channel_participants_kicked() else None

    def is_channel_participants_bots(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsBots)

    def as_channel_participants_bots(self) -> Optional[types.ChannelParticipantsBots]:
        return self._inner if self.is_channel_participants_bots() else None

    def is_channel_participants_banned(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsBanned)

    def as_channel_participants_banned(self) -> Optional[types.ChannelParticipantsBanned]:
        return self._inner if self.is_channel_participants_banned() else None

    def is_channel_participants_search(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsSearch)

    def as_channel_participants_search(self) -> Optional[types.ChannelParticipantsSearch]:
        return self._inner if self.is_channel_participants_search() else None

    def is_channel_participants_contacts(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsContacts)

    def as_channel_participants_contacts(self) -> Optional[types.ChannelParticipantsContacts]:
        return self._inner if self.is_channel_participants_contacts() else None

    def is_channel_participants_mentions(self) -> bool:
        return isinstance(self._inner, types.ChannelParticipantsMentions)

    def as_channel_participants_mentions(self) -> Optional[types.ChannelParticipantsMentions]:
        return self._inner if self.is_channel_participants_mentions() else None

    def __repr__(self) -> str:
        return f'ChannelParticipantsFilter({self._inner!r})'


class Chat(TLObject):
    """
    Boxed TL type ``Chat`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x29562865: types.ChatEmpty,
        0x41CBF256: types.Chat,
        0x6592A1A7: types.ChatForbidden,
        0x1C32B11C: types.Channel,
        0x17D493D5: types.ChannelForbidden,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Chat':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.ChatEmpty)

    def as_empty(self) -> Optional[types.ChatEmpty]:
        return self._inner if self.is_empty() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.Chat)

    def as_chat(self) -> Optional[types.Chat]:
        return self._inner if self.is_chat() else None

    def is_forbidden(self) -> bool:
        return isinstance(self._inner, types.ChatForbidden)

    def as_forbidden(self) -> Optional[types.ChatForbidden]:
        return self._inner if self.is_forbidden() else None

    def is_channel(self) -> bool:
        return isinstance(self._inner, types.Channel)

    def as_channel(self) -> Optional[types.Channel]:
        return self._inner if self.is_channel() else None

    def is_channel_forbidden(self) -> bool:
        return isinstance(self._inner, types.ChannelForbidden)

    def as_channel_forbidden(self) -> Optional[types.ChannelForbidden]:
        return self._inner if self.is_channel_forbidden() else None

    def __repr__(self) -> str:
        return f'Chat({self._inner!r})'


class ChatAdminRights(TLObject):
    """
    Boxed TL type ``ChatAdminRights`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5FB224D5: types.ChatAdminRights,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatAdminRights':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_admin_rights(self) -> bool:
        return isinstance(self._inner, types.ChatAdminRights)

    def as_chat_admin_rights(self) -> Optional[types.ChatAdminRights]:
        return self._inner if self.is_chat_admin_rights() else None

    def __repr__(self) -> str:
        return f'ChatAdminRights({self._inner!r})'


class ChatAdminWithInvites(TLObject):
    """
    Boxed TL type ``ChatAdminWithInvites`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF2ECEF23: types.ChatAdminWithInvites,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatAdminWithInvites':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_admin_with_invites(self) -> bool:
        return isinstance(self._inner, types.ChatAdminWithInvites)

    def as_chat_admin_with_invites(self) -> Optional[types.ChatAdminWithInvites]:
        return self._inner if self.is_chat_admin_with_invites() else None

    def __repr__(self) -> str:
        return f'ChatAdminWithInvites({self._inner!r})'


class ChatBannedRights(TLObject):
    """
    Boxed TL type ``ChatBannedRights`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9F120418: types.ChatBannedRights,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatBannedRights':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_banned_rights(self) -> bool:
        return isinstance(self._inner, types.ChatBannedRights)

    def as_chat_banned_rights(self) -> Optional[types.ChatBannedRights]:
        return self._inner if self.is_chat_banned_rights() else None

    def __repr__(self) -> str:
        return f'ChatBannedRights({self._inner!r})'


class ChatFull(TLObject):
    """
    Boxed TL type ``ChatFull`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2633421B: types.ChatFull,
        0xE4E0B29D: types.ChannelFull,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatFull':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_full(self) -> bool:
        return isinstance(self._inner, types.ChatFull)

    def as_chat_full(self) -> Optional[types.ChatFull]:
        return self._inner if self.is_chat_full() else None

    def is_channel_full(self) -> bool:
        return isinstance(self._inner, types.ChannelFull)

    def as_channel_full(self) -> Optional[types.ChannelFull]:
        return self._inner if self.is_channel_full() else None

    def __repr__(self) -> str:
        return f'ChatFull({self._inner!r})'


class ChatInvite(TLObject):
    """
    Boxed TL type ``ChatInvite`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5A686D7C: types.ChatInviteAlready,
        0x5C9D3702: types.ChatInvite,
        0x61695CB0: types.ChatInvitePeek,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_already(self) -> bool:
        return isinstance(self._inner, types.ChatInviteAlready)

    def as_already(self) -> Optional[types.ChatInviteAlready]:
        return self._inner if self.is_already() else None

    def is_chat_invite(self) -> bool:
        return isinstance(self._inner, types.ChatInvite)

    def as_chat_invite(self) -> Optional[types.ChatInvite]:
        return self._inner if self.is_chat_invite() else None

    def is_peek(self) -> bool:
        return isinstance(self._inner, types.ChatInvitePeek)

    def as_peek(self) -> Optional[types.ChatInvitePeek]:
        return self._inner if self.is_peek() else None

    def __repr__(self) -> str:
        return f'ChatInvite({self._inner!r})'


class ChatInviteImporter(TLObject):
    """
    Boxed TL type ``ChatInviteImporter`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8C5ADFD9: types.ChatInviteImporter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatInviteImporter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_invite_importer(self) -> bool:
        return isinstance(self._inner, types.ChatInviteImporter)

    def as_chat_invite_importer(self) -> Optional[types.ChatInviteImporter]:
        return self._inner if self.is_chat_invite_importer() else None

    def __repr__(self) -> str:
        return f'ChatInviteImporter({self._inner!r})'


class ChatOnlines(TLObject):
    """
    Boxed TL type ``ChatOnlines`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF041E250: types.ChatOnlines,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatOnlines':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_onlines(self) -> bool:
        return isinstance(self._inner, types.ChatOnlines)

    def as_chat_onlines(self) -> Optional[types.ChatOnlines]:
        return self._inner if self.is_chat_onlines() else None

    def __repr__(self) -> str:
        return f'ChatOnlines({self._inner!r})'


class ChatParticipant(TLObject):
    """
    Boxed TL type ``ChatParticipant`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC02D4007: types.ChatParticipant,
        0xE46BCEE4: types.ChatParticipantCreator,
        0xA0933F5B: types.ChatParticipantAdmin,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatParticipant':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_participant(self) -> bool:
        return isinstance(self._inner, types.ChatParticipant)

    def as_chat_participant(self) -> Optional[types.ChatParticipant]:
        return self._inner if self.is_chat_participant() else None

    def is_creator(self) -> bool:
        return isinstance(self._inner, types.ChatParticipantCreator)

    def as_creator(self) -> Optional[types.ChatParticipantCreator]:
        return self._inner if self.is_creator() else None

    def is_admin(self) -> bool:
        return isinstance(self._inner, types.ChatParticipantAdmin)

    def as_admin(self) -> Optional[types.ChatParticipantAdmin]:
        return self._inner if self.is_admin() else None

    def __repr__(self) -> str:
        return f'ChatParticipant({self._inner!r})'


class ChatParticipants(TLObject):
    """
    Boxed TL type ``ChatParticipants`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8763D3E1: types.ChatParticipantsForbidden,
        0x3CBC93F8: types.ChatParticipants,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatParticipants':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_forbidden(self) -> bool:
        return isinstance(self._inner, types.ChatParticipantsForbidden)

    def as_forbidden(self) -> Optional[types.ChatParticipantsForbidden]:
        return self._inner if self.is_forbidden() else None

    def is_chat_participants(self) -> bool:
        return isinstance(self._inner, types.ChatParticipants)

    def as_chat_participants(self) -> Optional[types.ChatParticipants]:
        return self._inner if self.is_chat_participants() else None

    def __repr__(self) -> str:
        return f'ChatParticipants({self._inner!r})'


class ChatPhoto(TLObject):
    """
    Boxed TL type ``ChatPhoto`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x37C1011C: types.ChatPhotoEmpty,
        0x1C6E1C11: types.ChatPhoto,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatPhoto':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.ChatPhotoEmpty)

    def as_empty(self) -> Optional[types.ChatPhotoEmpty]:
        return self._inner if self.is_empty() else None

    def is_chat_photo(self) -> bool:
        return isinstance(self._inner, types.ChatPhoto)

    def as_chat_photo(self) -> Optional[types.ChatPhoto]:
        return self._inner if self.is_chat_photo() else None

    def __repr__(self) -> str:
        return f'ChatPhoto({self._inner!r})'


class ChatReactions(TLObject):
    """
    Boxed TL type ``ChatReactions`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEAFC32BC: types.ChatReactionsNone,
        0x52928BCA: types.ChatReactionsAll,
        0x661D4037: types.ChatReactionsSome,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatReactions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_none(self) -> bool:
        return isinstance(self._inner, types.ChatReactionsNone)

    def as_none(self) -> Optional[types.ChatReactionsNone]:
        return self._inner if self.is_none() else None

    def is_all(self) -> bool:
        return isinstance(self._inner, types.ChatReactionsAll)

    def as_all(self) -> Optional[types.ChatReactionsAll]:
        return self._inner if self.is_all() else None

    def is_some(self) -> bool:
        return isinstance(self._inner, types.ChatReactionsSome)

    def as_some(self) -> Optional[types.ChatReactionsSome]:
        return self._inner if self.is_some() else None

    def __repr__(self) -> str:
        return f'ChatReactions({self._inner!r})'


class ChatTheme(TLObject):
    """
    Boxed TL type ``ChatTheme`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC3DFFC04: types.ChatTheme,
        0x3458F9C8: types.ChatThemeUniqueGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatTheme':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_theme(self) -> bool:
        return isinstance(self._inner, types.ChatTheme)

    def as_chat_theme(self) -> Optional[types.ChatTheme]:
        return self._inner if self.is_chat_theme() else None

    def is_unique_gift(self) -> bool:
        return isinstance(self._inner, types.ChatThemeUniqueGift)

    def as_unique_gift(self) -> Optional[types.ChatThemeUniqueGift]:
        return self._inner if self.is_unique_gift() else None

    def __repr__(self) -> str:
        return f'ChatTheme({self._inner!r})'


class CodeSettings(TLObject):
    """
    Boxed TL type ``CodeSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAD253D78: types.CodeSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CodeSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_code_settings(self) -> bool:
        return isinstance(self._inner, types.CodeSettings)

    def as_code_settings(self) -> Optional[types.CodeSettings]:
        return self._inner if self.is_code_settings() else None

    def __repr__(self) -> str:
        return f'CodeSettings({self._inner!r})'


class Config(TLObject):
    """
    Boxed TL type ``Config`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCC1A241E: types.Config,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Config':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_config(self) -> bool:
        return isinstance(self._inner, types.Config)

    def as_config(self) -> Optional[types.Config]:
        return self._inner if self.is_config() else None

    def __repr__(self) -> str:
        return f'Config({self._inner!r})'


class ConnectedBot(TLObject):
    """
    Boxed TL type ``ConnectedBot`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCD64636C: types.ConnectedBot,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ConnectedBot':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_connected_bot(self) -> bool:
        return isinstance(self._inner, types.ConnectedBot)

    def as_connected_bot(self) -> Optional[types.ConnectedBot]:
        return self._inner if self.is_connected_bot() else None

    def __repr__(self) -> str:
        return f'ConnectedBot({self._inner!r})'


class ConnectedBotStarRef(TLObject):
    """
    Boxed TL type ``ConnectedBotStarRef`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x19A13F71: types.ConnectedBotStarRef,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ConnectedBotStarRef':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_connected_bot_star_ref(self) -> bool:
        return isinstance(self._inner, types.ConnectedBotStarRef)

    def as_connected_bot_star_ref(self) -> Optional[types.ConnectedBotStarRef]:
        return self._inner if self.is_connected_bot_star_ref() else None

    def __repr__(self) -> str:
        return f'ConnectedBotStarRef({self._inner!r})'


class Contact(TLObject):
    """
    Boxed TL type ``Contact`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x145ADE0B: types.Contact,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Contact':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_contact(self) -> bool:
        return isinstance(self._inner, types.Contact)

    def as_contact(self) -> Optional[types.Contact]:
        return self._inner if self.is_contact() else None

    def __repr__(self) -> str:
        return f'Contact({self._inner!r})'


class ContactBirthday(TLObject):
    """
    Boxed TL type ``ContactBirthday`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1D998733: types.ContactBirthday,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ContactBirthday':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_contact_birthday(self) -> bool:
        return isinstance(self._inner, types.ContactBirthday)

    def as_contact_birthday(self) -> Optional[types.ContactBirthday]:
        return self._inner if self.is_contact_birthday() else None

    def __repr__(self) -> str:
        return f'ContactBirthday({self._inner!r})'


class ContactStatus(TLObject):
    """
    Boxed TL type ``ContactStatus`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x16D9703B: types.ContactStatus,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ContactStatus':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_contact_status(self) -> bool:
        return isinstance(self._inner, types.ContactStatus)

    def as_contact_status(self) -> Optional[types.ContactStatus]:
        return self._inner if self.is_contact_status() else None

    def __repr__(self) -> str:
        return f'ContactStatus({self._inner!r})'


class DataJson(TLObject):
    """
    Boxed TL type ``DataJSON`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7D748D04: types.DataJson,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DataJson':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_data_json(self) -> bool:
        return isinstance(self._inner, types.DataJson)

    def as_data_json(self) -> Optional[types.DataJson]:
        return self._inner if self.is_data_json() else None

    def __repr__(self) -> str:
        return f'DataJson({self._inner!r})'


class DcOption(TLObject):
    """
    Boxed TL type ``DcOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x18B7A10D: types.DcOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DcOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dc_option(self) -> bool:
        return isinstance(self._inner, types.DcOption)

    def as_dc_option(self) -> Optional[types.DcOption]:
        return self._inner if self.is_dc_option() else None

    def __repr__(self) -> str:
        return f'DcOption({self._inner!r})'


class DefaultHistoryTtl(TLObject):
    """
    Boxed TL type ``DefaultHistoryTTL`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x43B46B20: types.DefaultHistoryTtl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DefaultHistoryTtl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_default_history_ttl(self) -> bool:
        return isinstance(self._inner, types.DefaultHistoryTtl)

    def as_default_history_ttl(self) -> Optional[types.DefaultHistoryTtl]:
        return self._inner if self.is_default_history_ttl() else None

    def __repr__(self) -> str:
        return f'DefaultHistoryTtl({self._inner!r})'


class Dialog(TLObject):
    """
    Boxed TL type ``Dialog`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD58A08C6: types.Dialog,
        0x71BD134C: types.DialogFolder,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Dialog':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialog(self) -> bool:
        return isinstance(self._inner, types.Dialog)

    def as_dialog(self) -> Optional[types.Dialog]:
        return self._inner if self.is_dialog() else None

    def is_folder(self) -> bool:
        return isinstance(self._inner, types.DialogFolder)

    def as_folder(self) -> Optional[types.DialogFolder]:
        return self._inner if self.is_folder() else None

    def __repr__(self) -> str:
        return f'Dialog({self._inner!r})'


class DialogFilter(TLObject):
    """
    Boxed TL type ``DialogFilter`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAA472651: types.DialogFilter,
        0x363293AE: types.DialogFilterDefault,
        0x96537BD7: types.DialogFilterChatlist,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DialogFilter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialog_filter(self) -> bool:
        return isinstance(self._inner, types.DialogFilter)

    def as_dialog_filter(self) -> Optional[types.DialogFilter]:
        return self._inner if self.is_dialog_filter() else None

    def is_default(self) -> bool:
        return isinstance(self._inner, types.DialogFilterDefault)

    def as_default(self) -> Optional[types.DialogFilterDefault]:
        return self._inner if self.is_default() else None

    def is_chatlist(self) -> bool:
        return isinstance(self._inner, types.DialogFilterChatlist)

    def as_chatlist(self) -> Optional[types.DialogFilterChatlist]:
        return self._inner if self.is_chatlist() else None

    def __repr__(self) -> str:
        return f'DialogFilter({self._inner!r})'


class DialogFilterSuggested(TLObject):
    """
    Boxed TL type ``DialogFilterSuggested`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x77744D4A: types.DialogFilterSuggested,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DialogFilterSuggested':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialog_filter_suggested(self) -> bool:
        return isinstance(self._inner, types.DialogFilterSuggested)

    def as_dialog_filter_suggested(self) -> Optional[types.DialogFilterSuggested]:
        return self._inner if self.is_dialog_filter_suggested() else None

    def __repr__(self) -> str:
        return f'DialogFilterSuggested({self._inner!r})'


class DialogPeer(TLObject):
    """
    Boxed TL type ``DialogPeer`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE56DBF05: types.DialogPeer,
        0x514519E2: types.DialogPeerFolder,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DialogPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialog_peer(self) -> bool:
        return isinstance(self._inner, types.DialogPeer)

    def as_dialog_peer(self) -> Optional[types.DialogPeer]:
        return self._inner if self.is_dialog_peer() else None

    def is_folder(self) -> bool:
        return isinstance(self._inner, types.DialogPeerFolder)

    def as_folder(self) -> Optional[types.DialogPeerFolder]:
        return self._inner if self.is_folder() else None

    def __repr__(self) -> str:
        return f'DialogPeer({self._inner!r})'


class DisallowedGiftsSettings(TLObject):
    """
    Boxed TL type ``DisallowedGiftsSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x71F276C4: types.DisallowedGiftsSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DisallowedGiftsSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_disallowed_gifts_settings(self) -> bool:
        return isinstance(self._inner, types.DisallowedGiftsSettings)

    def as_disallowed_gifts_settings(self) -> Optional[types.DisallowedGiftsSettings]:
        return self._inner if self.is_disallowed_gifts_settings() else None

    def __repr__(self) -> str:
        return f'DisallowedGiftsSettings({self._inner!r})'


class Document(TLObject):
    """
    Boxed TL type ``Document`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x36F8C871: types.DocumentEmpty,
        0x8FD4C4D8: types.Document,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Document':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.DocumentEmpty)

    def as_empty(self) -> Optional[types.DocumentEmpty]:
        return self._inner if self.is_empty() else None

    def is_document(self) -> bool:
        return isinstance(self._inner, types.Document)

    def as_document(self) -> Optional[types.Document]:
        return self._inner if self.is_document() else None

    def __repr__(self) -> str:
        return f'Document({self._inner!r})'


class DocumentAttribute(TLObject):
    """
    Boxed TL type ``DocumentAttribute`` — union of 8 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6C37C15C: types.DocumentAttributeImageSize,
        0x11B58939: types.DocumentAttributeAnimated,
        0x6319D612: types.DocumentAttributeSticker,
        0x43C57C48: types.DocumentAttributeVideo,
        0x9852F9C6: types.DocumentAttributeAudio,
        0x15590068: types.DocumentAttributeFilename,
        0x9801D2F7: types.DocumentAttributeHasStickers,
        0xFD149899: types.DocumentAttributeCustomEmoji,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DocumentAttribute':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_image_size(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeImageSize)

    def as_image_size(self) -> Optional[types.DocumentAttributeImageSize]:
        return self._inner if self.is_image_size() else None

    def is_animated(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeAnimated)

    def as_animated(self) -> Optional[types.DocumentAttributeAnimated]:
        return self._inner if self.is_animated() else None

    def is_sticker(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeSticker)

    def as_sticker(self) -> Optional[types.DocumentAttributeSticker]:
        return self._inner if self.is_sticker() else None

    def is_video(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeVideo)

    def as_video(self) -> Optional[types.DocumentAttributeVideo]:
        return self._inner if self.is_video() else None

    def is_audio(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeAudio)

    def as_audio(self) -> Optional[types.DocumentAttributeAudio]:
        return self._inner if self.is_audio() else None

    def is_filename(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeFilename)

    def as_filename(self) -> Optional[types.DocumentAttributeFilename]:
        return self._inner if self.is_filename() else None

    def is_has_stickers(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeHasStickers)

    def as_has_stickers(self) -> Optional[types.DocumentAttributeHasStickers]:
        return self._inner if self.is_has_stickers() else None

    def is_custom_emoji(self) -> bool:
        return isinstance(self._inner, types.DocumentAttributeCustomEmoji)

    def as_custom_emoji(self) -> Optional[types.DocumentAttributeCustomEmoji]:
        return self._inner if self.is_custom_emoji() else None

    def __repr__(self) -> str:
        return f'DocumentAttribute({self._inner!r})'


class DraftMessage(TLObject):
    """
    Boxed TL type ``DraftMessage`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1B0C841A: types.DraftMessageEmpty,
        0x96EAA5EB: types.DraftMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DraftMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.DraftMessageEmpty)

    def as_empty(self) -> Optional[types.DraftMessageEmpty]:
        return self._inner if self.is_empty() else None

    def is_draft_message(self) -> bool:
        return isinstance(self._inner, types.DraftMessage)

    def as_draft_message(self) -> Optional[types.DraftMessage]:
        return self._inner if self.is_draft_message() else None

    def __repr__(self) -> str:
        return f'DraftMessage({self._inner!r})'


class EmailVerification(TLObject):
    """
    Boxed TL type ``EmailVerification`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x922E55A9: types.EmailVerificationCode,
        0xDB909EC2: types.EmailVerificationGoogle,
        0x96D074FD: types.EmailVerificationApple,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmailVerification':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_code(self) -> bool:
        return isinstance(self._inner, types.EmailVerificationCode)

    def as_code(self) -> Optional[types.EmailVerificationCode]:
        return self._inner if self.is_code() else None

    def is_google(self) -> bool:
        return isinstance(self._inner, types.EmailVerificationGoogle)

    def as_google(self) -> Optional[types.EmailVerificationGoogle]:
        return self._inner if self.is_google() else None

    def is_apple(self) -> bool:
        return isinstance(self._inner, types.EmailVerificationApple)

    def as_apple(self) -> Optional[types.EmailVerificationApple]:
        return self._inner if self.is_apple() else None

    def __repr__(self) -> str:
        return f'EmailVerification({self._inner!r})'


class EmailVerifyPurpose(TLObject):
    """
    Boxed TL type ``EmailVerifyPurpose`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4345BE73: types.EmailVerifyPurposeLoginSetup,
        0x527D22EB: types.EmailVerifyPurposeLoginChange,
        0xBBF51685: types.EmailVerifyPurposePassport,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmailVerifyPurpose':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_login_setup(self) -> bool:
        return isinstance(self._inner, types.EmailVerifyPurposeLoginSetup)

    def as_login_setup(self) -> Optional[types.EmailVerifyPurposeLoginSetup]:
        return self._inner if self.is_login_setup() else None

    def is_login_change(self) -> bool:
        return isinstance(self._inner, types.EmailVerifyPurposeLoginChange)

    def as_login_change(self) -> Optional[types.EmailVerifyPurposeLoginChange]:
        return self._inner if self.is_login_change() else None

    def is_passport(self) -> bool:
        return isinstance(self._inner, types.EmailVerifyPurposePassport)

    def as_passport(self) -> Optional[types.EmailVerifyPurposePassport]:
        return self._inner if self.is_passport() else None

    def __repr__(self) -> str:
        return f'EmailVerifyPurpose({self._inner!r})'


class EmojiGroup(TLObject):
    """
    Boxed TL type ``EmojiGroup`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7A9ABDA9: types.EmojiGroup,
        0x80D26CC7: types.EmojiGroupGreeting,
        0x093BCF34: types.EmojiGroupPremium,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiGroup':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_group(self) -> bool:
        return isinstance(self._inner, types.EmojiGroup)

    def as_emoji_group(self) -> Optional[types.EmojiGroup]:
        return self._inner if self.is_emoji_group() else None

    def is_greeting(self) -> bool:
        return isinstance(self._inner, types.EmojiGroupGreeting)

    def as_greeting(self) -> Optional[types.EmojiGroupGreeting]:
        return self._inner if self.is_greeting() else None

    def is_premium(self) -> bool:
        return isinstance(self._inner, types.EmojiGroupPremium)

    def as_premium(self) -> Optional[types.EmojiGroupPremium]:
        return self._inner if self.is_premium() else None

    def __repr__(self) -> str:
        return f'EmojiGroup({self._inner!r})'


class EmojiKeyword(TLObject):
    """
    Boxed TL type ``EmojiKeyword`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD5B3B9F9: types.EmojiKeyword,
        0x236DF622: types.EmojiKeywordDeleted,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiKeyword':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_keyword(self) -> bool:
        return isinstance(self._inner, types.EmojiKeyword)

    def as_emoji_keyword(self) -> Optional[types.EmojiKeyword]:
        return self._inner if self.is_emoji_keyword() else None

    def is_deleted(self) -> bool:
        return isinstance(self._inner, types.EmojiKeywordDeleted)

    def as_deleted(self) -> Optional[types.EmojiKeywordDeleted]:
        return self._inner if self.is_deleted() else None

    def __repr__(self) -> str:
        return f'EmojiKeyword({self._inner!r})'


class EmojiKeywordsDifference(TLObject):
    """
    Boxed TL type ``EmojiKeywordsDifference`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5CC761BD: types.EmojiKeywordsDifference,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiKeywordsDifference':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_keywords_difference(self) -> bool:
        return isinstance(self._inner, types.EmojiKeywordsDifference)

    def as_emoji_keywords_difference(self) -> Optional[types.EmojiKeywordsDifference]:
        return self._inner if self.is_emoji_keywords_difference() else None

    def __repr__(self) -> str:
        return f'EmojiKeywordsDifference({self._inner!r})'


class EmojiLanguage(TLObject):
    """
    Boxed TL type ``EmojiLanguage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB3FB5361: types.EmojiLanguage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiLanguage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_language(self) -> bool:
        return isinstance(self._inner, types.EmojiLanguage)

    def as_emoji_language(self) -> Optional[types.EmojiLanguage]:
        return self._inner if self.is_emoji_language() else None

    def __repr__(self) -> str:
        return f'EmojiLanguage({self._inner!r})'


class EmojiList(TLObject):
    """
    Boxed TL type ``EmojiList`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x481EADFA: types.EmojiListNotModified,
        0x7A1E11D1: types.EmojiList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.EmojiListNotModified)

    def as_not_modified(self) -> Optional[types.EmojiListNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_emoji_list(self) -> bool:
        return isinstance(self._inner, types.EmojiList)

    def as_emoji_list(self) -> Optional[types.EmojiList]:
        return self._inner if self.is_emoji_list() else None

    def __repr__(self) -> str:
        return f'EmojiList({self._inner!r})'


class EmojiStatus(TLObject):
    """
    Boxed TL type ``EmojiStatus`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2DE11AAE: types.EmojiStatusEmpty,
        0xE7FF068A: types.EmojiStatus,
        0x7184603B: types.EmojiStatusCollectible,
        0x07141DBF: types.InputEmojiStatusCollectible,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiStatus':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.EmojiStatusEmpty)

    def as_empty(self) -> Optional[types.EmojiStatusEmpty]:
        return self._inner if self.is_empty() else None

    def is_emoji_status(self) -> bool:
        return isinstance(self._inner, types.EmojiStatus)

    def as_emoji_status(self) -> Optional[types.EmojiStatus]:
        return self._inner if self.is_emoji_status() else None

    def is_collectible(self) -> bool:
        return isinstance(self._inner, types.EmojiStatusCollectible)

    def as_collectible(self) -> Optional[types.EmojiStatusCollectible]:
        return self._inner if self.is_collectible() else None

    def is_input_emoji_status_collectible(self) -> bool:
        return isinstance(self._inner, types.InputEmojiStatusCollectible)

    def as_input_emoji_status_collectible(self) -> Optional[types.InputEmojiStatusCollectible]:
        return self._inner if self.is_input_emoji_status_collectible() else None

    def __repr__(self) -> str:
        return f'EmojiStatus({self._inner!r})'


class EmojiUrl(TLObject):
    """
    Boxed TL type ``EmojiURL`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA575739D: types.EmojiUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_url(self) -> bool:
        return isinstance(self._inner, types.EmojiUrl)

    def as_emoji_url(self) -> Optional[types.EmojiUrl]:
        return self._inner if self.is_emoji_url() else None

    def __repr__(self) -> str:
        return f'EmojiUrl({self._inner!r})'


class EncryptedChat(TLObject):
    """
    Boxed TL type ``EncryptedChat`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAB7EC0A0: types.EncryptedChatEmpty,
        0x66B25953: types.EncryptedChatWaiting,
        0x48F1D94C: types.EncryptedChatRequested,
        0x61F0D4C7: types.EncryptedChat,
        0x1E1C7C45: types.EncryptedChatDiscarded,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EncryptedChat':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.EncryptedChatEmpty)

    def as_empty(self) -> Optional[types.EncryptedChatEmpty]:
        return self._inner if self.is_empty() else None

    def is_waiting(self) -> bool:
        return isinstance(self._inner, types.EncryptedChatWaiting)

    def as_waiting(self) -> Optional[types.EncryptedChatWaiting]:
        return self._inner if self.is_waiting() else None

    def is_requested(self) -> bool:
        return isinstance(self._inner, types.EncryptedChatRequested)

    def as_requested(self) -> Optional[types.EncryptedChatRequested]:
        return self._inner if self.is_requested() else None

    def is_encrypted_chat(self) -> bool:
        return isinstance(self._inner, types.EncryptedChat)

    def as_encrypted_chat(self) -> Optional[types.EncryptedChat]:
        return self._inner if self.is_encrypted_chat() else None

    def is_discarded(self) -> bool:
        return isinstance(self._inner, types.EncryptedChatDiscarded)

    def as_discarded(self) -> Optional[types.EncryptedChatDiscarded]:
        return self._inner if self.is_discarded() else None

    def __repr__(self) -> str:
        return f'EncryptedChat({self._inner!r})'


class EncryptedFile(TLObject):
    """
    Boxed TL type ``EncryptedFile`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC21F497E: types.EncryptedFileEmpty,
        0xA8008CD8: types.EncryptedFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EncryptedFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.EncryptedFileEmpty)

    def as_empty(self) -> Optional[types.EncryptedFileEmpty]:
        return self._inner if self.is_empty() else None

    def is_encrypted_file(self) -> bool:
        return isinstance(self._inner, types.EncryptedFile)

    def as_encrypted_file(self) -> Optional[types.EncryptedFile]:
        return self._inner if self.is_encrypted_file() else None

    def __repr__(self) -> str:
        return f'EncryptedFile({self._inner!r})'


class EncryptedMessage(TLObject):
    """
    Boxed TL type ``EncryptedMessage`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xED18C118: types.EncryptedMessage,
        0x23734B06: types.EncryptedMessageService,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EncryptedMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_encrypted_message(self) -> bool:
        return isinstance(self._inner, types.EncryptedMessage)

    def as_encrypted_message(self) -> Optional[types.EncryptedMessage]:
        return self._inner if self.is_encrypted_message() else None

    def is_service(self) -> bool:
        return isinstance(self._inner, types.EncryptedMessageService)

    def as_service(self) -> Optional[types.EncryptedMessageService]:
        return self._inner if self.is_service() else None

    def __repr__(self) -> str:
        return f'EncryptedMessage({self._inner!r})'


class Error(TLObject):
    """
    Boxed TL type ``Error`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC4B9F9BB: types.Error,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Error':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_error(self) -> bool:
        return isinstance(self._inner, types.Error)

    def as_error(self) -> Optional[types.Error]:
        return self._inner if self.is_error() else None

    def __repr__(self) -> str:
        return f'Error({self._inner!r})'


class ExportedChatInvite(TLObject):
    """
    Boxed TL type ``ExportedChatInvite`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA22CBD96: types.ChatInviteExported,
        0xED107AB7: types.ChatInvitePublicJoinRequests,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedChatInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_invite_exported(self) -> bool:
        return isinstance(self._inner, types.ChatInviteExported)

    def as_chat_invite_exported(self) -> Optional[types.ChatInviteExported]:
        return self._inner if self.is_chat_invite_exported() else None

    def is_chat_invite_public_join_requests(self) -> bool:
        return isinstance(self._inner, types.ChatInvitePublicJoinRequests)

    def as_chat_invite_public_join_requests(self) -> Optional[types.ChatInvitePublicJoinRequests]:
        return self._inner if self.is_chat_invite_public_join_requests() else None

    def __repr__(self) -> str:
        return f'ExportedChatInvite({self._inner!r})'


class ExportedChatlistInvite(TLObject):
    """
    Boxed TL type ``ExportedChatlistInvite`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0C5181AC: types.ExportedChatlistInvite,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedChatlistInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_chatlist_invite(self) -> bool:
        return isinstance(self._inner, types.ExportedChatlistInvite)

    def as_exported_chatlist_invite(self) -> Optional[types.ExportedChatlistInvite]:
        return self._inner if self.is_exported_chatlist_invite() else None

    def __repr__(self) -> str:
        return f'ExportedChatlistInvite({self._inner!r})'


class ExportedContactToken(TLObject):
    """
    Boxed TL type ``ExportedContactToken`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x41BF109B: types.ExportedContactToken,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedContactToken':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_contact_token(self) -> bool:
        return isinstance(self._inner, types.ExportedContactToken)

    def as_exported_contact_token(self) -> Optional[types.ExportedContactToken]:
        return self._inner if self.is_exported_contact_token() else None

    def __repr__(self) -> str:
        return f'ExportedContactToken({self._inner!r})'


class ExportedMessageLink(TLObject):
    """
    Boxed TL type ``ExportedMessageLink`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5DAB1AF4: types.ExportedMessageLink,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedMessageLink':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_message_link(self) -> bool:
        return isinstance(self._inner, types.ExportedMessageLink)

    def as_exported_message_link(self) -> Optional[types.ExportedMessageLink]:
        return self._inner if self.is_exported_message_link() else None

    def __repr__(self) -> str:
        return f'ExportedMessageLink({self._inner!r})'


class ExportedStoryLink(TLObject):
    """
    Boxed TL type ``ExportedStoryLink`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3FC9053B: types.ExportedStoryLink,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedStoryLink':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_story_link(self) -> bool:
        return isinstance(self._inner, types.ExportedStoryLink)

    def as_exported_story_link(self) -> Optional[types.ExportedStoryLink]:
        return self._inner if self.is_exported_story_link() else None

    def __repr__(self) -> str:
        return f'ExportedStoryLink({self._inner!r})'


class FactCheck(TLObject):
    """
    Boxed TL type ``FactCheck`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB89BFCCF: types.FactCheck,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FactCheck':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_fact_check(self) -> bool:
        return isinstance(self._inner, types.FactCheck)

    def as_fact_check(self) -> Optional[types.FactCheck]:
        return self._inner if self.is_fact_check() else None

    def __repr__(self) -> str:
        return f'FactCheck({self._inner!r})'


class FileHash(TLObject):
    """
    Boxed TL type ``FileHash`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF39B035C: types.FileHash,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FileHash':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_file_hash(self) -> bool:
        return isinstance(self._inner, types.FileHash)

    def as_file_hash(self) -> Optional[types.FileHash]:
        return self._inner if self.is_file_hash() else None

    def __repr__(self) -> str:
        return f'FileHash({self._inner!r})'


class Folder(TLObject):
    """
    Boxed TL type ``Folder`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFF544E65: types.Folder,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Folder':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_folder(self) -> bool:
        return isinstance(self._inner, types.Folder)

    def as_folder(self) -> Optional[types.Folder]:
        return self._inner if self.is_folder() else None

    def __repr__(self) -> str:
        return f'Folder({self._inner!r})'


class FolderPeer(TLObject):
    """
    Boxed TL type ``FolderPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE9BAA668: types.FolderPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FolderPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_folder_peer(self) -> bool:
        return isinstance(self._inner, types.FolderPeer)

    def as_folder_peer(self) -> Optional[types.FolderPeer]:
        return self._inner if self.is_folder_peer() else None

    def __repr__(self) -> str:
        return f'FolderPeer({self._inner!r})'


class ForumTopic(TLObject):
    """
    Boxed TL type ``ForumTopic`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x023F109B: types.ForumTopicDeleted,
        0xCDFF0ECA: types.ForumTopic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ForumTopic':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_deleted(self) -> bool:
        return isinstance(self._inner, types.ForumTopicDeleted)

    def as_deleted(self) -> Optional[types.ForumTopicDeleted]:
        return self._inner if self.is_deleted() else None

    def is_forum_topic(self) -> bool:
        return isinstance(self._inner, types.ForumTopic)

    def as_forum_topic(self) -> Optional[types.ForumTopic]:
        return self._inner if self.is_forum_topic() else None

    def __repr__(self) -> str:
        return f'ForumTopic({self._inner!r})'


class FoundStory(TLObject):
    """
    Boxed TL type ``FoundStory`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE87ACBC0: types.FoundStory,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FoundStory':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_found_story(self) -> bool:
        return isinstance(self._inner, types.FoundStory)

    def as_found_story(self) -> Optional[types.FoundStory]:
        return self._inner if self.is_found_story() else None

    def __repr__(self) -> str:
        return f'FoundStory({self._inner!r})'


class Game(TLObject):
    """
    Boxed TL type ``Game`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBDF9653B: types.Game,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Game':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_game(self) -> bool:
        return isinstance(self._inner, types.Game)

    def as_game(self) -> Optional[types.Game]:
        return self._inner if self.is_game() else None

    def __repr__(self) -> str:
        return f'Game({self._inner!r})'


class GeoPoint(TLObject):
    """
    Boxed TL type ``GeoPoint`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1117DD5F: types.GeoPointEmpty,
        0xB2A2F663: types.GeoPoint,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GeoPoint':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.GeoPointEmpty)

    def as_empty(self) -> Optional[types.GeoPointEmpty]:
        return self._inner if self.is_empty() else None

    def is_geo_point(self) -> bool:
        return isinstance(self._inner, types.GeoPoint)

    def as_geo_point(self) -> Optional[types.GeoPoint]:
        return self._inner if self.is_geo_point() else None

    def __repr__(self) -> str:
        return f'GeoPoint({self._inner!r})'


class GeoPointAddress(TLObject):
    """
    Boxed TL type ``GeoPointAddress`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDE4C5D93: types.GeoPointAddress,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GeoPointAddress':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_geo_point_address(self) -> bool:
        return isinstance(self._inner, types.GeoPointAddress)

    def as_geo_point_address(self) -> Optional[types.GeoPointAddress]:
        return self._inner if self.is_geo_point_address() else None

    def __repr__(self) -> str:
        return f'GeoPointAddress({self._inner!r})'


class GlobalPrivacySettings(TLObject):
    """
    Boxed TL type ``GlobalPrivacySettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFE41B34F: types.GlobalPrivacySettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GlobalPrivacySettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_global_privacy_settings(self) -> bool:
        return isinstance(self._inner, types.GlobalPrivacySettings)

    def as_global_privacy_settings(self) -> Optional[types.GlobalPrivacySettings]:
        return self._inner if self.is_global_privacy_settings() else None

    def __repr__(self) -> str:
        return f'GlobalPrivacySettings({self._inner!r})'


class GroupCall(TLObject):
    """
    Boxed TL type ``GroupCall`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7780BCB4: types.GroupCallDiscarded,
        0xEFB2B617: types.GroupCall,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCall':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_discarded(self) -> bool:
        return isinstance(self._inner, types.GroupCallDiscarded)

    def as_discarded(self) -> Optional[types.GroupCallDiscarded]:
        return self._inner if self.is_discarded() else None

    def is_group_call(self) -> bool:
        return isinstance(self._inner, types.GroupCall)

    def as_group_call(self) -> Optional[types.GroupCall]:
        return self._inner if self.is_group_call() else None

    def __repr__(self) -> str:
        return f'GroupCall({self._inner!r})'


class GroupCallDonor(TLObject):
    """
    Boxed TL type ``GroupCallDonor`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEE430C85: types.GroupCallDonor,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallDonor':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_donor(self) -> bool:
        return isinstance(self._inner, types.GroupCallDonor)

    def as_group_call_donor(self) -> Optional[types.GroupCallDonor]:
        return self._inner if self.is_group_call_donor() else None

    def __repr__(self) -> str:
        return f'GroupCallDonor({self._inner!r})'


class GroupCallMessage(TLObject):
    """
    Boxed TL type ``GroupCallMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1A8AFC7E: types.GroupCallMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_message(self) -> bool:
        return isinstance(self._inner, types.GroupCallMessage)

    def as_group_call_message(self) -> Optional[types.GroupCallMessage]:
        return self._inner if self.is_group_call_message() else None

    def __repr__(self) -> str:
        return f'GroupCallMessage({self._inner!r})'


class GroupCallParticipant(TLObject):
    """
    Boxed TL type ``GroupCallParticipant`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2A3DC7AC: types.GroupCallParticipant,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallParticipant':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_participant(self) -> bool:
        return isinstance(self._inner, types.GroupCallParticipant)

    def as_group_call_participant(self) -> Optional[types.GroupCallParticipant]:
        return self._inner if self.is_group_call_participant() else None

    def __repr__(self) -> str:
        return f'GroupCallParticipant({self._inner!r})'


class GroupCallParticipantVideo(TLObject):
    """
    Boxed TL type ``GroupCallParticipantVideo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x67753AC8: types.GroupCallParticipantVideo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallParticipantVideo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_participant_video(self) -> bool:
        return isinstance(self._inner, types.GroupCallParticipantVideo)

    def as_group_call_participant_video(self) -> Optional[types.GroupCallParticipantVideo]:
        return self._inner if self.is_group_call_participant_video() else None

    def __repr__(self) -> str:
        return f'GroupCallParticipantVideo({self._inner!r})'


class GroupCallParticipantVideoSourceGroup(TLObject):
    """
    Boxed TL type ``GroupCallParticipantVideoSourceGroup`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDCB118B7: types.GroupCallParticipantVideoSourceGroup,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallParticipantVideoSourceGroup':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_participant_video_source_group(self) -> bool:
        return isinstance(self._inner, types.GroupCallParticipantVideoSourceGroup)

    def as_group_call_participant_video_source_group(self) -> Optional[types.GroupCallParticipantVideoSourceGroup]:
        return self._inner if self.is_group_call_participant_video_source_group() else None

    def __repr__(self) -> str:
        return f'GroupCallParticipantVideoSourceGroup({self._inner!r})'


class GroupCallStreamChannel(TLObject):
    """
    Boxed TL type ``GroupCallStreamChannel`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x80EB48AF: types.GroupCallStreamChannel,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallStreamChannel':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_stream_channel(self) -> bool:
        return isinstance(self._inner, types.GroupCallStreamChannel)

    def as_group_call_stream_channel(self) -> Optional[types.GroupCallStreamChannel]:
        return self._inner if self.is_group_call_stream_channel() else None

    def __repr__(self) -> str:
        return f'GroupCallStreamChannel({self._inner!r})'


class HighScore(TLObject):
    """
    Boxed TL type ``HighScore`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x73A379EB: types.HighScore,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'HighScore':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_high_score(self) -> bool:
        return isinstance(self._inner, types.HighScore)

    def as_high_score(self) -> Optional[types.HighScore]:
        return self._inner if self.is_high_score() else None

    def __repr__(self) -> str:
        return f'HighScore({self._inner!r})'


class ImportedContact(TLObject):
    """
    Boxed TL type ``ImportedContact`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC13E3C50: types.ImportedContact,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ImportedContact':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_imported_contact(self) -> bool:
        return isinstance(self._inner, types.ImportedContact)

    def as_imported_contact(self) -> Optional[types.ImportedContact]:
        return self._inner if self.is_imported_contact() else None

    def __repr__(self) -> str:
        return f'ImportedContact({self._inner!r})'


class InlineBotSwitchPm(TLObject):
    """
    Boxed TL type ``InlineBotSwitchPM`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3C20629F: types.InlineBotSwitchPm,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InlineBotSwitchPm':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_inline_bot_switch_pm(self) -> bool:
        return isinstance(self._inner, types.InlineBotSwitchPm)

    def as_inline_bot_switch_pm(self) -> Optional[types.InlineBotSwitchPm]:
        return self._inner if self.is_inline_bot_switch_pm() else None

    def __repr__(self) -> str:
        return f'InlineBotSwitchPm({self._inner!r})'


class InlineBotWebView(TLObject):
    """
    Boxed TL type ``InlineBotWebView`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB57295D5: types.InlineBotWebView,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InlineBotWebView':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_inline_bot_web_view(self) -> bool:
        return isinstance(self._inner, types.InlineBotWebView)

    def as_inline_bot_web_view(self) -> Optional[types.InlineBotWebView]:
        return self._inner if self.is_inline_bot_web_view() else None

    def __repr__(self) -> str:
        return f'InlineBotWebView({self._inner!r})'


class InlineQueryPeerType(TLObject):
    """
    Boxed TL type ``InlineQueryPeerType`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3081ED9D: types.InlineQueryPeerTypeSameBotPm,
        0x833C0FAC: types.InlineQueryPeerTypePm,
        0xD766C50A: types.InlineQueryPeerTypeChat,
        0x5EC4BE43: types.InlineQueryPeerTypeMegagroup,
        0x6334EE9A: types.InlineQueryPeerTypeBroadcast,
        0x0E3B2D0C: types.InlineQueryPeerTypeBotPm,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InlineQueryPeerType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_same_bot_pm(self) -> bool:
        return isinstance(self._inner, types.InlineQueryPeerTypeSameBotPm)

    def as_same_bot_pm(self) -> Optional[types.InlineQueryPeerTypeSameBotPm]:
        return self._inner if self.is_same_bot_pm() else None

    def is_pm(self) -> bool:
        return isinstance(self._inner, types.InlineQueryPeerTypePm)

    def as_pm(self) -> Optional[types.InlineQueryPeerTypePm]:
        return self._inner if self.is_pm() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.InlineQueryPeerTypeChat)

    def as_chat(self) -> Optional[types.InlineQueryPeerTypeChat]:
        return self._inner if self.is_chat() else None

    def is_megagroup(self) -> bool:
        return isinstance(self._inner, types.InlineQueryPeerTypeMegagroup)

    def as_megagroup(self) -> Optional[types.InlineQueryPeerTypeMegagroup]:
        return self._inner if self.is_megagroup() else None

    def is_broadcast(self) -> bool:
        return isinstance(self._inner, types.InlineQueryPeerTypeBroadcast)

    def as_broadcast(self) -> Optional[types.InlineQueryPeerTypeBroadcast]:
        return self._inner if self.is_broadcast() else None

    def is_bot_pm(self) -> bool:
        return isinstance(self._inner, types.InlineQueryPeerTypeBotPm)

    def as_bot_pm(self) -> Optional[types.InlineQueryPeerTypeBotPm]:
        return self._inner if self.is_bot_pm() else None

    def __repr__(self) -> str:
        return f'InlineQueryPeerType({self._inner!r})'


class InputAppEvent(TLObject):
    """
    Boxed TL type ``InputAppEvent`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1D1B1245: types.InputAppEvent,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputAppEvent':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_app_event(self) -> bool:
        return isinstance(self._inner, types.InputAppEvent)

    def as_input_app_event(self) -> Optional[types.InputAppEvent]:
        return self._inner if self.is_input_app_event() else None

    def __repr__(self) -> str:
        return f'InputAppEvent({self._inner!r})'


class InputBotApp(TLObject):
    """
    Boxed TL type ``InputBotApp`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA920BD7A: types.InputBotAppId,
        0x908C0407: types.InputBotAppShortName,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBotApp':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_id(self) -> bool:
        return isinstance(self._inner, types.InputBotAppId)

    def as_id(self) -> Optional[types.InputBotAppId]:
        return self._inner if self.is_id() else None

    def is_short_name(self) -> bool:
        return isinstance(self._inner, types.InputBotAppShortName)

    def as_short_name(self) -> Optional[types.InputBotAppShortName]:
        return self._inner if self.is_short_name() else None

    def __repr__(self) -> str:
        return f'InputBotApp({self._inner!r})'


class InputBotInlineMessage(TLObject):
    """
    Boxed TL type ``InputBotInlineMessage`` — union of 8 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3380C786: types.InputBotInlineMessageMediaAuto,
        0x3DCD7A87: types.InputBotInlineMessageText,
        0x96929A85: types.InputBotInlineMessageMediaGeo,
        0x417BBF11: types.InputBotInlineMessageMediaVenue,
        0xA6EDBFFD: types.InputBotInlineMessageMediaContact,
        0x4B425864: types.InputBotInlineMessageGame,
        0xD7E78225: types.InputBotInlineMessageMediaInvoice,
        0xBDDCC510: types.InputBotInlineMessageMediaWebPage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBotInlineMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_media_auto(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageMediaAuto)

    def as_media_auto(self) -> Optional[types.InputBotInlineMessageMediaAuto]:
        return self._inner if self.is_media_auto() else None

    def is_text(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageText)

    def as_text(self) -> Optional[types.InputBotInlineMessageText]:
        return self._inner if self.is_text() else None

    def is_media_geo(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageMediaGeo)

    def as_media_geo(self) -> Optional[types.InputBotInlineMessageMediaGeo]:
        return self._inner if self.is_media_geo() else None

    def is_media_venue(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageMediaVenue)

    def as_media_venue(self) -> Optional[types.InputBotInlineMessageMediaVenue]:
        return self._inner if self.is_media_venue() else None

    def is_media_contact(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageMediaContact)

    def as_media_contact(self) -> Optional[types.InputBotInlineMessageMediaContact]:
        return self._inner if self.is_media_contact() else None

    def is_game(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageGame)

    def as_game(self) -> Optional[types.InputBotInlineMessageGame]:
        return self._inner if self.is_game() else None

    def is_media_invoice(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageMediaInvoice)

    def as_media_invoice(self) -> Optional[types.InputBotInlineMessageMediaInvoice]:
        return self._inner if self.is_media_invoice() else None

    def is_media_web_page(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageMediaWebPage)

    def as_media_web_page(self) -> Optional[types.InputBotInlineMessageMediaWebPage]:
        return self._inner if self.is_media_web_page() else None

    def __repr__(self) -> str:
        return f'InputBotInlineMessage({self._inner!r})'


class InputBotInlineMessageId(TLObject):
    """
    Boxed TL type ``InputBotInlineMessageID`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x890C3D89: types.InputBotInlineMessageId,
        0xB6D915D7: types.InputBotInlineMessageId64,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBotInlineMessageId':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_bot_inline_message_id(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageId)

    def as_input_bot_inline_message_id(self) -> Optional[types.InputBotInlineMessageId]:
        return self._inner if self.is_input_bot_inline_message_id() else None

    def is_input_bot_inline_message_id64(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineMessageId64)

    def as_input_bot_inline_message_id64(self) -> Optional[types.InputBotInlineMessageId64]:
        return self._inner if self.is_input_bot_inline_message_id64() else None

    def __repr__(self) -> str:
        return f'InputBotInlineMessageId({self._inner!r})'


class InputBotInlineResult(TLObject):
    """
    Boxed TL type ``InputBotInlineResult`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x88BF9319: types.InputBotInlineResult,
        0xA8D864A7: types.InputBotInlineResultPhoto,
        0xFFF8FDC4: types.InputBotInlineResultDocument,
        0x4FA417F2: types.InputBotInlineResultGame,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBotInlineResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_bot_inline_result(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineResult)

    def as_input_bot_inline_result(self) -> Optional[types.InputBotInlineResult]:
        return self._inner if self.is_input_bot_inline_result() else None

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineResultPhoto)

    def as_photo(self) -> Optional[types.InputBotInlineResultPhoto]:
        return self._inner if self.is_photo() else None

    def is_document(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineResultDocument)

    def as_document(self) -> Optional[types.InputBotInlineResultDocument]:
        return self._inner if self.is_document() else None

    def is_game(self) -> bool:
        return isinstance(self._inner, types.InputBotInlineResultGame)

    def as_game(self) -> Optional[types.InputBotInlineResultGame]:
        return self._inner if self.is_game() else None

    def __repr__(self) -> str:
        return f'InputBotInlineResult({self._inner!r})'


class InputBusinessAwayMessage(TLObject):
    """
    Boxed TL type ``InputBusinessAwayMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x832175E0: types.InputBusinessAwayMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBusinessAwayMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_business_away_message(self) -> bool:
        return isinstance(self._inner, types.InputBusinessAwayMessage)

    def as_input_business_away_message(self) -> Optional[types.InputBusinessAwayMessage]:
        return self._inner if self.is_input_business_away_message() else None

    def __repr__(self) -> str:
        return f'InputBusinessAwayMessage({self._inner!r})'


class InputBusinessBotRecipients(TLObject):
    """
    Boxed TL type ``InputBusinessBotRecipients`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC4E5921E: types.InputBusinessBotRecipients,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBusinessBotRecipients':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_business_bot_recipients(self) -> bool:
        return isinstance(self._inner, types.InputBusinessBotRecipients)

    def as_input_business_bot_recipients(self) -> Optional[types.InputBusinessBotRecipients]:
        return self._inner if self.is_input_business_bot_recipients() else None

    def __repr__(self) -> str:
        return f'InputBusinessBotRecipients({self._inner!r})'


class InputBusinessChatLink(TLObject):
    """
    Boxed TL type ``InputBusinessChatLink`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x11679FA7: types.InputBusinessChatLink,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBusinessChatLink':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_business_chat_link(self) -> bool:
        return isinstance(self._inner, types.InputBusinessChatLink)

    def as_input_business_chat_link(self) -> Optional[types.InputBusinessChatLink]:
        return self._inner if self.is_input_business_chat_link() else None

    def __repr__(self) -> str:
        return f'InputBusinessChatLink({self._inner!r})'


class InputBusinessGreetingMessage(TLObject):
    """
    Boxed TL type ``InputBusinessGreetingMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0194CB3B: types.InputBusinessGreetingMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBusinessGreetingMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_business_greeting_message(self) -> bool:
        return isinstance(self._inner, types.InputBusinessGreetingMessage)

    def as_input_business_greeting_message(self) -> Optional[types.InputBusinessGreetingMessage]:
        return self._inner if self.is_input_business_greeting_message() else None

    def __repr__(self) -> str:
        return f'InputBusinessGreetingMessage({self._inner!r})'


class InputBusinessIntro(TLObject):
    """
    Boxed TL type ``InputBusinessIntro`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x09C469CD: types.InputBusinessIntro,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBusinessIntro':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_business_intro(self) -> bool:
        return isinstance(self._inner, types.InputBusinessIntro)

    def as_input_business_intro(self) -> Optional[types.InputBusinessIntro]:
        return self._inner if self.is_input_business_intro() else None

    def __repr__(self) -> str:
        return f'InputBusinessIntro({self._inner!r})'


class InputBusinessRecipients(TLObject):
    """
    Boxed TL type ``InputBusinessRecipients`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6F8B32AA: types.InputBusinessRecipients,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputBusinessRecipients':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_business_recipients(self) -> bool:
        return isinstance(self._inner, types.InputBusinessRecipients)

    def as_input_business_recipients(self) -> Optional[types.InputBusinessRecipients]:
        return self._inner if self.is_input_business_recipients() else None

    def __repr__(self) -> str:
        return f'InputBusinessRecipients({self._inner!r})'


class InputChannel(TLObject):
    """
    Boxed TL type ``InputChannel`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEE8C1E86: types.InputChannelEmpty,
        0xF35AEC28: types.InputChannel,
        0x5B934F9D: types.InputChannelFromMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputChannel':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputChannelEmpty)

    def as_empty(self) -> Optional[types.InputChannelEmpty]:
        return self._inner if self.is_empty() else None

    def is_input_channel(self) -> bool:
        return isinstance(self._inner, types.InputChannel)

    def as_input_channel(self) -> Optional[types.InputChannel]:
        return self._inner if self.is_input_channel() else None

    def is_from_message(self) -> bool:
        return isinstance(self._inner, types.InputChannelFromMessage)

    def as_from_message(self) -> Optional[types.InputChannelFromMessage]:
        return self._inner if self.is_from_message() else None

    def __repr__(self) -> str:
        return f'InputChannel({self._inner!r})'


class InputChatPhoto(TLObject):
    """
    Boxed TL type ``InputChatPhoto`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1CA48F57: types.InputChatPhotoEmpty,
        0xBDCDAEC0: types.InputChatUploadedPhoto,
        0x8953AD37: types.InputChatPhoto,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputChatPhoto':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputChatPhotoEmpty)

    def as_empty(self) -> Optional[types.InputChatPhotoEmpty]:
        return self._inner if self.is_empty() else None

    def is_input_chat_uploaded_photo(self) -> bool:
        return isinstance(self._inner, types.InputChatUploadedPhoto)

    def as_input_chat_uploaded_photo(self) -> Optional[types.InputChatUploadedPhoto]:
        return self._inner if self.is_input_chat_uploaded_photo() else None

    def is_input_chat_photo(self) -> bool:
        return isinstance(self._inner, types.InputChatPhoto)

    def as_input_chat_photo(self) -> Optional[types.InputChatPhoto]:
        return self._inner if self.is_input_chat_photo() else None

    def __repr__(self) -> str:
        return f'InputChatPhoto({self._inner!r})'


class InputChatTheme(TLObject):
    """
    Boxed TL type ``InputChatTheme`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x83268483: types.InputChatThemeEmpty,
        0xC93DE95C: types.InputChatTheme,
        0x87E5DFE4: types.InputChatThemeUniqueGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputChatTheme':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputChatThemeEmpty)

    def as_empty(self) -> Optional[types.InputChatThemeEmpty]:
        return self._inner if self.is_empty() else None

    def is_input_chat_theme(self) -> bool:
        return isinstance(self._inner, types.InputChatTheme)

    def as_input_chat_theme(self) -> Optional[types.InputChatTheme]:
        return self._inner if self.is_input_chat_theme() else None

    def is_unique_gift(self) -> bool:
        return isinstance(self._inner, types.InputChatThemeUniqueGift)

    def as_unique_gift(self) -> Optional[types.InputChatThemeUniqueGift]:
        return self._inner if self.is_unique_gift() else None

    def __repr__(self) -> str:
        return f'InputChatTheme({self._inner!r})'


class InputChatlist(TLObject):
    """
    Boxed TL type ``InputChatlist`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF3E0DA33: types.InputChatlistDialogFilter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputChatlist':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialog_filter(self) -> bool:
        return isinstance(self._inner, types.InputChatlistDialogFilter)

    def as_dialog_filter(self) -> Optional[types.InputChatlistDialogFilter]:
        return self._inner if self.is_dialog_filter() else None

    def __repr__(self) -> str:
        return f'InputChatlist({self._inner!r})'


class InputCheckPasswordSrp(TLObject):
    """
    Boxed TL type ``InputCheckPasswordSRP`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9880F658: types.InputCheckPasswordEmpty,
        0xD27FF082: types.InputCheckPasswordSrp,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputCheckPasswordSrp':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_check_password_empty(self) -> bool:
        return isinstance(self._inner, types.InputCheckPasswordEmpty)

    def as_input_check_password_empty(self) -> Optional[types.InputCheckPasswordEmpty]:
        return self._inner if self.is_input_check_password_empty() else None

    def is_input_check_password_srp(self) -> bool:
        return isinstance(self._inner, types.InputCheckPasswordSrp)

    def as_input_check_password_srp(self) -> Optional[types.InputCheckPasswordSrp]:
        return self._inner if self.is_input_check_password_srp() else None

    def __repr__(self) -> str:
        return f'InputCheckPasswordSrp({self._inner!r})'


class InputClientProxy(TLObject):
    """
    Boxed TL type ``InputClientProxy`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x75588B3F: types.InputClientProxy,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputClientProxy':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_client_proxy(self) -> bool:
        return isinstance(self._inner, types.InputClientProxy)

    def as_input_client_proxy(self) -> Optional[types.InputClientProxy]:
        return self._inner if self.is_input_client_proxy() else None

    def __repr__(self) -> str:
        return f'InputClientProxy({self._inner!r})'


class InputCollectible(TLObject):
    """
    Boxed TL type ``InputCollectible`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE39460A9: types.InputCollectibleUsername,
        0xA2E214A4: types.InputCollectiblePhone,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputCollectible':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_username(self) -> bool:
        return isinstance(self._inner, types.InputCollectibleUsername)

    def as_username(self) -> Optional[types.InputCollectibleUsername]:
        return self._inner if self.is_username() else None

    def is_phone(self) -> bool:
        return isinstance(self._inner, types.InputCollectiblePhone)

    def as_phone(self) -> Optional[types.InputCollectiblePhone]:
        return self._inner if self.is_phone() else None

    def __repr__(self) -> str:
        return f'InputCollectible({self._inner!r})'


class InputContact(TLObject):
    """
    Boxed TL type ``InputContact`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6A1DC4BE: types.InputPhoneContact,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputContact':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_phone_contact(self) -> bool:
        return isinstance(self._inner, types.InputPhoneContact)

    def as_input_phone_contact(self) -> Optional[types.InputPhoneContact]:
        return self._inner if self.is_input_phone_contact() else None

    def __repr__(self) -> str:
        return f'InputContact({self._inner!r})'


class InputDialogPeer(TLObject):
    """
    Boxed TL type ``InputDialogPeer`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFCAAFEB7: types.InputDialogPeer,
        0x64600527: types.InputDialogPeerFolder,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputDialogPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_dialog_peer(self) -> bool:
        return isinstance(self._inner, types.InputDialogPeer)

    def as_input_dialog_peer(self) -> Optional[types.InputDialogPeer]:
        return self._inner if self.is_input_dialog_peer() else None

    def is_folder(self) -> bool:
        return isinstance(self._inner, types.InputDialogPeerFolder)

    def as_folder(self) -> Optional[types.InputDialogPeerFolder]:
        return self._inner if self.is_folder() else None

    def __repr__(self) -> str:
        return f'InputDialogPeer({self._inner!r})'


class InputDocument(TLObject):
    """
    Boxed TL type ``InputDocument`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x72F0EAAE: types.InputDocumentEmpty,
        0x1ABFB575: types.InputDocument,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputDocument':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputDocumentEmpty)

    def as_empty(self) -> Optional[types.InputDocumentEmpty]:
        return self._inner if self.is_empty() else None

    def is_input_document(self) -> bool:
        return isinstance(self._inner, types.InputDocument)

    def as_input_document(self) -> Optional[types.InputDocument]:
        return self._inner if self.is_input_document() else None

    def __repr__(self) -> str:
        return f'InputDocument({self._inner!r})'


class InputEncryptedChat(TLObject):
    """
    Boxed TL type ``InputEncryptedChat`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF141B5E1: types.InputEncryptedChat,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputEncryptedChat':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_encrypted_chat(self) -> bool:
        return isinstance(self._inner, types.InputEncryptedChat)

    def as_input_encrypted_chat(self) -> Optional[types.InputEncryptedChat]:
        return self._inner if self.is_input_encrypted_chat() else None

    def __repr__(self) -> str:
        return f'InputEncryptedChat({self._inner!r})'


class InputEncryptedFile(TLObject):
    """
    Boxed TL type ``InputEncryptedFile`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1837C364: types.InputEncryptedFileEmpty,
        0x64BD0306: types.InputEncryptedFileUploaded,
        0x5A17B5E5: types.InputEncryptedFile,
        0x2DC173C8: types.InputEncryptedFileBigUploaded,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputEncryptedFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputEncryptedFileEmpty)

    def as_empty(self) -> Optional[types.InputEncryptedFileEmpty]:
        return self._inner if self.is_empty() else None

    def is_uploaded(self) -> bool:
        return isinstance(self._inner, types.InputEncryptedFileUploaded)

    def as_uploaded(self) -> Optional[types.InputEncryptedFileUploaded]:
        return self._inner if self.is_uploaded() else None

    def is_input_encrypted_file(self) -> bool:
        return isinstance(self._inner, types.InputEncryptedFile)

    def as_input_encrypted_file(self) -> Optional[types.InputEncryptedFile]:
        return self._inner if self.is_input_encrypted_file() else None

    def is_big_uploaded(self) -> bool:
        return isinstance(self._inner, types.InputEncryptedFileBigUploaded)

    def as_big_uploaded(self) -> Optional[types.InputEncryptedFileBigUploaded]:
        return self._inner if self.is_big_uploaded() else None

    def __repr__(self) -> str:
        return f'InputEncryptedFile({self._inner!r})'


class InputFile(TLObject):
    """
    Boxed TL type ``InputFile`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF52FF27F: types.InputFile,
        0xFA4F0BB5: types.InputFileBig,
        0x62DC8B48: types.InputFileStoryDocument,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_file(self) -> bool:
        return isinstance(self._inner, types.InputFile)

    def as_input_file(self) -> Optional[types.InputFile]:
        return self._inner if self.is_input_file() else None

    def is_big(self) -> bool:
        return isinstance(self._inner, types.InputFileBig)

    def as_big(self) -> Optional[types.InputFileBig]:
        return self._inner if self.is_big() else None

    def is_story_document(self) -> bool:
        return isinstance(self._inner, types.InputFileStoryDocument)

    def as_story_document(self) -> Optional[types.InputFileStoryDocument]:
        return self._inner if self.is_story_document() else None

    def __repr__(self) -> str:
        return f'InputFile({self._inner!r})'


class InputFileLocation(TLObject):
    """
    Boxed TL type ``InputFileLocation`` — union of 10 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDFDAABE1: types.InputFileLocation,
        0xF5235D55: types.InputEncryptedFileLocation,
        0xBAD07584: types.InputDocumentFileLocation,
        0xCBC7EE28: types.InputSecureFileLocation,
        0x29BE5899: types.InputTakeoutFileLocation,
        0x40181FFE: types.InputPhotoFileLocation,
        0xD83466F3: types.InputPhotoLegacyFileLocation,
        0x37257E99: types.InputPeerPhotoFileLocation,
        0x9D84F3DB: types.InputStickerSetThumb,
        0x0598A92A: types.InputGroupCallStream,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputFileLocation':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_file_location(self) -> bool:
        return isinstance(self._inner, types.InputFileLocation)

    def as_input_file_location(self) -> Optional[types.InputFileLocation]:
        return self._inner if self.is_input_file_location() else None

    def is_input_encrypted_file_location(self) -> bool:
        return isinstance(self._inner, types.InputEncryptedFileLocation)

    def as_input_encrypted_file_location(self) -> Optional[types.InputEncryptedFileLocation]:
        return self._inner if self.is_input_encrypted_file_location() else None

    def is_input_document_file_location(self) -> bool:
        return isinstance(self._inner, types.InputDocumentFileLocation)

    def as_input_document_file_location(self) -> Optional[types.InputDocumentFileLocation]:
        return self._inner if self.is_input_document_file_location() else None

    def is_input_secure_file_location(self) -> bool:
        return isinstance(self._inner, types.InputSecureFileLocation)

    def as_input_secure_file_location(self) -> Optional[types.InputSecureFileLocation]:
        return self._inner if self.is_input_secure_file_location() else None

    def is_input_takeout_file_location(self) -> bool:
        return isinstance(self._inner, types.InputTakeoutFileLocation)

    def as_input_takeout_file_location(self) -> Optional[types.InputTakeoutFileLocation]:
        return self._inner if self.is_input_takeout_file_location() else None

    def is_input_photo_file_location(self) -> bool:
        return isinstance(self._inner, types.InputPhotoFileLocation)

    def as_input_photo_file_location(self) -> Optional[types.InputPhotoFileLocation]:
        return self._inner if self.is_input_photo_file_location() else None

    def is_input_photo_legacy_file_location(self) -> bool:
        return isinstance(self._inner, types.InputPhotoLegacyFileLocation)

    def as_input_photo_legacy_file_location(self) -> Optional[types.InputPhotoLegacyFileLocation]:
        return self._inner if self.is_input_photo_legacy_file_location() else None

    def is_input_peer_photo_file_location(self) -> bool:
        return isinstance(self._inner, types.InputPeerPhotoFileLocation)

    def as_input_peer_photo_file_location(self) -> Optional[types.InputPeerPhotoFileLocation]:
        return self._inner if self.is_input_peer_photo_file_location() else None

    def is_input_sticker_set_thumb(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetThumb)

    def as_input_sticker_set_thumb(self) -> Optional[types.InputStickerSetThumb]:
        return self._inner if self.is_input_sticker_set_thumb() else None

    def is_input_group_call_stream(self) -> bool:
        return isinstance(self._inner, types.InputGroupCallStream)

    def as_input_group_call_stream(self) -> Optional[types.InputGroupCallStream]:
        return self._inner if self.is_input_group_call_stream() else None

    def __repr__(self) -> str:
        return f'InputFileLocation({self._inner!r})'


class InputFolderPeer(TLObject):
    """
    Boxed TL type ``InputFolderPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFBD2C296: types.InputFolderPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputFolderPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_folder_peer(self) -> bool:
        return isinstance(self._inner, types.InputFolderPeer)

    def as_input_folder_peer(self) -> Optional[types.InputFolderPeer]:
        return self._inner if self.is_input_folder_peer() else None

    def __repr__(self) -> str:
        return f'InputFolderPeer({self._inner!r})'


class InputGame(TLObject):
    """
    Boxed TL type ``InputGame`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x032C3E77: types.InputGameId,
        0xC331E80A: types.InputGameShortName,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputGame':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_id(self) -> bool:
        return isinstance(self._inner, types.InputGameId)

    def as_id(self) -> Optional[types.InputGameId]:
        return self._inner if self.is_id() else None

    def is_short_name(self) -> bool:
        return isinstance(self._inner, types.InputGameShortName)

    def as_short_name(self) -> Optional[types.InputGameShortName]:
        return self._inner if self.is_short_name() else None

    def __repr__(self) -> str:
        return f'InputGame({self._inner!r})'


class InputGeoPoint(TLObject):
    """
    Boxed TL type ``InputGeoPoint`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE4C123D6: types.InputGeoPointEmpty,
        0x48222FAF: types.InputGeoPoint,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputGeoPoint':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputGeoPointEmpty)

    def as_empty(self) -> Optional[types.InputGeoPointEmpty]:
        return self._inner if self.is_empty() else None

    def is_input_geo_point(self) -> bool:
        return isinstance(self._inner, types.InputGeoPoint)

    def as_input_geo_point(self) -> Optional[types.InputGeoPoint]:
        return self._inner if self.is_input_geo_point() else None

    def __repr__(self) -> str:
        return f'InputGeoPoint({self._inner!r})'


class InputGroupCall(TLObject):
    """
    Boxed TL type ``InputGroupCall`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD8AA840F: types.InputGroupCall,
        0xFE06823F: types.InputGroupCallSlug,
        0x8C10603F: types.InputGroupCallInviteMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputGroupCall':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_group_call(self) -> bool:
        return isinstance(self._inner, types.InputGroupCall)

    def as_input_group_call(self) -> Optional[types.InputGroupCall]:
        return self._inner if self.is_input_group_call() else None

    def is_slug(self) -> bool:
        return isinstance(self._inner, types.InputGroupCallSlug)

    def as_slug(self) -> Optional[types.InputGroupCallSlug]:
        return self._inner if self.is_slug() else None

    def is_invite_message(self) -> bool:
        return isinstance(self._inner, types.InputGroupCallInviteMessage)

    def as_invite_message(self) -> Optional[types.InputGroupCallInviteMessage]:
        return self._inner if self.is_invite_message() else None

    def __repr__(self) -> str:
        return f'InputGroupCall({self._inner!r})'


class InputInvoice(TLObject):
    """
    Boxed TL type ``InputInvoice`` — union of 15 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC5B56859: types.InputInvoiceMessage,
        0xC326CAEF: types.InputInvoiceSlug,
        0x98986C0D: types.InputInvoicePremiumGiftCode,
        0x65F00CE3: types.InputInvoiceStars,
        0x34E793F1: types.InputInvoiceChatInviteSubscription,
        0xE8625E92: types.InputInvoiceStarGift,
        0x4D818D5D: types.InputInvoiceStarGiftUpgrade,
        0x4A5F5BD9: types.InputInvoiceStarGiftTransfer,
        0xDABAB2EF: types.InputInvoicePremiumGiftStars,
        0xF4997E42: types.InputInvoiceBusinessBotTransferStars,
        0xC39F5324: types.InputInvoiceStarGiftResale,
        0x9A0B48B8: types.InputInvoiceStarGiftPrepaidUpgrade,
        0x3E77F614: types.InputInvoicePremiumAuthCode,
        0x0923D8D1: types.InputInvoiceStarGiftDropOriginalDetails,
        0x1ECAFA10: types.InputInvoiceStarGiftAuctionBid,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputInvoice':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceMessage)

    def as_message(self) -> Optional[types.InputInvoiceMessage]:
        return self._inner if self.is_message() else None

    def is_slug(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceSlug)

    def as_slug(self) -> Optional[types.InputInvoiceSlug]:
        return self._inner if self.is_slug() else None

    def is_premium_gift_code(self) -> bool:
        return isinstance(self._inner, types.InputInvoicePremiumGiftCode)

    def as_premium_gift_code(self) -> Optional[types.InputInvoicePremiumGiftCode]:
        return self._inner if self.is_premium_gift_code() else None

    def is_stars(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStars)

    def as_stars(self) -> Optional[types.InputInvoiceStars]:
        return self._inner if self.is_stars() else None

    def is_chat_invite_subscription(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceChatInviteSubscription)

    def as_chat_invite_subscription(self) -> Optional[types.InputInvoiceChatInviteSubscription]:
        return self._inner if self.is_chat_invite_subscription() else None

    def is_star_gift(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGift)

    def as_star_gift(self) -> Optional[types.InputInvoiceStarGift]:
        return self._inner if self.is_star_gift() else None

    def is_star_gift_upgrade(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGiftUpgrade)

    def as_star_gift_upgrade(self) -> Optional[types.InputInvoiceStarGiftUpgrade]:
        return self._inner if self.is_star_gift_upgrade() else None

    def is_star_gift_transfer(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGiftTransfer)

    def as_star_gift_transfer(self) -> Optional[types.InputInvoiceStarGiftTransfer]:
        return self._inner if self.is_star_gift_transfer() else None

    def is_premium_gift_stars(self) -> bool:
        return isinstance(self._inner, types.InputInvoicePremiumGiftStars)

    def as_premium_gift_stars(self) -> Optional[types.InputInvoicePremiumGiftStars]:
        return self._inner if self.is_premium_gift_stars() else None

    def is_business_bot_transfer_stars(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceBusinessBotTransferStars)

    def as_business_bot_transfer_stars(self) -> Optional[types.InputInvoiceBusinessBotTransferStars]:
        return self._inner if self.is_business_bot_transfer_stars() else None

    def is_star_gift_resale(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGiftResale)

    def as_star_gift_resale(self) -> Optional[types.InputInvoiceStarGiftResale]:
        return self._inner if self.is_star_gift_resale() else None

    def is_star_gift_prepaid_upgrade(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGiftPrepaidUpgrade)

    def as_star_gift_prepaid_upgrade(self) -> Optional[types.InputInvoiceStarGiftPrepaidUpgrade]:
        return self._inner if self.is_star_gift_prepaid_upgrade() else None

    def is_premium_auth_code(self) -> bool:
        return isinstance(self._inner, types.InputInvoicePremiumAuthCode)

    def as_premium_auth_code(self) -> Optional[types.InputInvoicePremiumAuthCode]:
        return self._inner if self.is_premium_auth_code() else None

    def is_star_gift_drop_original_details(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGiftDropOriginalDetails)

    def as_star_gift_drop_original_details(self) -> Optional[types.InputInvoiceStarGiftDropOriginalDetails]:
        return self._inner if self.is_star_gift_drop_original_details() else None

    def is_star_gift_auction_bid(self) -> bool:
        return isinstance(self._inner, types.InputInvoiceStarGiftAuctionBid)

    def as_star_gift_auction_bid(self) -> Optional[types.InputInvoiceStarGiftAuctionBid]:
        return self._inner if self.is_star_gift_auction_bid() else None

    def __repr__(self) -> str:
        return f'InputInvoice({self._inner!r})'


class InputMedia(TLObject):
    """
    Boxed TL type ``InputMedia`` — union of 20 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9664F57F: types.InputMediaEmpty,
        0x1E287D04: types.InputMediaUploadedPhoto,
        0xB3BA0635: types.InputMediaPhoto,
        0xF9C44144: types.InputMediaGeoPoint,
        0xF8AB7DFB: types.InputMediaContact,
        0x037C9330: types.InputMediaUploadedDocument,
        0xA8763AB5: types.InputMediaDocument,
        0xC13D1C11: types.InputMediaVenue,
        0xE5BBFE1A: types.InputMediaPhotoExternal,
        0x779600F9: types.InputMediaDocumentExternal,
        0xD33F43F3: types.InputMediaGame,
        0x405FEF0D: types.InputMediaInvoice,
        0x971FA843: types.InputMediaGeoLive,
        0x0F94E5F1: types.InputMediaPoll,
        0xE66FBF7B: types.InputMediaDice,
        0x89FDD778: types.InputMediaStory,
        0xC21B8849: types.InputMediaWebPage,
        0xC4103386: types.InputMediaPaidMedia,
        0x9FC55FDE: types.InputMediaTodo,
        0xF3A9244A: types.InputMediaStakeDice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputMedia':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputMediaEmpty)

    def as_empty(self) -> Optional[types.InputMediaEmpty]:
        return self._inner if self.is_empty() else None

    def is_uploaded_photo(self) -> bool:
        return isinstance(self._inner, types.InputMediaUploadedPhoto)

    def as_uploaded_photo(self) -> Optional[types.InputMediaUploadedPhoto]:
        return self._inner if self.is_uploaded_photo() else None

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.InputMediaPhoto)

    def as_photo(self) -> Optional[types.InputMediaPhoto]:
        return self._inner if self.is_photo() else None

    def is_geo_point(self) -> bool:
        return isinstance(self._inner, types.InputMediaGeoPoint)

    def as_geo_point(self) -> Optional[types.InputMediaGeoPoint]:
        return self._inner if self.is_geo_point() else None

    def is_contact(self) -> bool:
        return isinstance(self._inner, types.InputMediaContact)

    def as_contact(self) -> Optional[types.InputMediaContact]:
        return self._inner if self.is_contact() else None

    def is_uploaded_document(self) -> bool:
        return isinstance(self._inner, types.InputMediaUploadedDocument)

    def as_uploaded_document(self) -> Optional[types.InputMediaUploadedDocument]:
        return self._inner if self.is_uploaded_document() else None

    def is_document(self) -> bool:
        return isinstance(self._inner, types.InputMediaDocument)

    def as_document(self) -> Optional[types.InputMediaDocument]:
        return self._inner if self.is_document() else None

    def is_venue(self) -> bool:
        return isinstance(self._inner, types.InputMediaVenue)

    def as_venue(self) -> Optional[types.InputMediaVenue]:
        return self._inner if self.is_venue() else None

    def is_photo_external(self) -> bool:
        return isinstance(self._inner, types.InputMediaPhotoExternal)

    def as_photo_external(self) -> Optional[types.InputMediaPhotoExternal]:
        return self._inner if self.is_photo_external() else None

    def is_document_external(self) -> bool:
        return isinstance(self._inner, types.InputMediaDocumentExternal)

    def as_document_external(self) -> Optional[types.InputMediaDocumentExternal]:
        return self._inner if self.is_document_external() else None

    def is_game(self) -> bool:
        return isinstance(self._inner, types.InputMediaGame)

    def as_game(self) -> Optional[types.InputMediaGame]:
        return self._inner if self.is_game() else None

    def is_invoice(self) -> bool:
        return isinstance(self._inner, types.InputMediaInvoice)

    def as_invoice(self) -> Optional[types.InputMediaInvoice]:
        return self._inner if self.is_invoice() else None

    def is_geo_live(self) -> bool:
        return isinstance(self._inner, types.InputMediaGeoLive)

    def as_geo_live(self) -> Optional[types.InputMediaGeoLive]:
        return self._inner if self.is_geo_live() else None

    def is_poll(self) -> bool:
        return isinstance(self._inner, types.InputMediaPoll)

    def as_poll(self) -> Optional[types.InputMediaPoll]:
        return self._inner if self.is_poll() else None

    def is_dice(self) -> bool:
        return isinstance(self._inner, types.InputMediaDice)

    def as_dice(self) -> Optional[types.InputMediaDice]:
        return self._inner if self.is_dice() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.InputMediaStory)

    def as_story(self) -> Optional[types.InputMediaStory]:
        return self._inner if self.is_story() else None

    def is_web_page(self) -> bool:
        return isinstance(self._inner, types.InputMediaWebPage)

    def as_web_page(self) -> Optional[types.InputMediaWebPage]:
        return self._inner if self.is_web_page() else None

    def is_paid_media(self) -> bool:
        return isinstance(self._inner, types.InputMediaPaidMedia)

    def as_paid_media(self) -> Optional[types.InputMediaPaidMedia]:
        return self._inner if self.is_paid_media() else None

    def is_todo(self) -> bool:
        return isinstance(self._inner, types.InputMediaTodo)

    def as_todo(self) -> Optional[types.InputMediaTodo]:
        return self._inner if self.is_todo() else None

    def is_stake_dice(self) -> bool:
        return isinstance(self._inner, types.InputMediaStakeDice)

    def as_stake_dice(self) -> Optional[types.InputMediaStakeDice]:
        return self._inner if self.is_stake_dice() else None

    def __repr__(self) -> str:
        return f'InputMedia({self._inner!r})'


class InputMessage(TLObject):
    """
    Boxed TL type ``InputMessage`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA676A322: types.InputMessageId,
        0xBAD88395: types.InputMessageReplyTo,
        0x86872538: types.InputMessagePinned,
        0xACFA1A7E: types.InputMessageCallbackQuery,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_id(self) -> bool:
        return isinstance(self._inner, types.InputMessageId)

    def as_id(self) -> Optional[types.InputMessageId]:
        return self._inner if self.is_id() else None

    def is_reply_to(self) -> bool:
        return isinstance(self._inner, types.InputMessageReplyTo)

    def as_reply_to(self) -> Optional[types.InputMessageReplyTo]:
        return self._inner if self.is_reply_to() else None

    def is_pinned(self) -> bool:
        return isinstance(self._inner, types.InputMessagePinned)

    def as_pinned(self) -> Optional[types.InputMessagePinned]:
        return self._inner if self.is_pinned() else None

    def is_callback_query(self) -> bool:
        return isinstance(self._inner, types.InputMessageCallbackQuery)

    def as_callback_query(self) -> Optional[types.InputMessageCallbackQuery]:
        return self._inner if self.is_callback_query() else None

    def __repr__(self) -> str:
        return f'InputMessage({self._inner!r})'


class InputNotifyPeer(TLObject):
    """
    Boxed TL type ``InputNotifyPeer`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB8BC5B0C: types.InputNotifyPeer,
        0x193B4417: types.InputNotifyUsers,
        0x4A95E84E: types.InputNotifyChats,
        0xB1DB7C7E: types.InputNotifyBroadcasts,
        0x5C467992: types.InputNotifyForumTopic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputNotifyPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_notify_peer(self) -> bool:
        return isinstance(self._inner, types.InputNotifyPeer)

    def as_input_notify_peer(self) -> Optional[types.InputNotifyPeer]:
        return self._inner if self.is_input_notify_peer() else None

    def is_input_notify_users(self) -> bool:
        return isinstance(self._inner, types.InputNotifyUsers)

    def as_input_notify_users(self) -> Optional[types.InputNotifyUsers]:
        return self._inner if self.is_input_notify_users() else None

    def is_input_notify_chats(self) -> bool:
        return isinstance(self._inner, types.InputNotifyChats)

    def as_input_notify_chats(self) -> Optional[types.InputNotifyChats]:
        return self._inner if self.is_input_notify_chats() else None

    def is_input_notify_broadcasts(self) -> bool:
        return isinstance(self._inner, types.InputNotifyBroadcasts)

    def as_input_notify_broadcasts(self) -> Optional[types.InputNotifyBroadcasts]:
        return self._inner if self.is_input_notify_broadcasts() else None

    def is_input_notify_forum_topic(self) -> bool:
        return isinstance(self._inner, types.InputNotifyForumTopic)

    def as_input_notify_forum_topic(self) -> Optional[types.InputNotifyForumTopic]:
        return self._inner if self.is_input_notify_forum_topic() else None

    def __repr__(self) -> str:
        return f'InputNotifyPeer({self._inner!r})'


class InputPasskeyCredential(TLObject):
    """
    Boxed TL type ``InputPasskeyCredential`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3C27B78F: types.InputPasskeyCredentialPublicKey,
        0x5B1CCB28: types.InputPasskeyCredentialFirebasePnv,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPasskeyCredential':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_public_key(self) -> bool:
        return isinstance(self._inner, types.InputPasskeyCredentialPublicKey)

    def as_public_key(self) -> Optional[types.InputPasskeyCredentialPublicKey]:
        return self._inner if self.is_public_key() else None

    def is_firebase_pnv(self) -> bool:
        return isinstance(self._inner, types.InputPasskeyCredentialFirebasePnv)

    def as_firebase_pnv(self) -> Optional[types.InputPasskeyCredentialFirebasePnv]:
        return self._inner if self.is_firebase_pnv() else None

    def __repr__(self) -> str:
        return f'InputPasskeyCredential({self._inner!r})'


class InputPasskeyResponse(TLObject):
    """
    Boxed TL type ``InputPasskeyResponse`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3E63935C: types.InputPasskeyResponseRegister,
        0xC31FC14A: types.InputPasskeyResponseLogin,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPasskeyResponse':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_register(self) -> bool:
        return isinstance(self._inner, types.InputPasskeyResponseRegister)

    def as_register(self) -> Optional[types.InputPasskeyResponseRegister]:
        return self._inner if self.is_register() else None

    def is_login(self) -> bool:
        return isinstance(self._inner, types.InputPasskeyResponseLogin)

    def as_login(self) -> Optional[types.InputPasskeyResponseLogin]:
        return self._inner if self.is_login() else None

    def __repr__(self) -> str:
        return f'InputPasskeyResponse({self._inner!r})'


class InputPaymentCredentials(TLObject):
    """
    Boxed TL type ``InputPaymentCredentials`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC10EB2CF: types.InputPaymentCredentialsSaved,
        0x3417D728: types.InputPaymentCredentials,
        0x0AA1C39F: types.InputPaymentCredentialsApplePay,
        0x8AC32801: types.InputPaymentCredentialsGooglePay,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPaymentCredentials':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved(self) -> bool:
        return isinstance(self._inner, types.InputPaymentCredentialsSaved)

    def as_saved(self) -> Optional[types.InputPaymentCredentialsSaved]:
        return self._inner if self.is_saved() else None

    def is_input_payment_credentials(self) -> bool:
        return isinstance(self._inner, types.InputPaymentCredentials)

    def as_input_payment_credentials(self) -> Optional[types.InputPaymentCredentials]:
        return self._inner if self.is_input_payment_credentials() else None

    def is_apple_pay(self) -> bool:
        return isinstance(self._inner, types.InputPaymentCredentialsApplePay)

    def as_apple_pay(self) -> Optional[types.InputPaymentCredentialsApplePay]:
        return self._inner if self.is_apple_pay() else None

    def is_google_pay(self) -> bool:
        return isinstance(self._inner, types.InputPaymentCredentialsGooglePay)

    def as_google_pay(self) -> Optional[types.InputPaymentCredentialsGooglePay]:
        return self._inner if self.is_google_pay() else None

    def __repr__(self) -> str:
        return f'InputPaymentCredentials({self._inner!r})'


class InputPeer(TLObject):
    """
    Boxed TL type ``InputPeer`` — union of 7 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7F3B18EA: types.InputPeerEmpty,
        0x7DA07EC9: types.InputPeerSelf,
        0x35A95CB9: types.InputPeerChat,
        0xDDE8A54C: types.InputPeerUser,
        0x27BCBBFC: types.InputPeerChannel,
        0xA87B0A1C: types.InputPeerUserFromMessage,
        0xBD2A0840: types.InputPeerChannelFromMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputPeerEmpty)

    def as_empty(self) -> Optional[types.InputPeerEmpty]:
        return self._inner if self.is_empty() else None

    def is_self(self) -> bool:
        return isinstance(self._inner, types.InputPeerSelf)

    def as_self(self) -> Optional[types.InputPeerSelf]:
        return self._inner if self.is_self() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.InputPeerChat)

    def as_chat(self) -> Optional[types.InputPeerChat]:
        return self._inner if self.is_chat() else None

    def is_user(self) -> bool:
        return isinstance(self._inner, types.InputPeerUser)

    def as_user(self) -> Optional[types.InputPeerUser]:
        return self._inner if self.is_user() else None

    def is_channel(self) -> bool:
        return isinstance(self._inner, types.InputPeerChannel)

    def as_channel(self) -> Optional[types.InputPeerChannel]:
        return self._inner if self.is_channel() else None

    def is_user_from_message(self) -> bool:
        return isinstance(self._inner, types.InputPeerUserFromMessage)

    def as_user_from_message(self) -> Optional[types.InputPeerUserFromMessage]:
        return self._inner if self.is_user_from_message() else None

    def is_channel_from_message(self) -> bool:
        return isinstance(self._inner, types.InputPeerChannelFromMessage)

    def as_channel_from_message(self) -> Optional[types.InputPeerChannelFromMessage]:
        return self._inner if self.is_channel_from_message() else None

    def __repr__(self) -> str:
        return f'InputPeer({self._inner!r})'


class InputPeerNotifySettings(TLObject):
    """
    Boxed TL type ``InputPeerNotifySettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCACB6AE2: types.InputPeerNotifySettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPeerNotifySettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_peer_notify_settings(self) -> bool:
        return isinstance(self._inner, types.InputPeerNotifySettings)

    def as_input_peer_notify_settings(self) -> Optional[types.InputPeerNotifySettings]:
        return self._inner if self.is_input_peer_notify_settings() else None

    def __repr__(self) -> str:
        return f'InputPeerNotifySettings({self._inner!r})'


class InputPhoneCall(TLObject):
    """
    Boxed TL type ``InputPhoneCall`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1E36FDED: types.InputPhoneCall,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPhoneCall':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_phone_call(self) -> bool:
        return isinstance(self._inner, types.InputPhoneCall)

    def as_input_phone_call(self) -> Optional[types.InputPhoneCall]:
        return self._inner if self.is_input_phone_call() else None

    def __repr__(self) -> str:
        return f'InputPhoneCall({self._inner!r})'


class InputPhoto(TLObject):
    """
    Boxed TL type ``InputPhoto`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1CD7BF0D: types.InputPhotoEmpty,
        0x3BB3B94A: types.InputPhoto,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPhoto':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputPhotoEmpty)

    def as_empty(self) -> Optional[types.InputPhotoEmpty]:
        return self._inner if self.is_empty() else None

    def is_input_photo(self) -> bool:
        return isinstance(self._inner, types.InputPhoto)

    def as_input_photo(self) -> Optional[types.InputPhoto]:
        return self._inner if self.is_input_photo() else None

    def __repr__(self) -> str:
        return f'InputPhoto({self._inner!r})'


class InputPrivacyKey(TLObject):
    """
    Boxed TL type ``InputPrivacyKey`` — union of 14 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4F96CB18: types.InputPrivacyKeyStatusTimestamp,
        0xBDFB0426: types.InputPrivacyKeyChatInvite,
        0xFABADC5F: types.InputPrivacyKeyPhoneCall,
        0xDB9E70D2: types.InputPrivacyKeyPhoneP2P,
        0xA4DD4C08: types.InputPrivacyKeyForwards,
        0x5719BACC: types.InputPrivacyKeyProfilePhoto,
        0x0352DAFA: types.InputPrivacyKeyPhoneNumber,
        0xD1219BDD: types.InputPrivacyKeyAddedByPhone,
        0xAEE69D68: types.InputPrivacyKeyVoiceMessages,
        0x3823CC40: types.InputPrivacyKeyAbout,
        0xD65A11CC: types.InputPrivacyKeyBirthday,
        0xE1732341: types.InputPrivacyKeyStarGiftsAutoSave,
        0xBDC597B4: types.InputPrivacyKeyNoPaidMessages,
        0x4DBE9226: types.InputPrivacyKeySavedMusic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPrivacyKey':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_status_timestamp(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyStatusTimestamp)

    def as_status_timestamp(self) -> Optional[types.InputPrivacyKeyStatusTimestamp]:
        return self._inner if self.is_status_timestamp() else None

    def is_chat_invite(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyChatInvite)

    def as_chat_invite(self) -> Optional[types.InputPrivacyKeyChatInvite]:
        return self._inner if self.is_chat_invite() else None

    def is_phone_call(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyPhoneCall)

    def as_phone_call(self) -> Optional[types.InputPrivacyKeyPhoneCall]:
        return self._inner if self.is_phone_call() else None

    def is_phone_p2_p(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyPhoneP2P)

    def as_phone_p2_p(self) -> Optional[types.InputPrivacyKeyPhoneP2P]:
        return self._inner if self.is_phone_p2_p() else None

    def is_forwards(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyForwards)

    def as_forwards(self) -> Optional[types.InputPrivacyKeyForwards]:
        return self._inner if self.is_forwards() else None

    def is_profile_photo(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyProfilePhoto)

    def as_profile_photo(self) -> Optional[types.InputPrivacyKeyProfilePhoto]:
        return self._inner if self.is_profile_photo() else None

    def is_phone_number(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyPhoneNumber)

    def as_phone_number(self) -> Optional[types.InputPrivacyKeyPhoneNumber]:
        return self._inner if self.is_phone_number() else None

    def is_added_by_phone(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyAddedByPhone)

    def as_added_by_phone(self) -> Optional[types.InputPrivacyKeyAddedByPhone]:
        return self._inner if self.is_added_by_phone() else None

    def is_voice_messages(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyVoiceMessages)

    def as_voice_messages(self) -> Optional[types.InputPrivacyKeyVoiceMessages]:
        return self._inner if self.is_voice_messages() else None

    def is_about(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyAbout)

    def as_about(self) -> Optional[types.InputPrivacyKeyAbout]:
        return self._inner if self.is_about() else None

    def is_birthday(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyBirthday)

    def as_birthday(self) -> Optional[types.InputPrivacyKeyBirthday]:
        return self._inner if self.is_birthday() else None

    def is_star_gifts_auto_save(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyStarGiftsAutoSave)

    def as_star_gifts_auto_save(self) -> Optional[types.InputPrivacyKeyStarGiftsAutoSave]:
        return self._inner if self.is_star_gifts_auto_save() else None

    def is_no_paid_messages(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeyNoPaidMessages)

    def as_no_paid_messages(self) -> Optional[types.InputPrivacyKeyNoPaidMessages]:
        return self._inner if self.is_no_paid_messages() else None

    def is_saved_music(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyKeySavedMusic)

    def as_saved_music(self) -> Optional[types.InputPrivacyKeySavedMusic]:
        return self._inner if self.is_saved_music() else None

    def __repr__(self) -> str:
        return f'InputPrivacyKey({self._inner!r})'


class InputPrivacyRule(TLObject):
    """
    Boxed TL type ``InputPrivacyRule`` — union of 12 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0D09E07B: types.InputPrivacyValueAllowContacts,
        0x184B35CE: types.InputPrivacyValueAllowAll,
        0x131CC67F: types.InputPrivacyValueAllowUsers,
        0x0BA52007: types.InputPrivacyValueDisallowContacts,
        0xD66B66C9: types.InputPrivacyValueDisallowAll,
        0x90110467: types.InputPrivacyValueDisallowUsers,
        0x840649CF: types.InputPrivacyValueAllowChatParticipants,
        0xE94F0F86: types.InputPrivacyValueDisallowChatParticipants,
        0x2F453E49: types.InputPrivacyValueAllowCloseFriends,
        0x77CDC9F1: types.InputPrivacyValueAllowPremium,
        0x5A4FCCE5: types.InputPrivacyValueAllowBots,
        0xC4E57915: types.InputPrivacyValueDisallowBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputPrivacyRule':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_privacy_value_allow_contacts(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowContacts)

    def as_input_privacy_value_allow_contacts(self) -> Optional[types.InputPrivacyValueAllowContacts]:
        return self._inner if self.is_input_privacy_value_allow_contacts() else None

    def is_input_privacy_value_allow_all(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowAll)

    def as_input_privacy_value_allow_all(self) -> Optional[types.InputPrivacyValueAllowAll]:
        return self._inner if self.is_input_privacy_value_allow_all() else None

    def is_input_privacy_value_allow_users(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowUsers)

    def as_input_privacy_value_allow_users(self) -> Optional[types.InputPrivacyValueAllowUsers]:
        return self._inner if self.is_input_privacy_value_allow_users() else None

    def is_input_privacy_value_disallow_contacts(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueDisallowContacts)

    def as_input_privacy_value_disallow_contacts(self) -> Optional[types.InputPrivacyValueDisallowContacts]:
        return self._inner if self.is_input_privacy_value_disallow_contacts() else None

    def is_input_privacy_value_disallow_all(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueDisallowAll)

    def as_input_privacy_value_disallow_all(self) -> Optional[types.InputPrivacyValueDisallowAll]:
        return self._inner if self.is_input_privacy_value_disallow_all() else None

    def is_input_privacy_value_disallow_users(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueDisallowUsers)

    def as_input_privacy_value_disallow_users(self) -> Optional[types.InputPrivacyValueDisallowUsers]:
        return self._inner if self.is_input_privacy_value_disallow_users() else None

    def is_input_privacy_value_allow_chat_participants(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowChatParticipants)

    def as_input_privacy_value_allow_chat_participants(self) -> Optional[types.InputPrivacyValueAllowChatParticipants]:
        return self._inner if self.is_input_privacy_value_allow_chat_participants() else None

    def is_input_privacy_value_disallow_chat_participants(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueDisallowChatParticipants)

    def as_input_privacy_value_disallow_chat_participants(self) -> Optional[types.InputPrivacyValueDisallowChatParticipants]:
        return self._inner if self.is_input_privacy_value_disallow_chat_participants() else None

    def is_input_privacy_value_allow_close_friends(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowCloseFriends)

    def as_input_privacy_value_allow_close_friends(self) -> Optional[types.InputPrivacyValueAllowCloseFriends]:
        return self._inner if self.is_input_privacy_value_allow_close_friends() else None

    def is_input_privacy_value_allow_premium(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowPremium)

    def as_input_privacy_value_allow_premium(self) -> Optional[types.InputPrivacyValueAllowPremium]:
        return self._inner if self.is_input_privacy_value_allow_premium() else None

    def is_input_privacy_value_allow_bots(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueAllowBots)

    def as_input_privacy_value_allow_bots(self) -> Optional[types.InputPrivacyValueAllowBots]:
        return self._inner if self.is_input_privacy_value_allow_bots() else None

    def is_input_privacy_value_disallow_bots(self) -> bool:
        return isinstance(self._inner, types.InputPrivacyValueDisallowBots)

    def as_input_privacy_value_disallow_bots(self) -> Optional[types.InputPrivacyValueDisallowBots]:
        return self._inner if self.is_input_privacy_value_disallow_bots() else None

    def __repr__(self) -> str:
        return f'InputPrivacyRule({self._inner!r})'


class InputQuickReplyShortcut(TLObject):
    """
    Boxed TL type ``InputQuickReplyShortcut`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x24596D41: types.InputQuickReplyShortcut,
        0x01190CF1: types.InputQuickReplyShortcutId,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputQuickReplyShortcut':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_quick_reply_shortcut(self) -> bool:
        return isinstance(self._inner, types.InputQuickReplyShortcut)

    def as_input_quick_reply_shortcut(self) -> Optional[types.InputQuickReplyShortcut]:
        return self._inner if self.is_input_quick_reply_shortcut() else None

    def is_id(self) -> bool:
        return isinstance(self._inner, types.InputQuickReplyShortcutId)

    def as_id(self) -> Optional[types.InputQuickReplyShortcutId]:
        return self._inner if self.is_id() else None

    def __repr__(self) -> str:
        return f'InputQuickReplyShortcut({self._inner!r})'


class InputReplyTo(TLObject):
    """
    Boxed TL type ``InputReplyTo`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x869FBE10: types.InputReplyToMessage,
        0x5881323A: types.InputReplyToStory,
        0x69D66C45: types.InputReplyToMonoForum,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputReplyTo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message(self) -> bool:
        return isinstance(self._inner, types.InputReplyToMessage)

    def as_message(self) -> Optional[types.InputReplyToMessage]:
        return self._inner if self.is_message() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.InputReplyToStory)

    def as_story(self) -> Optional[types.InputReplyToStory]:
        return self._inner if self.is_story() else None

    def is_mono_forum(self) -> bool:
        return isinstance(self._inner, types.InputReplyToMonoForum)

    def as_mono_forum(self) -> Optional[types.InputReplyToMonoForum]:
        return self._inner if self.is_mono_forum() else None

    def __repr__(self) -> str:
        return f'InputReplyTo({self._inner!r})'


class InputSavedStarGift(TLObject):
    """
    Boxed TL type ``InputSavedStarGift`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x69279795: types.InputSavedStarGiftUser,
        0xF101AA7F: types.InputSavedStarGiftChat,
        0x2085C238: types.InputSavedStarGiftSlug,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputSavedStarGift':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_user(self) -> bool:
        return isinstance(self._inner, types.InputSavedStarGiftUser)

    def as_user(self) -> Optional[types.InputSavedStarGiftUser]:
        return self._inner if self.is_user() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.InputSavedStarGiftChat)

    def as_chat(self) -> Optional[types.InputSavedStarGiftChat]:
        return self._inner if self.is_chat() else None

    def is_slug(self) -> bool:
        return isinstance(self._inner, types.InputSavedStarGiftSlug)

    def as_slug(self) -> Optional[types.InputSavedStarGiftSlug]:
        return self._inner if self.is_slug() else None

    def __repr__(self) -> str:
        return f'InputSavedStarGift({self._inner!r})'


class InputSecureFile(TLObject):
    """
    Boxed TL type ``InputSecureFile`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3334B0F0: types.InputSecureFileUploaded,
        0x5367E5BE: types.InputSecureFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputSecureFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_uploaded(self) -> bool:
        return isinstance(self._inner, types.InputSecureFileUploaded)

    def as_uploaded(self) -> Optional[types.InputSecureFileUploaded]:
        return self._inner if self.is_uploaded() else None

    def is_input_secure_file(self) -> bool:
        return isinstance(self._inner, types.InputSecureFile)

    def as_input_secure_file(self) -> Optional[types.InputSecureFile]:
        return self._inner if self.is_input_secure_file() else None

    def __repr__(self) -> str:
        return f'InputSecureFile({self._inner!r})'


class InputSecureValue(TLObject):
    """
    Boxed TL type ``InputSecureValue`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDB21D0A7: types.InputSecureValue,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputSecureValue':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_secure_value(self) -> bool:
        return isinstance(self._inner, types.InputSecureValue)

    def as_input_secure_value(self) -> Optional[types.InputSecureValue]:
        return self._inner if self.is_input_secure_value() else None

    def __repr__(self) -> str:
        return f'InputSecureValue({self._inner!r})'


class InputSingleMedia(TLObject):
    """
    Boxed TL type ``InputSingleMedia`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1CC6E91F: types.InputSingleMedia,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputSingleMedia':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_single_media(self) -> bool:
        return isinstance(self._inner, types.InputSingleMedia)

    def as_input_single_media(self) -> Optional[types.InputSingleMedia]:
        return self._inner if self.is_input_single_media() else None

    def __repr__(self) -> str:
        return f'InputSingleMedia({self._inner!r})'


class InputStarGiftAuction(TLObject):
    """
    Boxed TL type ``InputStarGiftAuction`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x02E16C98: types.InputStarGiftAuction,
        0x7AB58308: types.InputStarGiftAuctionSlug,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputStarGiftAuction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_star_gift_auction(self) -> bool:
        return isinstance(self._inner, types.InputStarGiftAuction)

    def as_input_star_gift_auction(self) -> Optional[types.InputStarGiftAuction]:
        return self._inner if self.is_input_star_gift_auction() else None

    def is_slug(self) -> bool:
        return isinstance(self._inner, types.InputStarGiftAuctionSlug)

    def as_slug(self) -> Optional[types.InputStarGiftAuctionSlug]:
        return self._inner if self.is_slug() else None

    def __repr__(self) -> str:
        return f'InputStarGiftAuction({self._inner!r})'


class InputStarsTransaction(TLObject):
    """
    Boxed TL type ``InputStarsTransaction`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x206AE6D1: types.InputStarsTransaction,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputStarsTransaction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_stars_transaction(self) -> bool:
        return isinstance(self._inner, types.InputStarsTransaction)

    def as_input_stars_transaction(self) -> Optional[types.InputStarsTransaction]:
        return self._inner if self.is_input_stars_transaction() else None

    def __repr__(self) -> str:
        return f'InputStarsTransaction({self._inner!r})'


class InputStickerSet(TLObject):
    """
    Boxed TL type ``InputStickerSet`` — union of 12 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFFB62B95: types.InputStickerSetEmpty,
        0x9DE7A269: types.InputStickerSetId,
        0x861CC8A0: types.InputStickerSetShortName,
        0x028703C8: types.InputStickerSetAnimatedEmoji,
        0xE67F520E: types.InputStickerSetDice,
        0x0CDE3739: types.InputStickerSetAnimatedEmojiAnimations,
        0xC88B3B02: types.InputStickerSetPremiumGifts,
        0x04C4D4CE: types.InputStickerSetEmojiGenericAnimations,
        0x29D0F5EE: types.InputStickerSetEmojiDefaultStatuses,
        0x44C1F8E9: types.InputStickerSetEmojiDefaultTopicIcons,
        0x49748553: types.InputStickerSetEmojiChannelDefaultStatuses,
        0x1CF671A0: types.InputStickerSetTonGifts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputStickerSet':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetEmpty)

    def as_empty(self) -> Optional[types.InputStickerSetEmpty]:
        return self._inner if self.is_empty() else None

    def is_id(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetId)

    def as_id(self) -> Optional[types.InputStickerSetId]:
        return self._inner if self.is_id() else None

    def is_short_name(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetShortName)

    def as_short_name(self) -> Optional[types.InputStickerSetShortName]:
        return self._inner if self.is_short_name() else None

    def is_animated_emoji(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetAnimatedEmoji)

    def as_animated_emoji(self) -> Optional[types.InputStickerSetAnimatedEmoji]:
        return self._inner if self.is_animated_emoji() else None

    def is_dice(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetDice)

    def as_dice(self) -> Optional[types.InputStickerSetDice]:
        return self._inner if self.is_dice() else None

    def is_animated_emoji_animations(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetAnimatedEmojiAnimations)

    def as_animated_emoji_animations(self) -> Optional[types.InputStickerSetAnimatedEmojiAnimations]:
        return self._inner if self.is_animated_emoji_animations() else None

    def is_premium_gifts(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetPremiumGifts)

    def as_premium_gifts(self) -> Optional[types.InputStickerSetPremiumGifts]:
        return self._inner if self.is_premium_gifts() else None

    def is_emoji_generic_animations(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetEmojiGenericAnimations)

    def as_emoji_generic_animations(self) -> Optional[types.InputStickerSetEmojiGenericAnimations]:
        return self._inner if self.is_emoji_generic_animations() else None

    def is_emoji_default_statuses(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetEmojiDefaultStatuses)

    def as_emoji_default_statuses(self) -> Optional[types.InputStickerSetEmojiDefaultStatuses]:
        return self._inner if self.is_emoji_default_statuses() else None

    def is_emoji_default_topic_icons(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetEmojiDefaultTopicIcons)

    def as_emoji_default_topic_icons(self) -> Optional[types.InputStickerSetEmojiDefaultTopicIcons]:
        return self._inner if self.is_emoji_default_topic_icons() else None

    def is_emoji_channel_default_statuses(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetEmojiChannelDefaultStatuses)

    def as_emoji_channel_default_statuses(self) -> Optional[types.InputStickerSetEmojiChannelDefaultStatuses]:
        return self._inner if self.is_emoji_channel_default_statuses() else None

    def is_ton_gifts(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetTonGifts)

    def as_ton_gifts(self) -> Optional[types.InputStickerSetTonGifts]:
        return self._inner if self.is_ton_gifts() else None

    def __repr__(self) -> str:
        return f'InputStickerSet({self._inner!r})'


class InputStickerSetItem(TLObject):
    """
    Boxed TL type ``InputStickerSetItem`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x32DA9E9C: types.InputStickerSetItem,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputStickerSetItem':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_sticker_set_item(self) -> bool:
        return isinstance(self._inner, types.InputStickerSetItem)

    def as_input_sticker_set_item(self) -> Optional[types.InputStickerSetItem]:
        return self._inner if self.is_input_sticker_set_item() else None

    def __repr__(self) -> str:
        return f'InputStickerSetItem({self._inner!r})'


class InputStickeredMedia(TLObject):
    """
    Boxed TL type ``InputStickeredMedia`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4A992157: types.InputStickeredMediaPhoto,
        0x0438865B: types.InputStickeredMediaDocument,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputStickeredMedia':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.InputStickeredMediaPhoto)

    def as_photo(self) -> Optional[types.InputStickeredMediaPhoto]:
        return self._inner if self.is_photo() else None

    def is_document(self) -> bool:
        return isinstance(self._inner, types.InputStickeredMediaDocument)

    def as_document(self) -> Optional[types.InputStickeredMediaDocument]:
        return self._inner if self.is_document() else None

    def __repr__(self) -> str:
        return f'InputStickeredMedia({self._inner!r})'


class InputStorePaymentPurpose(TLObject):
    """
    Boxed TL type ``InputStorePaymentPurpose`` — union of 8 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA6751E66: types.InputStorePaymentPremiumSubscription,
        0x616F7FE8: types.InputStorePaymentGiftPremium,
        0xFB790393: types.InputStorePaymentPremiumGiftCode,
        0x160544CA: types.InputStorePaymentPremiumGiveaway,
        0xF9A2A6CB: types.InputStorePaymentStarsTopup,
        0x1D741EF7: types.InputStorePaymentStarsGift,
        0x751F08FA: types.InputStorePaymentStarsGiveaway,
        0x9BB2636D: types.InputStorePaymentAuthCode,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputStorePaymentPurpose':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_store_payment_premium_subscription(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentPremiumSubscription)

    def as_input_store_payment_premium_subscription(self) -> Optional[types.InputStorePaymentPremiumSubscription]:
        return self._inner if self.is_input_store_payment_premium_subscription() else None

    def is_input_store_payment_gift_premium(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentGiftPremium)

    def as_input_store_payment_gift_premium(self) -> Optional[types.InputStorePaymentGiftPremium]:
        return self._inner if self.is_input_store_payment_gift_premium() else None

    def is_input_store_payment_premium_gift_code(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentPremiumGiftCode)

    def as_input_store_payment_premium_gift_code(self) -> Optional[types.InputStorePaymentPremiumGiftCode]:
        return self._inner if self.is_input_store_payment_premium_gift_code() else None

    def is_input_store_payment_premium_giveaway(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentPremiumGiveaway)

    def as_input_store_payment_premium_giveaway(self) -> Optional[types.InputStorePaymentPremiumGiveaway]:
        return self._inner if self.is_input_store_payment_premium_giveaway() else None

    def is_input_store_payment_stars_topup(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentStarsTopup)

    def as_input_store_payment_stars_topup(self) -> Optional[types.InputStorePaymentStarsTopup]:
        return self._inner if self.is_input_store_payment_stars_topup() else None

    def is_input_store_payment_stars_gift(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentStarsGift)

    def as_input_store_payment_stars_gift(self) -> Optional[types.InputStorePaymentStarsGift]:
        return self._inner if self.is_input_store_payment_stars_gift() else None

    def is_input_store_payment_stars_giveaway(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentStarsGiveaway)

    def as_input_store_payment_stars_giveaway(self) -> Optional[types.InputStorePaymentStarsGiveaway]:
        return self._inner if self.is_input_store_payment_stars_giveaway() else None

    def is_input_store_payment_auth_code(self) -> bool:
        return isinstance(self._inner, types.InputStorePaymentAuthCode)

    def as_input_store_payment_auth_code(self) -> Optional[types.InputStorePaymentAuthCode]:
        return self._inner if self.is_input_store_payment_auth_code() else None

    def __repr__(self) -> str:
        return f'InputStorePaymentPurpose({self._inner!r})'


class InputTheme(TLObject):
    """
    Boxed TL type ``InputTheme`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3C5693E9: types.InputTheme,
        0xF5890DF1: types.InputThemeSlug,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputTheme':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_theme(self) -> bool:
        return isinstance(self._inner, types.InputTheme)

    def as_input_theme(self) -> Optional[types.InputTheme]:
        return self._inner if self.is_input_theme() else None

    def is_slug(self) -> bool:
        return isinstance(self._inner, types.InputThemeSlug)

    def as_slug(self) -> Optional[types.InputThemeSlug]:
        return self._inner if self.is_slug() else None

    def __repr__(self) -> str:
        return f'InputTheme({self._inner!r})'


class InputThemeSettings(TLObject):
    """
    Boxed TL type ``InputThemeSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8FDE504F: types.InputThemeSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputThemeSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_theme_settings(self) -> bool:
        return isinstance(self._inner, types.InputThemeSettings)

    def as_input_theme_settings(self) -> Optional[types.InputThemeSettings]:
        return self._inner if self.is_input_theme_settings() else None

    def __repr__(self) -> str:
        return f'InputThemeSettings({self._inner!r})'


class InputUser(TLObject):
    """
    Boxed TL type ``InputUser`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB98886CF: types.InputUserEmpty,
        0xF7C1B13F: types.InputUserSelf,
        0xF21158C6: types.InputUser,
        0x1DA448E2: types.InputUserFromMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputUser':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.InputUserEmpty)

    def as_empty(self) -> Optional[types.InputUserEmpty]:
        return self._inner if self.is_empty() else None

    def is_self(self) -> bool:
        return isinstance(self._inner, types.InputUserSelf)

    def as_self(self) -> Optional[types.InputUserSelf]:
        return self._inner if self.is_self() else None

    def is_input_user(self) -> bool:
        return isinstance(self._inner, types.InputUser)

    def as_input_user(self) -> Optional[types.InputUser]:
        return self._inner if self.is_input_user() else None

    def is_from_message(self) -> bool:
        return isinstance(self._inner, types.InputUserFromMessage)

    def as_from_message(self) -> Optional[types.InputUserFromMessage]:
        return self._inner if self.is_from_message() else None

    def __repr__(self) -> str:
        return f'InputUser({self._inner!r})'


class InputWallPaper(TLObject):
    """
    Boxed TL type ``InputWallPaper`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE630B979: types.InputWallPaper,
        0x72091C80: types.InputWallPaperSlug,
        0x967A462E: types.InputWallPaperNoFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputWallPaper':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_wall_paper(self) -> bool:
        return isinstance(self._inner, types.InputWallPaper)

    def as_input_wall_paper(self) -> Optional[types.InputWallPaper]:
        return self._inner if self.is_input_wall_paper() else None

    def is_slug(self) -> bool:
        return isinstance(self._inner, types.InputWallPaperSlug)

    def as_slug(self) -> Optional[types.InputWallPaperSlug]:
        return self._inner if self.is_slug() else None

    def is_no_file(self) -> bool:
        return isinstance(self._inner, types.InputWallPaperNoFile)

    def as_no_file(self) -> Optional[types.InputWallPaperNoFile]:
        return self._inner if self.is_no_file() else None

    def __repr__(self) -> str:
        return f'InputWallPaper({self._inner!r})'


class InputWebDocument(TLObject):
    """
    Boxed TL type ``InputWebDocument`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9BED434D: types.InputWebDocument,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputWebDocument':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_web_document(self) -> bool:
        return isinstance(self._inner, types.InputWebDocument)

    def as_input_web_document(self) -> Optional[types.InputWebDocument]:
        return self._inner if self.is_input_web_document() else None

    def __repr__(self) -> str:
        return f'InputWebDocument({self._inner!r})'


class InputWebFileLocation(TLObject):
    """
    Boxed TL type ``InputWebFileLocation`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC239D686: types.InputWebFileLocation,
        0x9F2221C9: types.InputWebFileGeoPointLocation,
        0xF46FE924: types.InputWebFileAudioAlbumThumbLocation,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InputWebFileLocation':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_web_file_location(self) -> bool:
        return isinstance(self._inner, types.InputWebFileLocation)

    def as_input_web_file_location(self) -> Optional[types.InputWebFileLocation]:
        return self._inner if self.is_input_web_file_location() else None

    def is_input_web_file_geo_point_location(self) -> bool:
        return isinstance(self._inner, types.InputWebFileGeoPointLocation)

    def as_input_web_file_geo_point_location(self) -> Optional[types.InputWebFileGeoPointLocation]:
        return self._inner if self.is_input_web_file_geo_point_location() else None

    def is_input_web_file_audio_album_thumb_location(self) -> bool:
        return isinstance(self._inner, types.InputWebFileAudioAlbumThumbLocation)

    def as_input_web_file_audio_album_thumb_location(self) -> Optional[types.InputWebFileAudioAlbumThumbLocation]:
        return self._inner if self.is_input_web_file_audio_album_thumb_location() else None

    def __repr__(self) -> str:
        return f'InputWebFileLocation({self._inner!r})'


class Invoice(TLObject):
    """
    Boxed TL type ``Invoice`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x049EE584: types.Invoice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Invoice':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_invoice(self) -> bool:
        return isinstance(self._inner, types.Invoice)

    def as_invoice(self) -> Optional[types.Invoice]:
        return self._inner if self.is_invoice() else None

    def __repr__(self) -> str:
        return f'Invoice({self._inner!r})'


class JsonobjectValue(TLObject):
    """
    Boxed TL type ``JSONObjectValue`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC0DE1BD9: types.JsonObjectValue,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'JsonobjectValue':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_json_object_value(self) -> bool:
        return isinstance(self._inner, types.JsonObjectValue)

    def as_json_object_value(self) -> Optional[types.JsonObjectValue]:
        return self._inner if self.is_json_object_value() else None

    def __repr__(self) -> str:
        return f'JsonobjectValue({self._inner!r})'


class Jsonvalue(TLObject):
    """
    Boxed TL type ``JSONValue`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3F6D7B68: types.JsonNull,
        0xC7345E6A: types.JsonBool,
        0x2BE0DFA4: types.JsonNumber,
        0xB71E767A: types.JsonString,
        0xF7444763: types.JsonArray,
        0x99C1D49D: types.JsonObject,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Jsonvalue':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_json_null(self) -> bool:
        return isinstance(self._inner, types.JsonNull)

    def as_json_null(self) -> Optional[types.JsonNull]:
        return self._inner if self.is_json_null() else None

    def is_json_bool(self) -> bool:
        return isinstance(self._inner, types.JsonBool)

    def as_json_bool(self) -> Optional[types.JsonBool]:
        return self._inner if self.is_json_bool() else None

    def is_json_number(self) -> bool:
        return isinstance(self._inner, types.JsonNumber)

    def as_json_number(self) -> Optional[types.JsonNumber]:
        return self._inner if self.is_json_number() else None

    def is_json_string(self) -> bool:
        return isinstance(self._inner, types.JsonString)

    def as_json_string(self) -> Optional[types.JsonString]:
        return self._inner if self.is_json_string() else None

    def is_json_array(self) -> bool:
        return isinstance(self._inner, types.JsonArray)

    def as_json_array(self) -> Optional[types.JsonArray]:
        return self._inner if self.is_json_array() else None

    def is_json_object(self) -> bool:
        return isinstance(self._inner, types.JsonObject)

    def as_json_object(self) -> Optional[types.JsonObject]:
        return self._inner if self.is_json_object() else None

    def __repr__(self) -> str:
        return f'Jsonvalue({self._inner!r})'


class KeyboardButton(TLObject):
    """
    Boxed TL type ``KeyboardButton`` — union of 18 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7D170CFF: types.KeyboardButton,
        0xD80C25EC: types.KeyboardButtonUrl,
        0xE62BC960: types.KeyboardButtonCallback,
        0x417EFD8F: types.KeyboardButtonRequestPhone,
        0xAA40F94D: types.KeyboardButtonRequestGeoLocation,
        0x991399FC: types.KeyboardButtonSwitchInline,
        0x89C590F9: types.KeyboardButtonGame,
        0x3FA53905: types.KeyboardButtonBuy,
        0xF51006F9: types.KeyboardButtonUrlAuth,
        0x68013E72: types.InputKeyboardButtonUrlAuth,
        0x7A11D782: types.KeyboardButtonRequestPoll,
        0x7D5E07C7: types.InputKeyboardButtonUserProfile,
        0xC0FD5D09: types.KeyboardButtonUserProfile,
        0xE846B1A0: types.KeyboardButtonWebView,
        0xE15C4370: types.KeyboardButtonSimpleWebView,
        0x5B0F15F5: types.KeyboardButtonRequestPeer,
        0x02B78156: types.InputKeyboardButtonRequestPeer,
        0xBCC4AF10: types.KeyboardButtonCopy,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'KeyboardButton':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_keyboard_button(self) -> bool:
        return isinstance(self._inner, types.KeyboardButton)

    def as_keyboard_button(self) -> Optional[types.KeyboardButton]:
        return self._inner if self.is_keyboard_button() else None

    def is_url(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonUrl)

    def as_url(self) -> Optional[types.KeyboardButtonUrl]:
        return self._inner if self.is_url() else None

    def is_callback(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonCallback)

    def as_callback(self) -> Optional[types.KeyboardButtonCallback]:
        return self._inner if self.is_callback() else None

    def is_request_phone(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonRequestPhone)

    def as_request_phone(self) -> Optional[types.KeyboardButtonRequestPhone]:
        return self._inner if self.is_request_phone() else None

    def is_request_geo_location(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonRequestGeoLocation)

    def as_request_geo_location(self) -> Optional[types.KeyboardButtonRequestGeoLocation]:
        return self._inner if self.is_request_geo_location() else None

    def is_switch_inline(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonSwitchInline)

    def as_switch_inline(self) -> Optional[types.KeyboardButtonSwitchInline]:
        return self._inner if self.is_switch_inline() else None

    def is_game(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonGame)

    def as_game(self) -> Optional[types.KeyboardButtonGame]:
        return self._inner if self.is_game() else None

    def is_buy(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonBuy)

    def as_buy(self) -> Optional[types.KeyboardButtonBuy]:
        return self._inner if self.is_buy() else None

    def is_url_auth(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonUrlAuth)

    def as_url_auth(self) -> Optional[types.KeyboardButtonUrlAuth]:
        return self._inner if self.is_url_auth() else None

    def is_input_keyboard_button_url_auth(self) -> bool:
        return isinstance(self._inner, types.InputKeyboardButtonUrlAuth)

    def as_input_keyboard_button_url_auth(self) -> Optional[types.InputKeyboardButtonUrlAuth]:
        return self._inner if self.is_input_keyboard_button_url_auth() else None

    def is_request_poll(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonRequestPoll)

    def as_request_poll(self) -> Optional[types.KeyboardButtonRequestPoll]:
        return self._inner if self.is_request_poll() else None

    def is_input_keyboard_button_user_profile(self) -> bool:
        return isinstance(self._inner, types.InputKeyboardButtonUserProfile)

    def as_input_keyboard_button_user_profile(self) -> Optional[types.InputKeyboardButtonUserProfile]:
        return self._inner if self.is_input_keyboard_button_user_profile() else None

    def is_user_profile(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonUserProfile)

    def as_user_profile(self) -> Optional[types.KeyboardButtonUserProfile]:
        return self._inner if self.is_user_profile() else None

    def is_web_view(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonWebView)

    def as_web_view(self) -> Optional[types.KeyboardButtonWebView]:
        return self._inner if self.is_web_view() else None

    def is_simple_web_view(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonSimpleWebView)

    def as_simple_web_view(self) -> Optional[types.KeyboardButtonSimpleWebView]:
        return self._inner if self.is_simple_web_view() else None

    def is_request_peer(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonRequestPeer)

    def as_request_peer(self) -> Optional[types.KeyboardButtonRequestPeer]:
        return self._inner if self.is_request_peer() else None

    def is_input_keyboard_button_request_peer(self) -> bool:
        return isinstance(self._inner, types.InputKeyboardButtonRequestPeer)

    def as_input_keyboard_button_request_peer(self) -> Optional[types.InputKeyboardButtonRequestPeer]:
        return self._inner if self.is_input_keyboard_button_request_peer() else None

    def is_copy(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonCopy)

    def as_copy(self) -> Optional[types.KeyboardButtonCopy]:
        return self._inner if self.is_copy() else None

    def __repr__(self) -> str:
        return f'KeyboardButton({self._inner!r})'


class KeyboardButtonRow(TLObject):
    """
    Boxed TL type ``KeyboardButtonRow`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x77608B83: types.KeyboardButtonRow,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'KeyboardButtonRow':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_keyboard_button_row(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonRow)

    def as_keyboard_button_row(self) -> Optional[types.KeyboardButtonRow]:
        return self._inner if self.is_keyboard_button_row() else None

    def __repr__(self) -> str:
        return f'KeyboardButtonRow({self._inner!r})'


class KeyboardButtonStyle(TLObject):
    """
    Boxed TL type ``KeyboardButtonStyle`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4FDD3430: types.KeyboardButtonStyle,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'KeyboardButtonStyle':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_keyboard_button_style(self) -> bool:
        return isinstance(self._inner, types.KeyboardButtonStyle)

    def as_keyboard_button_style(self) -> Optional[types.KeyboardButtonStyle]:
        return self._inner if self.is_keyboard_button_style() else None

    def __repr__(self) -> str:
        return f'KeyboardButtonStyle({self._inner!r})'


class LabeledPrice(TLObject):
    """
    Boxed TL type ``LabeledPrice`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCB296BF8: types.LabeledPrice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'LabeledPrice':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_labeled_price(self) -> bool:
        return isinstance(self._inner, types.LabeledPrice)

    def as_labeled_price(self) -> Optional[types.LabeledPrice]:
        return self._inner if self.is_labeled_price() else None

    def __repr__(self) -> str:
        return f'LabeledPrice({self._inner!r})'


class LangPackDifference(TLObject):
    """
    Boxed TL type ``LangPackDifference`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF385C1F6: types.LangPackDifference,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'LangPackDifference':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_lang_pack_difference(self) -> bool:
        return isinstance(self._inner, types.LangPackDifference)

    def as_lang_pack_difference(self) -> Optional[types.LangPackDifference]:
        return self._inner if self.is_lang_pack_difference() else None

    def __repr__(self) -> str:
        return f'LangPackDifference({self._inner!r})'


class LangPackLanguage(TLObject):
    """
    Boxed TL type ``LangPackLanguage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEECA5CE3: types.LangPackLanguage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'LangPackLanguage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_lang_pack_language(self) -> bool:
        return isinstance(self._inner, types.LangPackLanguage)

    def as_lang_pack_language(self) -> Optional[types.LangPackLanguage]:
        return self._inner if self.is_lang_pack_language() else None

    def __repr__(self) -> str:
        return f'LangPackLanguage({self._inner!r})'


class LangPackString(TLObject):
    """
    Boxed TL type ``LangPackString`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCAD181F6: types.LangPackString,
        0x6C47AC9F: types.LangPackStringPluralized,
        0x2979EEB2: types.LangPackStringDeleted,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'LangPackString':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_lang_pack_string(self) -> bool:
        return isinstance(self._inner, types.LangPackString)

    def as_lang_pack_string(self) -> Optional[types.LangPackString]:
        return self._inner if self.is_lang_pack_string() else None

    def is_pluralized(self) -> bool:
        return isinstance(self._inner, types.LangPackStringPluralized)

    def as_pluralized(self) -> Optional[types.LangPackStringPluralized]:
        return self._inner if self.is_pluralized() else None

    def is_deleted(self) -> bool:
        return isinstance(self._inner, types.LangPackStringDeleted)

    def as_deleted(self) -> Optional[types.LangPackStringDeleted]:
        return self._inner if self.is_deleted() else None

    def __repr__(self) -> str:
        return f'LangPackString({self._inner!r})'


class MaskCoords(TLObject):
    """
    Boxed TL type ``MaskCoords`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAED6DBB2: types.MaskCoords,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MaskCoords':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_mask_coords(self) -> bool:
        return isinstance(self._inner, types.MaskCoords)

    def as_mask_coords(self) -> Optional[types.MaskCoords]:
        return self._inner if self.is_mask_coords() else None

    def __repr__(self) -> str:
        return f'MaskCoords({self._inner!r})'


class MediaArea(TLObject):
    """
    Boxed TL type ``MediaArea`` — union of 9 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBE82DB9C: types.MediaAreaVenue,
        0xB282217F: types.InputMediaAreaVenue,
        0xCAD5452D: types.MediaAreaGeoPoint,
        0x14455871: types.MediaAreaSuggestedReaction,
        0x770416AF: types.MediaAreaChannelPost,
        0x2271F2BF: types.InputMediaAreaChannelPost,
        0x37381085: types.MediaAreaUrl,
        0x49A6549C: types.MediaAreaWeather,
        0x5787686D: types.MediaAreaStarGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MediaArea':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_venue(self) -> bool:
        return isinstance(self._inner, types.MediaAreaVenue)

    def as_venue(self) -> Optional[types.MediaAreaVenue]:
        return self._inner if self.is_venue() else None

    def is_input_media_area_venue(self) -> bool:
        return isinstance(self._inner, types.InputMediaAreaVenue)

    def as_input_media_area_venue(self) -> Optional[types.InputMediaAreaVenue]:
        return self._inner if self.is_input_media_area_venue() else None

    def is_geo_point(self) -> bool:
        return isinstance(self._inner, types.MediaAreaGeoPoint)

    def as_geo_point(self) -> Optional[types.MediaAreaGeoPoint]:
        return self._inner if self.is_geo_point() else None

    def is_suggested_reaction(self) -> bool:
        return isinstance(self._inner, types.MediaAreaSuggestedReaction)

    def as_suggested_reaction(self) -> Optional[types.MediaAreaSuggestedReaction]:
        return self._inner if self.is_suggested_reaction() else None

    def is_channel_post(self) -> bool:
        return isinstance(self._inner, types.MediaAreaChannelPost)

    def as_channel_post(self) -> Optional[types.MediaAreaChannelPost]:
        return self._inner if self.is_channel_post() else None

    def is_input_media_area_channel_post(self) -> bool:
        return isinstance(self._inner, types.InputMediaAreaChannelPost)

    def as_input_media_area_channel_post(self) -> Optional[types.InputMediaAreaChannelPost]:
        return self._inner if self.is_input_media_area_channel_post() else None

    def is_url(self) -> bool:
        return isinstance(self._inner, types.MediaAreaUrl)

    def as_url(self) -> Optional[types.MediaAreaUrl]:
        return self._inner if self.is_url() else None

    def is_weather(self) -> bool:
        return isinstance(self._inner, types.MediaAreaWeather)

    def as_weather(self) -> Optional[types.MediaAreaWeather]:
        return self._inner if self.is_weather() else None

    def is_star_gift(self) -> bool:
        return isinstance(self._inner, types.MediaAreaStarGift)

    def as_star_gift(self) -> Optional[types.MediaAreaStarGift]:
        return self._inner if self.is_star_gift() else None

    def __repr__(self) -> str:
        return f'MediaArea({self._inner!r})'


class MediaAreaCoordinates(TLObject):
    """
    Boxed TL type ``MediaAreaCoordinates`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCFC9E002: types.MediaAreaCoordinates,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MediaAreaCoordinates':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_media_area_coordinates(self) -> bool:
        return isinstance(self._inner, types.MediaAreaCoordinates)

    def as_media_area_coordinates(self) -> Optional[types.MediaAreaCoordinates]:
        return self._inner if self.is_media_area_coordinates() else None

    def __repr__(self) -> str:
        return f'MediaAreaCoordinates({self._inner!r})'


class Message(TLObject):
    """
    Boxed TL type ``Message`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x90A6CA84: types.MessageEmpty,
        0x9CB490E9: types.Message,
        0x7A800E0A: types.MessageService,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Message':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.MessageEmpty)

    def as_empty(self) -> Optional[types.MessageEmpty]:
        return self._inner if self.is_empty() else None

    def is_message(self) -> bool:
        return isinstance(self._inner, types.Message)

    def as_message(self) -> Optional[types.Message]:
        return self._inner if self.is_message() else None

    def is_service(self) -> bool:
        return isinstance(self._inner, types.MessageService)

    def as_service(self) -> Optional[types.MessageService]:
        return self._inner if self.is_service() else None

    def __repr__(self) -> str:
        return f'Message({self._inner!r})'


class MessageAction(TLObject):
    """
    Boxed TL type ``MessageAction`` — union of 62 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB6AEF7B0: types.MessageActionEmpty,
        0xBD47CBAD: types.MessageActionChatCreate,
        0xB5A1CE5A: types.MessageActionChatEditTitle,
        0x7FCB13A8: types.MessageActionChatEditPhoto,
        0x95E3FBEF: types.MessageActionChatDeletePhoto,
        0x15CEFD00: types.MessageActionChatAddUser,
        0xA43F30CC: types.MessageActionChatDeleteUser,
        0x031224C3: types.MessageActionChatJoinedByLink,
        0x95D2AC92: types.MessageActionChannelCreate,
        0xE1037F92: types.MessageActionChatMigrateTo,
        0xEA3948E9: types.MessageActionChannelMigrateFrom,
        0x94BD38ED: types.MessageActionPinMessage,
        0x9FBAB604: types.MessageActionHistoryClear,
        0x92A72876: types.MessageActionGameScore,
        0xFFA00CCC: types.MessageActionPaymentSentMe,
        0xC624B16E: types.MessageActionPaymentSent,
        0x80E11A7F: types.MessageActionPhoneCall,
        0x4792929B: types.MessageActionScreenshotTaken,
        0xFAE69F56: types.MessageActionCustomAction,
        0xC516D679: types.MessageActionBotAllowed,
        0x1B287353: types.MessageActionSecureValuesSentMe,
        0xD95C6154: types.MessageActionSecureValuesSent,
        0xF3F25F76: types.MessageActionContactSignUp,
        0x98E0D697: types.MessageActionGeoProximityReached,
        0x7A0D7F42: types.MessageActionGroupCall,
        0x502F92F7: types.MessageActionInviteToGroupCall,
        0x3C134D7B: types.MessageActionSetMessagesTtl,
        0xB3A07661: types.MessageActionGroupCallScheduled,
        0xB91BBD3A: types.MessageActionSetChatTheme,
        0xEBBCA3CB: types.MessageActionChatJoinedByRequest,
        0x47DD8079: types.MessageActionWebViewDataSentMe,
        0xB4C38CB5: types.MessageActionWebViewDataSent,
        0x48E91302: types.MessageActionGiftPremium,
        0x0D999256: types.MessageActionTopicCreate,
        0xC0944820: types.MessageActionTopicEdit,
        0x57DE635E: types.MessageActionSuggestProfilePhoto,
        0x31518E9B: types.MessageActionRequestedPeer,
        0x5060A3F4: types.MessageActionSetChatWallPaper,
        0x31C48347: types.MessageActionGiftCode,
        0xA80F51E4: types.MessageActionGiveawayLaunch,
        0x87E2F155: types.MessageActionGiveawayResults,
        0xCC02AA6D: types.MessageActionBoostApply,
        0x93B31848: types.MessageActionRequestedPeerSentMe,
        0x41B3E202: types.MessageActionPaymentRefunded,
        0x45D5B021: types.MessageActionGiftStars,
        0xB00C47A2: types.MessageActionPrizeStars,
        0xEA2C31D3: types.MessageActionStarGift,
        0xE6C31522: types.MessageActionStarGiftUnique,
        0xAC1F1FCD: types.MessageActionPaidMessagesRefunded,
        0x84B88578: types.MessageActionPaidMessagesPrice,
        0x2FFE2F7A: types.MessageActionConferenceCall,
        0xCC7C5C89: types.MessageActionTodoCompletions,
        0xC7EDBC83: types.MessageActionTodoAppendTasks,
        0xEE7A1596: types.MessageActionSuggestedPostApproval,
        0x95DDCF69: types.MessageActionSuggestedPostSuccess,
        0x69F916F8: types.MessageActionSuggestedPostRefund,
        0xA8A3C699: types.MessageActionGiftTon,
        0x2C8F2A25: types.MessageActionSuggestBirthday,
        0x774278D4: types.MessageActionStarGiftPurchaseOffer,
        0x73ADA76B: types.MessageActionStarGiftPurchaseOfferDeclined,
        0xB07ED085: types.MessageActionNewCreatorPending,
        0xE188503B: types.MessageActionChangeCreator,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageAction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.MessageActionEmpty)

    def as_empty(self) -> Optional[types.MessageActionEmpty]:
        return self._inner if self.is_empty() else None

    def is_chat_create(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatCreate)

    def as_chat_create(self) -> Optional[types.MessageActionChatCreate]:
        return self._inner if self.is_chat_create() else None

    def is_chat_edit_title(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatEditTitle)

    def as_chat_edit_title(self) -> Optional[types.MessageActionChatEditTitle]:
        return self._inner if self.is_chat_edit_title() else None

    def is_chat_edit_photo(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatEditPhoto)

    def as_chat_edit_photo(self) -> Optional[types.MessageActionChatEditPhoto]:
        return self._inner if self.is_chat_edit_photo() else None

    def is_chat_delete_photo(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatDeletePhoto)

    def as_chat_delete_photo(self) -> Optional[types.MessageActionChatDeletePhoto]:
        return self._inner if self.is_chat_delete_photo() else None

    def is_chat_add_user(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatAddUser)

    def as_chat_add_user(self) -> Optional[types.MessageActionChatAddUser]:
        return self._inner if self.is_chat_add_user() else None

    def is_chat_delete_user(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatDeleteUser)

    def as_chat_delete_user(self) -> Optional[types.MessageActionChatDeleteUser]:
        return self._inner if self.is_chat_delete_user() else None

    def is_chat_joined_by_link(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatJoinedByLink)

    def as_chat_joined_by_link(self) -> Optional[types.MessageActionChatJoinedByLink]:
        return self._inner if self.is_chat_joined_by_link() else None

    def is_channel_create(self) -> bool:
        return isinstance(self._inner, types.MessageActionChannelCreate)

    def as_channel_create(self) -> Optional[types.MessageActionChannelCreate]:
        return self._inner if self.is_channel_create() else None

    def is_chat_migrate_to(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatMigrateTo)

    def as_chat_migrate_to(self) -> Optional[types.MessageActionChatMigrateTo]:
        return self._inner if self.is_chat_migrate_to() else None

    def is_channel_migrate_from(self) -> bool:
        return isinstance(self._inner, types.MessageActionChannelMigrateFrom)

    def as_channel_migrate_from(self) -> Optional[types.MessageActionChannelMigrateFrom]:
        return self._inner if self.is_channel_migrate_from() else None

    def is_pin_message(self) -> bool:
        return isinstance(self._inner, types.MessageActionPinMessage)

    def as_pin_message(self) -> Optional[types.MessageActionPinMessage]:
        return self._inner if self.is_pin_message() else None

    def is_history_clear(self) -> bool:
        return isinstance(self._inner, types.MessageActionHistoryClear)

    def as_history_clear(self) -> Optional[types.MessageActionHistoryClear]:
        return self._inner if self.is_history_clear() else None

    def is_game_score(self) -> bool:
        return isinstance(self._inner, types.MessageActionGameScore)

    def as_game_score(self) -> Optional[types.MessageActionGameScore]:
        return self._inner if self.is_game_score() else None

    def is_payment_sent_me(self) -> bool:
        return isinstance(self._inner, types.MessageActionPaymentSentMe)

    def as_payment_sent_me(self) -> Optional[types.MessageActionPaymentSentMe]:
        return self._inner if self.is_payment_sent_me() else None

    def is_payment_sent(self) -> bool:
        return isinstance(self._inner, types.MessageActionPaymentSent)

    def as_payment_sent(self) -> Optional[types.MessageActionPaymentSent]:
        return self._inner if self.is_payment_sent() else None

    def is_phone_call(self) -> bool:
        return isinstance(self._inner, types.MessageActionPhoneCall)

    def as_phone_call(self) -> Optional[types.MessageActionPhoneCall]:
        return self._inner if self.is_phone_call() else None

    def is_screenshot_taken(self) -> bool:
        return isinstance(self._inner, types.MessageActionScreenshotTaken)

    def as_screenshot_taken(self) -> Optional[types.MessageActionScreenshotTaken]:
        return self._inner if self.is_screenshot_taken() else None

    def is_custom_action(self) -> bool:
        return isinstance(self._inner, types.MessageActionCustomAction)

    def as_custom_action(self) -> Optional[types.MessageActionCustomAction]:
        return self._inner if self.is_custom_action() else None

    def is_bot_allowed(self) -> bool:
        return isinstance(self._inner, types.MessageActionBotAllowed)

    def as_bot_allowed(self) -> Optional[types.MessageActionBotAllowed]:
        return self._inner if self.is_bot_allowed() else None

    def is_secure_values_sent_me(self) -> bool:
        return isinstance(self._inner, types.MessageActionSecureValuesSentMe)

    def as_secure_values_sent_me(self) -> Optional[types.MessageActionSecureValuesSentMe]:
        return self._inner if self.is_secure_values_sent_me() else None

    def is_secure_values_sent(self) -> bool:
        return isinstance(self._inner, types.MessageActionSecureValuesSent)

    def as_secure_values_sent(self) -> Optional[types.MessageActionSecureValuesSent]:
        return self._inner if self.is_secure_values_sent() else None

    def is_contact_sign_up(self) -> bool:
        return isinstance(self._inner, types.MessageActionContactSignUp)

    def as_contact_sign_up(self) -> Optional[types.MessageActionContactSignUp]:
        return self._inner if self.is_contact_sign_up() else None

    def is_geo_proximity_reached(self) -> bool:
        return isinstance(self._inner, types.MessageActionGeoProximityReached)

    def as_geo_proximity_reached(self) -> Optional[types.MessageActionGeoProximityReached]:
        return self._inner if self.is_geo_proximity_reached() else None

    def is_group_call(self) -> bool:
        return isinstance(self._inner, types.MessageActionGroupCall)

    def as_group_call(self) -> Optional[types.MessageActionGroupCall]:
        return self._inner if self.is_group_call() else None

    def is_invite_to_group_call(self) -> bool:
        return isinstance(self._inner, types.MessageActionInviteToGroupCall)

    def as_invite_to_group_call(self) -> Optional[types.MessageActionInviteToGroupCall]:
        return self._inner if self.is_invite_to_group_call() else None

    def is_set_messages_ttl(self) -> bool:
        return isinstance(self._inner, types.MessageActionSetMessagesTtl)

    def as_set_messages_ttl(self) -> Optional[types.MessageActionSetMessagesTtl]:
        return self._inner if self.is_set_messages_ttl() else None

    def is_group_call_scheduled(self) -> bool:
        return isinstance(self._inner, types.MessageActionGroupCallScheduled)

    def as_group_call_scheduled(self) -> Optional[types.MessageActionGroupCallScheduled]:
        return self._inner if self.is_group_call_scheduled() else None

    def is_set_chat_theme(self) -> bool:
        return isinstance(self._inner, types.MessageActionSetChatTheme)

    def as_set_chat_theme(self) -> Optional[types.MessageActionSetChatTheme]:
        return self._inner if self.is_set_chat_theme() else None

    def is_chat_joined_by_request(self) -> bool:
        return isinstance(self._inner, types.MessageActionChatJoinedByRequest)

    def as_chat_joined_by_request(self) -> Optional[types.MessageActionChatJoinedByRequest]:
        return self._inner if self.is_chat_joined_by_request() else None

    def is_web_view_data_sent_me(self) -> bool:
        return isinstance(self._inner, types.MessageActionWebViewDataSentMe)

    def as_web_view_data_sent_me(self) -> Optional[types.MessageActionWebViewDataSentMe]:
        return self._inner if self.is_web_view_data_sent_me() else None

    def is_web_view_data_sent(self) -> bool:
        return isinstance(self._inner, types.MessageActionWebViewDataSent)

    def as_web_view_data_sent(self) -> Optional[types.MessageActionWebViewDataSent]:
        return self._inner if self.is_web_view_data_sent() else None

    def is_gift_premium(self) -> bool:
        return isinstance(self._inner, types.MessageActionGiftPremium)

    def as_gift_premium(self) -> Optional[types.MessageActionGiftPremium]:
        return self._inner if self.is_gift_premium() else None

    def is_topic_create(self) -> bool:
        return isinstance(self._inner, types.MessageActionTopicCreate)

    def as_topic_create(self) -> Optional[types.MessageActionTopicCreate]:
        return self._inner if self.is_topic_create() else None

    def is_topic_edit(self) -> bool:
        return isinstance(self._inner, types.MessageActionTopicEdit)

    def as_topic_edit(self) -> Optional[types.MessageActionTopicEdit]:
        return self._inner if self.is_topic_edit() else None

    def is_suggest_profile_photo(self) -> bool:
        return isinstance(self._inner, types.MessageActionSuggestProfilePhoto)

    def as_suggest_profile_photo(self) -> Optional[types.MessageActionSuggestProfilePhoto]:
        return self._inner if self.is_suggest_profile_photo() else None

    def is_requested_peer(self) -> bool:
        return isinstance(self._inner, types.MessageActionRequestedPeer)

    def as_requested_peer(self) -> Optional[types.MessageActionRequestedPeer]:
        return self._inner if self.is_requested_peer() else None

    def is_set_chat_wall_paper(self) -> bool:
        return isinstance(self._inner, types.MessageActionSetChatWallPaper)

    def as_set_chat_wall_paper(self) -> Optional[types.MessageActionSetChatWallPaper]:
        return self._inner if self.is_set_chat_wall_paper() else None

    def is_gift_code(self) -> bool:
        return isinstance(self._inner, types.MessageActionGiftCode)

    def as_gift_code(self) -> Optional[types.MessageActionGiftCode]:
        return self._inner if self.is_gift_code() else None

    def is_giveaway_launch(self) -> bool:
        return isinstance(self._inner, types.MessageActionGiveawayLaunch)

    def as_giveaway_launch(self) -> Optional[types.MessageActionGiveawayLaunch]:
        return self._inner if self.is_giveaway_launch() else None

    def is_giveaway_results(self) -> bool:
        return isinstance(self._inner, types.MessageActionGiveawayResults)

    def as_giveaway_results(self) -> Optional[types.MessageActionGiveawayResults]:
        return self._inner if self.is_giveaway_results() else None

    def is_boost_apply(self) -> bool:
        return isinstance(self._inner, types.MessageActionBoostApply)

    def as_boost_apply(self) -> Optional[types.MessageActionBoostApply]:
        return self._inner if self.is_boost_apply() else None

    def is_requested_peer_sent_me(self) -> bool:
        return isinstance(self._inner, types.MessageActionRequestedPeerSentMe)

    def as_requested_peer_sent_me(self) -> Optional[types.MessageActionRequestedPeerSentMe]:
        return self._inner if self.is_requested_peer_sent_me() else None

    def is_payment_refunded(self) -> bool:
        return isinstance(self._inner, types.MessageActionPaymentRefunded)

    def as_payment_refunded(self) -> Optional[types.MessageActionPaymentRefunded]:
        return self._inner if self.is_payment_refunded() else None

    def is_gift_stars(self) -> bool:
        return isinstance(self._inner, types.MessageActionGiftStars)

    def as_gift_stars(self) -> Optional[types.MessageActionGiftStars]:
        return self._inner if self.is_gift_stars() else None

    def is_prize_stars(self) -> bool:
        return isinstance(self._inner, types.MessageActionPrizeStars)

    def as_prize_stars(self) -> Optional[types.MessageActionPrizeStars]:
        return self._inner if self.is_prize_stars() else None

    def is_star_gift(self) -> bool:
        return isinstance(self._inner, types.MessageActionStarGift)

    def as_star_gift(self) -> Optional[types.MessageActionStarGift]:
        return self._inner if self.is_star_gift() else None

    def is_star_gift_unique(self) -> bool:
        return isinstance(self._inner, types.MessageActionStarGiftUnique)

    def as_star_gift_unique(self) -> Optional[types.MessageActionStarGiftUnique]:
        return self._inner if self.is_star_gift_unique() else None

    def is_paid_messages_refunded(self) -> bool:
        return isinstance(self._inner, types.MessageActionPaidMessagesRefunded)

    def as_paid_messages_refunded(self) -> Optional[types.MessageActionPaidMessagesRefunded]:
        return self._inner if self.is_paid_messages_refunded() else None

    def is_paid_messages_price(self) -> bool:
        return isinstance(self._inner, types.MessageActionPaidMessagesPrice)

    def as_paid_messages_price(self) -> Optional[types.MessageActionPaidMessagesPrice]:
        return self._inner if self.is_paid_messages_price() else None

    def is_conference_call(self) -> bool:
        return isinstance(self._inner, types.MessageActionConferenceCall)

    def as_conference_call(self) -> Optional[types.MessageActionConferenceCall]:
        return self._inner if self.is_conference_call() else None

    def is_todo_completions(self) -> bool:
        return isinstance(self._inner, types.MessageActionTodoCompletions)

    def as_todo_completions(self) -> Optional[types.MessageActionTodoCompletions]:
        return self._inner if self.is_todo_completions() else None

    def is_todo_append_tasks(self) -> bool:
        return isinstance(self._inner, types.MessageActionTodoAppendTasks)

    def as_todo_append_tasks(self) -> Optional[types.MessageActionTodoAppendTasks]:
        return self._inner if self.is_todo_append_tasks() else None

    def is_suggested_post_approval(self) -> bool:
        return isinstance(self._inner, types.MessageActionSuggestedPostApproval)

    def as_suggested_post_approval(self) -> Optional[types.MessageActionSuggestedPostApproval]:
        return self._inner if self.is_suggested_post_approval() else None

    def is_suggested_post_success(self) -> bool:
        return isinstance(self._inner, types.MessageActionSuggestedPostSuccess)

    def as_suggested_post_success(self) -> Optional[types.MessageActionSuggestedPostSuccess]:
        return self._inner if self.is_suggested_post_success() else None

    def is_suggested_post_refund(self) -> bool:
        return isinstance(self._inner, types.MessageActionSuggestedPostRefund)

    def as_suggested_post_refund(self) -> Optional[types.MessageActionSuggestedPostRefund]:
        return self._inner if self.is_suggested_post_refund() else None

    def is_gift_ton(self) -> bool:
        return isinstance(self._inner, types.MessageActionGiftTon)

    def as_gift_ton(self) -> Optional[types.MessageActionGiftTon]:
        return self._inner if self.is_gift_ton() else None

    def is_suggest_birthday(self) -> bool:
        return isinstance(self._inner, types.MessageActionSuggestBirthday)

    def as_suggest_birthday(self) -> Optional[types.MessageActionSuggestBirthday]:
        return self._inner if self.is_suggest_birthday() else None

    def is_star_gift_purchase_offer(self) -> bool:
        return isinstance(self._inner, types.MessageActionStarGiftPurchaseOffer)

    def as_star_gift_purchase_offer(self) -> Optional[types.MessageActionStarGiftPurchaseOffer]:
        return self._inner if self.is_star_gift_purchase_offer() else None

    def is_star_gift_purchase_offer_declined(self) -> bool:
        return isinstance(self._inner, types.MessageActionStarGiftPurchaseOfferDeclined)

    def as_star_gift_purchase_offer_declined(self) -> Optional[types.MessageActionStarGiftPurchaseOfferDeclined]:
        return self._inner if self.is_star_gift_purchase_offer_declined() else None

    def is_new_creator_pending(self) -> bool:
        return isinstance(self._inner, types.MessageActionNewCreatorPending)

    def as_new_creator_pending(self) -> Optional[types.MessageActionNewCreatorPending]:
        return self._inner if self.is_new_creator_pending() else None

    def is_change_creator(self) -> bool:
        return isinstance(self._inner, types.MessageActionChangeCreator)

    def as_change_creator(self) -> Optional[types.MessageActionChangeCreator]:
        return self._inner if self.is_change_creator() else None

    def __repr__(self) -> str:
        return f'MessageAction({self._inner!r})'


class MessageEntity(TLObject):
    """
    Boxed TL type ``MessageEntity`` — union of 21 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBB92BA95: types.MessageEntityUnknown,
        0xFA04579D: types.MessageEntityMention,
        0x6F635B0D: types.MessageEntityHashtag,
        0x6CEF8AC7: types.MessageEntityBotCommand,
        0x6ED02538: types.MessageEntityUrl,
        0x64E475C2: types.MessageEntityEmail,
        0xBD610BC9: types.MessageEntityBold,
        0x826F8B60: types.MessageEntityItalic,
        0x28A20571: types.MessageEntityCode,
        0x73924BE0: types.MessageEntityPre,
        0x76A6D327: types.MessageEntityTextUrl,
        0xDC7B1140: types.MessageEntityMentionName,
        0x208E68C9: types.InputMessageEntityMentionName,
        0x9B69E34B: types.MessageEntityPhone,
        0x4C4E743F: types.MessageEntityCashtag,
        0x9C4E7E8B: types.MessageEntityUnderline,
        0xBF0693D4: types.MessageEntityStrike,
        0x761E6AF4: types.MessageEntityBankCard,
        0x32CA960F: types.MessageEntitySpoiler,
        0xC8CF05F8: types.MessageEntityCustomEmoji,
        0xF1CCAAAC: types.MessageEntityBlockquote,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageEntity':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unknown(self) -> bool:
        return isinstance(self._inner, types.MessageEntityUnknown)

    def as_unknown(self) -> Optional[types.MessageEntityUnknown]:
        return self._inner if self.is_unknown() else None

    def is_mention(self) -> bool:
        return isinstance(self._inner, types.MessageEntityMention)

    def as_mention(self) -> Optional[types.MessageEntityMention]:
        return self._inner if self.is_mention() else None

    def is_hashtag(self) -> bool:
        return isinstance(self._inner, types.MessageEntityHashtag)

    def as_hashtag(self) -> Optional[types.MessageEntityHashtag]:
        return self._inner if self.is_hashtag() else None

    def is_bot_command(self) -> bool:
        return isinstance(self._inner, types.MessageEntityBotCommand)

    def as_bot_command(self) -> Optional[types.MessageEntityBotCommand]:
        return self._inner if self.is_bot_command() else None

    def is_url(self) -> bool:
        return isinstance(self._inner, types.MessageEntityUrl)

    def as_url(self) -> Optional[types.MessageEntityUrl]:
        return self._inner if self.is_url() else None

    def is_email(self) -> bool:
        return isinstance(self._inner, types.MessageEntityEmail)

    def as_email(self) -> Optional[types.MessageEntityEmail]:
        return self._inner if self.is_email() else None

    def is_bold(self) -> bool:
        return isinstance(self._inner, types.MessageEntityBold)

    def as_bold(self) -> Optional[types.MessageEntityBold]:
        return self._inner if self.is_bold() else None

    def is_italic(self) -> bool:
        return isinstance(self._inner, types.MessageEntityItalic)

    def as_italic(self) -> Optional[types.MessageEntityItalic]:
        return self._inner if self.is_italic() else None

    def is_code(self) -> bool:
        return isinstance(self._inner, types.MessageEntityCode)

    def as_code(self) -> Optional[types.MessageEntityCode]:
        return self._inner if self.is_code() else None

    def is_pre(self) -> bool:
        return isinstance(self._inner, types.MessageEntityPre)

    def as_pre(self) -> Optional[types.MessageEntityPre]:
        return self._inner if self.is_pre() else None

    def is_text_url(self) -> bool:
        return isinstance(self._inner, types.MessageEntityTextUrl)

    def as_text_url(self) -> Optional[types.MessageEntityTextUrl]:
        return self._inner if self.is_text_url() else None

    def is_mention_name(self) -> bool:
        return isinstance(self._inner, types.MessageEntityMentionName)

    def as_mention_name(self) -> Optional[types.MessageEntityMentionName]:
        return self._inner if self.is_mention_name() else None

    def is_input_message_entity_mention_name(self) -> bool:
        return isinstance(self._inner, types.InputMessageEntityMentionName)

    def as_input_message_entity_mention_name(self) -> Optional[types.InputMessageEntityMentionName]:
        return self._inner if self.is_input_message_entity_mention_name() else None

    def is_phone(self) -> bool:
        return isinstance(self._inner, types.MessageEntityPhone)

    def as_phone(self) -> Optional[types.MessageEntityPhone]:
        return self._inner if self.is_phone() else None

    def is_cashtag(self) -> bool:
        return isinstance(self._inner, types.MessageEntityCashtag)

    def as_cashtag(self) -> Optional[types.MessageEntityCashtag]:
        return self._inner if self.is_cashtag() else None

    def is_underline(self) -> bool:
        return isinstance(self._inner, types.MessageEntityUnderline)

    def as_underline(self) -> Optional[types.MessageEntityUnderline]:
        return self._inner if self.is_underline() else None

    def is_strike(self) -> bool:
        return isinstance(self._inner, types.MessageEntityStrike)

    def as_strike(self) -> Optional[types.MessageEntityStrike]:
        return self._inner if self.is_strike() else None

    def is_bank_card(self) -> bool:
        return isinstance(self._inner, types.MessageEntityBankCard)

    def as_bank_card(self) -> Optional[types.MessageEntityBankCard]:
        return self._inner if self.is_bank_card() else None

    def is_spoiler(self) -> bool:
        return isinstance(self._inner, types.MessageEntitySpoiler)

    def as_spoiler(self) -> Optional[types.MessageEntitySpoiler]:
        return self._inner if self.is_spoiler() else None

    def is_custom_emoji(self) -> bool:
        return isinstance(self._inner, types.MessageEntityCustomEmoji)

    def as_custom_emoji(self) -> Optional[types.MessageEntityCustomEmoji]:
        return self._inner if self.is_custom_emoji() else None

    def is_blockquote(self) -> bool:
        return isinstance(self._inner, types.MessageEntityBlockquote)

    def as_blockquote(self) -> Optional[types.MessageEntityBlockquote]:
        return self._inner if self.is_blockquote() else None

    def __repr__(self) -> str:
        return f'MessageEntity({self._inner!r})'


class MessageExtendedMedia(TLObject):
    """
    Boxed TL type ``MessageExtendedMedia`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAD628CC8: types.MessageExtendedMediaPreview,
        0xEE479C64: types.MessageExtendedMedia,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageExtendedMedia':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_preview(self) -> bool:
        return isinstance(self._inner, types.MessageExtendedMediaPreview)

    def as_preview(self) -> Optional[types.MessageExtendedMediaPreview]:
        return self._inner if self.is_preview() else None

    def is_message_extended_media(self) -> bool:
        return isinstance(self._inner, types.MessageExtendedMedia)

    def as_message_extended_media(self) -> Optional[types.MessageExtendedMedia]:
        return self._inner if self.is_message_extended_media() else None

    def __repr__(self) -> str:
        return f'MessageExtendedMedia({self._inner!r})'


class MessageFwdHeader(TLObject):
    """
    Boxed TL type ``MessageFwdHeader`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4E4DF4BB: types.MessageFwdHeader,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageFwdHeader':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_fwd_header(self) -> bool:
        return isinstance(self._inner, types.MessageFwdHeader)

    def as_message_fwd_header(self) -> Optional[types.MessageFwdHeader]:
        return self._inner if self.is_message_fwd_header() else None

    def __repr__(self) -> str:
        return f'MessageFwdHeader({self._inner!r})'


class MessageMedia(TLObject):
    """
    Boxed TL type ``MessageMedia`` — union of 19 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3DED6320: types.MessageMediaEmpty,
        0x695150D7: types.MessageMediaPhoto,
        0x56E0D474: types.MessageMediaGeo,
        0x70322949: types.MessageMediaContact,
        0x9F84F49E: types.MessageMediaUnsupported,
        0x52D8CCD9: types.MessageMediaDocument,
        0xDDF10C3B: types.MessageMediaWebPage,
        0x2EC0533F: types.MessageMediaVenue,
        0xFDB19008: types.MessageMediaGame,
        0xF6A548D3: types.MessageMediaInvoice,
        0xB940C666: types.MessageMediaGeoLive,
        0x4BD6E798: types.MessageMediaPoll,
        0x08CBEC07: types.MessageMediaDice,
        0x68CB6283: types.MessageMediaStory,
        0xAA073BEB: types.MessageMediaGiveaway,
        0xCEAA3EA1: types.MessageMediaGiveawayResults,
        0xA8852491: types.MessageMediaPaidMedia,
        0x8A53B014: types.MessageMediaToDo,
        0xCA5CAB89: types.MessageMediaVideoStream,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageMedia':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.MessageMediaEmpty)

    def as_empty(self) -> Optional[types.MessageMediaEmpty]:
        return self._inner if self.is_empty() else None

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.MessageMediaPhoto)

    def as_photo(self) -> Optional[types.MessageMediaPhoto]:
        return self._inner if self.is_photo() else None

    def is_geo(self) -> bool:
        return isinstance(self._inner, types.MessageMediaGeo)

    def as_geo(self) -> Optional[types.MessageMediaGeo]:
        return self._inner if self.is_geo() else None

    def is_contact(self) -> bool:
        return isinstance(self._inner, types.MessageMediaContact)

    def as_contact(self) -> Optional[types.MessageMediaContact]:
        return self._inner if self.is_contact() else None

    def is_unsupported(self) -> bool:
        return isinstance(self._inner, types.MessageMediaUnsupported)

    def as_unsupported(self) -> Optional[types.MessageMediaUnsupported]:
        return self._inner if self.is_unsupported() else None

    def is_document(self) -> bool:
        return isinstance(self._inner, types.MessageMediaDocument)

    def as_document(self) -> Optional[types.MessageMediaDocument]:
        return self._inner if self.is_document() else None

    def is_web_page(self) -> bool:
        return isinstance(self._inner, types.MessageMediaWebPage)

    def as_web_page(self) -> Optional[types.MessageMediaWebPage]:
        return self._inner if self.is_web_page() else None

    def is_venue(self) -> bool:
        return isinstance(self._inner, types.MessageMediaVenue)

    def as_venue(self) -> Optional[types.MessageMediaVenue]:
        return self._inner if self.is_venue() else None

    def is_game(self) -> bool:
        return isinstance(self._inner, types.MessageMediaGame)

    def as_game(self) -> Optional[types.MessageMediaGame]:
        return self._inner if self.is_game() else None

    def is_invoice(self) -> bool:
        return isinstance(self._inner, types.MessageMediaInvoice)

    def as_invoice(self) -> Optional[types.MessageMediaInvoice]:
        return self._inner if self.is_invoice() else None

    def is_geo_live(self) -> bool:
        return isinstance(self._inner, types.MessageMediaGeoLive)

    def as_geo_live(self) -> Optional[types.MessageMediaGeoLive]:
        return self._inner if self.is_geo_live() else None

    def is_poll(self) -> bool:
        return isinstance(self._inner, types.MessageMediaPoll)

    def as_poll(self) -> Optional[types.MessageMediaPoll]:
        return self._inner if self.is_poll() else None

    def is_dice(self) -> bool:
        return isinstance(self._inner, types.MessageMediaDice)

    def as_dice(self) -> Optional[types.MessageMediaDice]:
        return self._inner if self.is_dice() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.MessageMediaStory)

    def as_story(self) -> Optional[types.MessageMediaStory]:
        return self._inner if self.is_story() else None

    def is_giveaway(self) -> bool:
        return isinstance(self._inner, types.MessageMediaGiveaway)

    def as_giveaway(self) -> Optional[types.MessageMediaGiveaway]:
        return self._inner if self.is_giveaway() else None

    def is_giveaway_results(self) -> bool:
        return isinstance(self._inner, types.MessageMediaGiveawayResults)

    def as_giveaway_results(self) -> Optional[types.MessageMediaGiveawayResults]:
        return self._inner if self.is_giveaway_results() else None

    def is_paid_media(self) -> bool:
        return isinstance(self._inner, types.MessageMediaPaidMedia)

    def as_paid_media(self) -> Optional[types.MessageMediaPaidMedia]:
        return self._inner if self.is_paid_media() else None

    def is_to_do(self) -> bool:
        return isinstance(self._inner, types.MessageMediaToDo)

    def as_to_do(self) -> Optional[types.MessageMediaToDo]:
        return self._inner if self.is_to_do() else None

    def is_video_stream(self) -> bool:
        return isinstance(self._inner, types.MessageMediaVideoStream)

    def as_video_stream(self) -> Optional[types.MessageMediaVideoStream]:
        return self._inner if self.is_video_stream() else None

    def __repr__(self) -> str:
        return f'MessageMedia({self._inner!r})'


class MessagePeerReaction(TLObject):
    """
    Boxed TL type ``MessagePeerReaction`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8C79B63C: types.MessagePeerReaction,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessagePeerReaction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_peer_reaction(self) -> bool:
        return isinstance(self._inner, types.MessagePeerReaction)

    def as_message_peer_reaction(self) -> Optional[types.MessagePeerReaction]:
        return self._inner if self.is_message_peer_reaction() else None

    def __repr__(self) -> str:
        return f'MessagePeerReaction({self._inner!r})'


class MessagePeerVote(TLObject):
    """
    Boxed TL type ``MessagePeerVote`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB6CC2D5C: types.MessagePeerVote,
        0x74CDA504: types.MessagePeerVoteInputOption,
        0x4628F6E6: types.MessagePeerVoteMultiple,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessagePeerVote':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_peer_vote(self) -> bool:
        return isinstance(self._inner, types.MessagePeerVote)

    def as_message_peer_vote(self) -> Optional[types.MessagePeerVote]:
        return self._inner if self.is_message_peer_vote() else None

    def is_input_option(self) -> bool:
        return isinstance(self._inner, types.MessagePeerVoteInputOption)

    def as_input_option(self) -> Optional[types.MessagePeerVoteInputOption]:
        return self._inner if self.is_input_option() else None

    def is_multiple(self) -> bool:
        return isinstance(self._inner, types.MessagePeerVoteMultiple)

    def as_multiple(self) -> Optional[types.MessagePeerVoteMultiple]:
        return self._inner if self.is_multiple() else None

    def __repr__(self) -> str:
        return f'MessagePeerVote({self._inner!r})'


class MessageRange(TLObject):
    """
    Boxed TL type ``MessageRange`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0AE30253: types.MessageRange,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageRange':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_range(self) -> bool:
        return isinstance(self._inner, types.MessageRange)

    def as_message_range(self) -> Optional[types.MessageRange]:
        return self._inner if self.is_message_range() else None

    def __repr__(self) -> str:
        return f'MessageRange({self._inner!r})'


class MessageReactions(TLObject):
    """
    Boxed TL type ``MessageReactions`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0A339F0B: types.MessageReactions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageReactions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_reactions(self) -> bool:
        return isinstance(self._inner, types.MessageReactions)

    def as_message_reactions(self) -> Optional[types.MessageReactions]:
        return self._inner if self.is_message_reactions() else None

    def __repr__(self) -> str:
        return f'MessageReactions({self._inner!r})'


class MessageReactor(TLObject):
    """
    Boxed TL type ``MessageReactor`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4BA3A95A: types.MessageReactor,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageReactor':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_reactor(self) -> bool:
        return isinstance(self._inner, types.MessageReactor)

    def as_message_reactor(self) -> Optional[types.MessageReactor]:
        return self._inner if self.is_message_reactor() else None

    def __repr__(self) -> str:
        return f'MessageReactor({self._inner!r})'


class MessageReplies(TLObject):
    """
    Boxed TL type ``MessageReplies`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x83D60FC2: types.MessageReplies,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageReplies':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_replies(self) -> bool:
        return isinstance(self._inner, types.MessageReplies)

    def as_message_replies(self) -> Optional[types.MessageReplies]:
        return self._inner if self.is_message_replies() else None

    def __repr__(self) -> str:
        return f'MessageReplies({self._inner!r})'


class MessageReplyHeader(TLObject):
    """
    Boxed TL type ``MessageReplyHeader`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6917560B: types.MessageReplyHeader,
        0x0E5AF939: types.MessageReplyStoryHeader,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageReplyHeader':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_reply_header(self) -> bool:
        return isinstance(self._inner, types.MessageReplyHeader)

    def as_message_reply_header(self) -> Optional[types.MessageReplyHeader]:
        return self._inner if self.is_message_reply_header() else None

    def is_message_reply_story_header(self) -> bool:
        return isinstance(self._inner, types.MessageReplyStoryHeader)

    def as_message_reply_story_header(self) -> Optional[types.MessageReplyStoryHeader]:
        return self._inner if self.is_message_reply_story_header() else None

    def __repr__(self) -> str:
        return f'MessageReplyHeader({self._inner!r})'


class MessageReportOption(TLObject):
    """
    Boxed TL type ``MessageReportOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7903E3D9: types.MessageReportOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageReportOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_report_option(self) -> bool:
        return isinstance(self._inner, types.MessageReportOption)

    def as_message_report_option(self) -> Optional[types.MessageReportOption]:
        return self._inner if self.is_message_report_option() else None

    def __repr__(self) -> str:
        return f'MessageReportOption({self._inner!r})'


class MessageViews(TLObject):
    """
    Boxed TL type ``MessageViews`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x455B853D: types.MessageViews,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageViews':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_views(self) -> bool:
        return isinstance(self._inner, types.MessageViews)

    def as_message_views(self) -> Optional[types.MessageViews]:
        return self._inner if self.is_message_views() else None

    def __repr__(self) -> str:
        return f'MessageViews({self._inner!r})'


class MessagesFilter(TLObject):
    """
    Boxed TL type ``MessagesFilter`` — union of 17 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x57E2F66C: types.InputMessagesFilterEmpty,
        0x9609A51C: types.InputMessagesFilterPhotos,
        0x9FC00E65: types.InputMessagesFilterVideo,
        0x56E9F0E4: types.InputMessagesFilterPhotoVideo,
        0x9EDDF188: types.InputMessagesFilterDocument,
        0x7EF0DD87: types.InputMessagesFilterUrl,
        0xFFC86587: types.InputMessagesFilterGif,
        0x50F5C392: types.InputMessagesFilterVoice,
        0x3751B49E: types.InputMessagesFilterMusic,
        0x3A20ECB8: types.InputMessagesFilterChatPhotos,
        0x80C99768: types.InputMessagesFilterPhoneCalls,
        0x7A7C17A4: types.InputMessagesFilterRoundVoice,
        0xB549DA53: types.InputMessagesFilterRoundVideo,
        0xC1F8E69A: types.InputMessagesFilterMyMentions,
        0xE7026D0D: types.InputMessagesFilterGeo,
        0xE062DB83: types.InputMessagesFilterContacts,
        0x1BB00451: types.InputMessagesFilterPinned,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessagesFilter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_messages_filter_empty(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterEmpty)

    def as_input_messages_filter_empty(self) -> Optional[types.InputMessagesFilterEmpty]:
        return self._inner if self.is_input_messages_filter_empty() else None

    def is_input_messages_filter_photos(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterPhotos)

    def as_input_messages_filter_photos(self) -> Optional[types.InputMessagesFilterPhotos]:
        return self._inner if self.is_input_messages_filter_photos() else None

    def is_input_messages_filter_video(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterVideo)

    def as_input_messages_filter_video(self) -> Optional[types.InputMessagesFilterVideo]:
        return self._inner if self.is_input_messages_filter_video() else None

    def is_input_messages_filter_photo_video(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterPhotoVideo)

    def as_input_messages_filter_photo_video(self) -> Optional[types.InputMessagesFilterPhotoVideo]:
        return self._inner if self.is_input_messages_filter_photo_video() else None

    def is_input_messages_filter_document(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterDocument)

    def as_input_messages_filter_document(self) -> Optional[types.InputMessagesFilterDocument]:
        return self._inner if self.is_input_messages_filter_document() else None

    def is_input_messages_filter_url(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterUrl)

    def as_input_messages_filter_url(self) -> Optional[types.InputMessagesFilterUrl]:
        return self._inner if self.is_input_messages_filter_url() else None

    def is_input_messages_filter_gif(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterGif)

    def as_input_messages_filter_gif(self) -> Optional[types.InputMessagesFilterGif]:
        return self._inner if self.is_input_messages_filter_gif() else None

    def is_input_messages_filter_voice(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterVoice)

    def as_input_messages_filter_voice(self) -> Optional[types.InputMessagesFilterVoice]:
        return self._inner if self.is_input_messages_filter_voice() else None

    def is_input_messages_filter_music(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterMusic)

    def as_input_messages_filter_music(self) -> Optional[types.InputMessagesFilterMusic]:
        return self._inner if self.is_input_messages_filter_music() else None

    def is_input_messages_filter_chat_photos(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterChatPhotos)

    def as_input_messages_filter_chat_photos(self) -> Optional[types.InputMessagesFilterChatPhotos]:
        return self._inner if self.is_input_messages_filter_chat_photos() else None

    def is_input_messages_filter_phone_calls(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterPhoneCalls)

    def as_input_messages_filter_phone_calls(self) -> Optional[types.InputMessagesFilterPhoneCalls]:
        return self._inner if self.is_input_messages_filter_phone_calls() else None

    def is_input_messages_filter_round_voice(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterRoundVoice)

    def as_input_messages_filter_round_voice(self) -> Optional[types.InputMessagesFilterRoundVoice]:
        return self._inner if self.is_input_messages_filter_round_voice() else None

    def is_input_messages_filter_round_video(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterRoundVideo)

    def as_input_messages_filter_round_video(self) -> Optional[types.InputMessagesFilterRoundVideo]:
        return self._inner if self.is_input_messages_filter_round_video() else None

    def is_input_messages_filter_my_mentions(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterMyMentions)

    def as_input_messages_filter_my_mentions(self) -> Optional[types.InputMessagesFilterMyMentions]:
        return self._inner if self.is_input_messages_filter_my_mentions() else None

    def is_input_messages_filter_geo(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterGeo)

    def as_input_messages_filter_geo(self) -> Optional[types.InputMessagesFilterGeo]:
        return self._inner if self.is_input_messages_filter_geo() else None

    def is_input_messages_filter_contacts(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterContacts)

    def as_input_messages_filter_contacts(self) -> Optional[types.InputMessagesFilterContacts]:
        return self._inner if self.is_input_messages_filter_contacts() else None

    def is_input_messages_filter_pinned(self) -> bool:
        return isinstance(self._inner, types.InputMessagesFilterPinned)

    def as_input_messages_filter_pinned(self) -> Optional[types.InputMessagesFilterPinned]:
        return self._inner if self.is_input_messages_filter_pinned() else None

    def __repr__(self) -> str:
        return f'MessagesFilter({self._inner!r})'


class MissingInvitee(TLObject):
    """
    Boxed TL type ``MissingInvitee`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x628C9224: types.MissingInvitee,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MissingInvitee':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_missing_invitee(self) -> bool:
        return isinstance(self._inner, types.MissingInvitee)

    def as_missing_invitee(self) -> Optional[types.MissingInvitee]:
        return self._inner if self.is_missing_invitee() else None

    def __repr__(self) -> str:
        return f'MissingInvitee({self._inner!r})'


class MyBoost(TLObject):
    """
    Boxed TL type ``MyBoost`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC448415C: types.MyBoost,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MyBoost':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_my_boost(self) -> bool:
        return isinstance(self._inner, types.MyBoost)

    def as_my_boost(self) -> Optional[types.MyBoost]:
        return self._inner if self.is_my_boost() else None

    def __repr__(self) -> str:
        return f'MyBoost({self._inner!r})'


class NearestDc(TLObject):
    """
    Boxed TL type ``NearestDc`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8E1A1775: types.NearestDc,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'NearestDc':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_nearest_dc(self) -> bool:
        return isinstance(self._inner, types.NearestDc)

    def as_nearest_dc(self) -> Optional[types.NearestDc]:
        return self._inner if self.is_nearest_dc() else None

    def __repr__(self) -> str:
        return f'NearestDc({self._inner!r})'


class NotificationSound(TLObject):
    """
    Boxed TL type ``NotificationSound`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x97E8BEBE: types.NotificationSoundDefault,
        0x6F0C34DF: types.NotificationSoundNone,
        0x830B9AE4: types.NotificationSoundLocal,
        0xFF6C8049: types.NotificationSoundRingtone,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'NotificationSound':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_default(self) -> bool:
        return isinstance(self._inner, types.NotificationSoundDefault)

    def as_default(self) -> Optional[types.NotificationSoundDefault]:
        return self._inner if self.is_default() else None

    def is_none(self) -> bool:
        return isinstance(self._inner, types.NotificationSoundNone)

    def as_none(self) -> Optional[types.NotificationSoundNone]:
        return self._inner if self.is_none() else None

    def is_local(self) -> bool:
        return isinstance(self._inner, types.NotificationSoundLocal)

    def as_local(self) -> Optional[types.NotificationSoundLocal]:
        return self._inner if self.is_local() else None

    def is_ringtone(self) -> bool:
        return isinstance(self._inner, types.NotificationSoundRingtone)

    def as_ringtone(self) -> Optional[types.NotificationSoundRingtone]:
        return self._inner if self.is_ringtone() else None

    def __repr__(self) -> str:
        return f'NotificationSound({self._inner!r})'


class NotifyPeer(TLObject):
    """
    Boxed TL type ``NotifyPeer`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9FD40BD8: types.NotifyPeer,
        0xB4C83B4C: types.NotifyUsers,
        0xC007CEC3: types.NotifyChats,
        0xD612E8EF: types.NotifyBroadcasts,
        0x226E6308: types.NotifyForumTopic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'NotifyPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_notify_peer(self) -> bool:
        return isinstance(self._inner, types.NotifyPeer)

    def as_notify_peer(self) -> Optional[types.NotifyPeer]:
        return self._inner if self.is_notify_peer() else None

    def is_notify_users(self) -> bool:
        return isinstance(self._inner, types.NotifyUsers)

    def as_notify_users(self) -> Optional[types.NotifyUsers]:
        return self._inner if self.is_notify_users() else None

    def is_notify_chats(self) -> bool:
        return isinstance(self._inner, types.NotifyChats)

    def as_notify_chats(self) -> Optional[types.NotifyChats]:
        return self._inner if self.is_notify_chats() else None

    def is_notify_broadcasts(self) -> bool:
        return isinstance(self._inner, types.NotifyBroadcasts)

    def as_notify_broadcasts(self) -> Optional[types.NotifyBroadcasts]:
        return self._inner if self.is_notify_broadcasts() else None

    def is_notify_forum_topic(self) -> bool:
        return isinstance(self._inner, types.NotifyForumTopic)

    def as_notify_forum_topic(self) -> Optional[types.NotifyForumTopic]:
        return self._inner if self.is_notify_forum_topic() else None

    def __repr__(self) -> str:
        return f'NotifyPeer({self._inner!r})'


class OutboxReadDate(TLObject):
    """
    Boxed TL type ``OutboxReadDate`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3BB842AC: types.OutboxReadDate,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'OutboxReadDate':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_outbox_read_date(self) -> bool:
        return isinstance(self._inner, types.OutboxReadDate)

    def as_outbox_read_date(self) -> Optional[types.OutboxReadDate]:
        return self._inner if self.is_outbox_read_date() else None

    def __repr__(self) -> str:
        return f'OutboxReadDate({self._inner!r})'


class Page(TLObject):
    """
    Boxed TL type ``Page`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x98657F0D: types.Page,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Page':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_page(self) -> bool:
        return isinstance(self._inner, types.Page)

    def as_page(self) -> Optional[types.Page]:
        return self._inner if self.is_page() else None

    def __repr__(self) -> str:
        return f'Page({self._inner!r})'


class PageBlock(TLObject):
    """
    Boxed TL type ``PageBlock`` — union of 29 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x13567E8A: types.PageBlockUnsupported,
        0x70ABC3FD: types.PageBlockTitle,
        0x8FFA9A1F: types.PageBlockSubtitle,
        0xBAAFE5E0: types.PageBlockAuthorDate,
        0xBFD064EC: types.PageBlockHeader,
        0xF12BB6E1: types.PageBlockSubheader,
        0x467A0766: types.PageBlockParagraph,
        0xC070D93E: types.PageBlockPreformatted,
        0x48870999: types.PageBlockFooter,
        0xDB20B188: types.PageBlockDivider,
        0xCE0D37B0: types.PageBlockAnchor,
        0xE4E88011: types.PageBlockList,
        0x263D7C26: types.PageBlockBlockquote,
        0x4F4456D3: types.PageBlockPullquote,
        0x1759C560: types.PageBlockPhoto,
        0x7C8FE7B6: types.PageBlockVideo,
        0x39F23300: types.PageBlockCover,
        0xA8718DC5: types.PageBlockEmbed,
        0xF259A80B: types.PageBlockEmbedPost,
        0x65A0FA4D: types.PageBlockCollage,
        0x031F9590: types.PageBlockSlideshow,
        0xEF1751B5: types.PageBlockChannel,
        0x804361EA: types.PageBlockAudio,
        0x1E148390: types.PageBlockKicker,
        0xBF4DEA82: types.PageBlockTable,
        0x9A8AE1E1: types.PageBlockOrderedList,
        0x76768BED: types.PageBlockDetails,
        0x16115A96: types.PageBlockRelatedArticles,
        0xA44F3EF6: types.PageBlockMap,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageBlock':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unsupported(self) -> bool:
        return isinstance(self._inner, types.PageBlockUnsupported)

    def as_unsupported(self) -> Optional[types.PageBlockUnsupported]:
        return self._inner if self.is_unsupported() else None

    def is_title(self) -> bool:
        return isinstance(self._inner, types.PageBlockTitle)

    def as_title(self) -> Optional[types.PageBlockTitle]:
        return self._inner if self.is_title() else None

    def is_subtitle(self) -> bool:
        return isinstance(self._inner, types.PageBlockSubtitle)

    def as_subtitle(self) -> Optional[types.PageBlockSubtitle]:
        return self._inner if self.is_subtitle() else None

    def is_author_date(self) -> bool:
        return isinstance(self._inner, types.PageBlockAuthorDate)

    def as_author_date(self) -> Optional[types.PageBlockAuthorDate]:
        return self._inner if self.is_author_date() else None

    def is_header(self) -> bool:
        return isinstance(self._inner, types.PageBlockHeader)

    def as_header(self) -> Optional[types.PageBlockHeader]:
        return self._inner if self.is_header() else None

    def is_subheader(self) -> bool:
        return isinstance(self._inner, types.PageBlockSubheader)

    def as_subheader(self) -> Optional[types.PageBlockSubheader]:
        return self._inner if self.is_subheader() else None

    def is_paragraph(self) -> bool:
        return isinstance(self._inner, types.PageBlockParagraph)

    def as_paragraph(self) -> Optional[types.PageBlockParagraph]:
        return self._inner if self.is_paragraph() else None

    def is_preformatted(self) -> bool:
        return isinstance(self._inner, types.PageBlockPreformatted)

    def as_preformatted(self) -> Optional[types.PageBlockPreformatted]:
        return self._inner if self.is_preformatted() else None

    def is_footer(self) -> bool:
        return isinstance(self._inner, types.PageBlockFooter)

    def as_footer(self) -> Optional[types.PageBlockFooter]:
        return self._inner if self.is_footer() else None

    def is_divider(self) -> bool:
        return isinstance(self._inner, types.PageBlockDivider)

    def as_divider(self) -> Optional[types.PageBlockDivider]:
        return self._inner if self.is_divider() else None

    def is_anchor(self) -> bool:
        return isinstance(self._inner, types.PageBlockAnchor)

    def as_anchor(self) -> Optional[types.PageBlockAnchor]:
        return self._inner if self.is_anchor() else None

    def is_list(self) -> bool:
        return isinstance(self._inner, types.PageBlockList)

    def as_list(self) -> Optional[types.PageBlockList]:
        return self._inner if self.is_list() else None

    def is_blockquote(self) -> bool:
        return isinstance(self._inner, types.PageBlockBlockquote)

    def as_blockquote(self) -> Optional[types.PageBlockBlockquote]:
        return self._inner if self.is_blockquote() else None

    def is_pullquote(self) -> bool:
        return isinstance(self._inner, types.PageBlockPullquote)

    def as_pullquote(self) -> Optional[types.PageBlockPullquote]:
        return self._inner if self.is_pullquote() else None

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.PageBlockPhoto)

    def as_photo(self) -> Optional[types.PageBlockPhoto]:
        return self._inner if self.is_photo() else None

    def is_video(self) -> bool:
        return isinstance(self._inner, types.PageBlockVideo)

    def as_video(self) -> Optional[types.PageBlockVideo]:
        return self._inner if self.is_video() else None

    def is_cover(self) -> bool:
        return isinstance(self._inner, types.PageBlockCover)

    def as_cover(self) -> Optional[types.PageBlockCover]:
        return self._inner if self.is_cover() else None

    def is_embed(self) -> bool:
        return isinstance(self._inner, types.PageBlockEmbed)

    def as_embed(self) -> Optional[types.PageBlockEmbed]:
        return self._inner if self.is_embed() else None

    def is_embed_post(self) -> bool:
        return isinstance(self._inner, types.PageBlockEmbedPost)

    def as_embed_post(self) -> Optional[types.PageBlockEmbedPost]:
        return self._inner if self.is_embed_post() else None

    def is_collage(self) -> bool:
        return isinstance(self._inner, types.PageBlockCollage)

    def as_collage(self) -> Optional[types.PageBlockCollage]:
        return self._inner if self.is_collage() else None

    def is_slideshow(self) -> bool:
        return isinstance(self._inner, types.PageBlockSlideshow)

    def as_slideshow(self) -> Optional[types.PageBlockSlideshow]:
        return self._inner if self.is_slideshow() else None

    def is_channel(self) -> bool:
        return isinstance(self._inner, types.PageBlockChannel)

    def as_channel(self) -> Optional[types.PageBlockChannel]:
        return self._inner if self.is_channel() else None

    def is_audio(self) -> bool:
        return isinstance(self._inner, types.PageBlockAudio)

    def as_audio(self) -> Optional[types.PageBlockAudio]:
        return self._inner if self.is_audio() else None

    def is_kicker(self) -> bool:
        return isinstance(self._inner, types.PageBlockKicker)

    def as_kicker(self) -> Optional[types.PageBlockKicker]:
        return self._inner if self.is_kicker() else None

    def is_table(self) -> bool:
        return isinstance(self._inner, types.PageBlockTable)

    def as_table(self) -> Optional[types.PageBlockTable]:
        return self._inner if self.is_table() else None

    def is_ordered_list(self) -> bool:
        return isinstance(self._inner, types.PageBlockOrderedList)

    def as_ordered_list(self) -> Optional[types.PageBlockOrderedList]:
        return self._inner if self.is_ordered_list() else None

    def is_details(self) -> bool:
        return isinstance(self._inner, types.PageBlockDetails)

    def as_details(self) -> Optional[types.PageBlockDetails]:
        return self._inner if self.is_details() else None

    def is_related_articles(self) -> bool:
        return isinstance(self._inner, types.PageBlockRelatedArticles)

    def as_related_articles(self) -> Optional[types.PageBlockRelatedArticles]:
        return self._inner if self.is_related_articles() else None

    def is_map(self) -> bool:
        return isinstance(self._inner, types.PageBlockMap)

    def as_map(self) -> Optional[types.PageBlockMap]:
        return self._inner if self.is_map() else None

    def __repr__(self) -> str:
        return f'PageBlock({self._inner!r})'


class PageCaption(TLObject):
    """
    Boxed TL type ``PageCaption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6F747657: types.PageCaption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageCaption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_page_caption(self) -> bool:
        return isinstance(self._inner, types.PageCaption)

    def as_page_caption(self) -> Optional[types.PageCaption]:
        return self._inner if self.is_page_caption() else None

    def __repr__(self) -> str:
        return f'PageCaption({self._inner!r})'


class PageListItem(TLObject):
    """
    Boxed TL type ``PageListItem`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB92FB6CD: types.PageListItemText,
        0x25E073FC: types.PageListItemBlocks,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageListItem':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_text(self) -> bool:
        return isinstance(self._inner, types.PageListItemText)

    def as_text(self) -> Optional[types.PageListItemText]:
        return self._inner if self.is_text() else None

    def is_blocks(self) -> bool:
        return isinstance(self._inner, types.PageListItemBlocks)

    def as_blocks(self) -> Optional[types.PageListItemBlocks]:
        return self._inner if self.is_blocks() else None

    def __repr__(self) -> str:
        return f'PageListItem({self._inner!r})'


class PageListOrderedItem(TLObject):
    """
    Boxed TL type ``PageListOrderedItem`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5E068047: types.PageListOrderedItemText,
        0x98DD8936: types.PageListOrderedItemBlocks,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageListOrderedItem':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_text(self) -> bool:
        return isinstance(self._inner, types.PageListOrderedItemText)

    def as_text(self) -> Optional[types.PageListOrderedItemText]:
        return self._inner if self.is_text() else None

    def is_blocks(self) -> bool:
        return isinstance(self._inner, types.PageListOrderedItemBlocks)

    def as_blocks(self) -> Optional[types.PageListOrderedItemBlocks]:
        return self._inner if self.is_blocks() else None

    def __repr__(self) -> str:
        return f'PageListOrderedItem({self._inner!r})'


class PageRelatedArticle(TLObject):
    """
    Boxed TL type ``PageRelatedArticle`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB390DC08: types.PageRelatedArticle,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageRelatedArticle':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_page_related_article(self) -> bool:
        return isinstance(self._inner, types.PageRelatedArticle)

    def as_page_related_article(self) -> Optional[types.PageRelatedArticle]:
        return self._inner if self.is_page_related_article() else None

    def __repr__(self) -> str:
        return f'PageRelatedArticle({self._inner!r})'


class PageTableCell(TLObject):
    """
    Boxed TL type ``PageTableCell`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x34566B6A: types.PageTableCell,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageTableCell':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_page_table_cell(self) -> bool:
        return isinstance(self._inner, types.PageTableCell)

    def as_page_table_cell(self) -> Optional[types.PageTableCell]:
        return self._inner if self.is_page_table_cell() else None

    def __repr__(self) -> str:
        return f'PageTableCell({self._inner!r})'


class PageTableRow(TLObject):
    """
    Boxed TL type ``PageTableRow`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE0C0C5E5: types.PageTableRow,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PageTableRow':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_page_table_row(self) -> bool:
        return isinstance(self._inner, types.PageTableRow)

    def as_page_table_row(self) -> Optional[types.PageTableRow]:
        return self._inner if self.is_page_table_row() else None

    def __repr__(self) -> str:
        return f'PageTableRow({self._inner!r})'


class PaidReactionPrivacy(TLObject):
    """
    Boxed TL type ``PaidReactionPrivacy`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x206AD49E: types.PaidReactionPrivacyDefault,
        0x1F0C1AD9: types.PaidReactionPrivacyAnonymous,
        0xDC6CFCF0: types.PaidReactionPrivacyPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaidReactionPrivacy':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_default(self) -> bool:
        return isinstance(self._inner, types.PaidReactionPrivacyDefault)

    def as_default(self) -> Optional[types.PaidReactionPrivacyDefault]:
        return self._inner if self.is_default() else None

    def is_anonymous(self) -> bool:
        return isinstance(self._inner, types.PaidReactionPrivacyAnonymous)

    def as_anonymous(self) -> Optional[types.PaidReactionPrivacyAnonymous]:
        return self._inner if self.is_anonymous() else None

    def is_peer(self) -> bool:
        return isinstance(self._inner, types.PaidReactionPrivacyPeer)

    def as_peer(self) -> Optional[types.PaidReactionPrivacyPeer]:
        return self._inner if self.is_peer() else None

    def __repr__(self) -> str:
        return f'PaidReactionPrivacy({self._inner!r})'


class Passkey(TLObject):
    """
    Boxed TL type ``Passkey`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x98613EBF: types.Passkey,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Passkey':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_passkey(self) -> bool:
        return isinstance(self._inner, types.Passkey)

    def as_passkey(self) -> Optional[types.Passkey]:
        return self._inner if self.is_passkey() else None

    def __repr__(self) -> str:
        return f'Passkey({self._inner!r})'


class PasswordKdfAlgo(TLObject):
    """
    Boxed TL type ``PasswordKdfAlgo`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD45AB096: types.PasswordKdfAlgoUnknown,
        0x3A912D4A: types.PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PasswordKdfAlgo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unknown(self) -> bool:
        return isinstance(self._inner, types.PasswordKdfAlgoUnknown)

    def as_unknown(self) -> Optional[types.PasswordKdfAlgoUnknown]:
        return self._inner if self.is_unknown() else None

    def is_sha256_sha256_pbkdf2_hmacsha512iter100000_sha256_mod_pow(self) -> bool:
        return isinstance(self._inner, types.PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow)

    def as_sha256_sha256_pbkdf2_hmacsha512iter100000_sha256_mod_pow(self) -> Optional[types.PasswordKdfAlgoSha256Sha256Pbkdf2Hmacsha512iter100000Sha256ModPow]:
        return self._inner if self.is_sha256_sha256_pbkdf2_hmacsha512iter100000_sha256_mod_pow() else None

    def __repr__(self) -> str:
        return f'PasswordKdfAlgo({self._inner!r})'


class PaymentCharge(TLObject):
    """
    Boxed TL type ``PaymentCharge`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEA02C27E: types.PaymentCharge,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentCharge':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_payment_charge(self) -> bool:
        return isinstance(self._inner, types.PaymentCharge)

    def as_payment_charge(self) -> Optional[types.PaymentCharge]:
        return self._inner if self.is_payment_charge() else None

    def __repr__(self) -> str:
        return f'PaymentCharge({self._inner!r})'


class PaymentFormMethod(TLObject):
    """
    Boxed TL type ``PaymentFormMethod`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x88F8F21B: types.PaymentFormMethod,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentFormMethod':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_payment_form_method(self) -> bool:
        return isinstance(self._inner, types.PaymentFormMethod)

    def as_payment_form_method(self) -> Optional[types.PaymentFormMethod]:
        return self._inner if self.is_payment_form_method() else None

    def __repr__(self) -> str:
        return f'PaymentFormMethod({self._inner!r})'


class PaymentRequestedInfo(TLObject):
    """
    Boxed TL type ``PaymentRequestedInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x909C3F94: types.PaymentRequestedInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentRequestedInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_payment_requested_info(self) -> bool:
        return isinstance(self._inner, types.PaymentRequestedInfo)

    def as_payment_requested_info(self) -> Optional[types.PaymentRequestedInfo]:
        return self._inner if self.is_payment_requested_info() else None

    def __repr__(self) -> str:
        return f'PaymentRequestedInfo({self._inner!r})'


class PaymentSavedCredentials(TLObject):
    """
    Boxed TL type ``PaymentSavedCredentials`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCDC27A1F: types.PaymentSavedCredentialsCard,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentSavedCredentials':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_card(self) -> bool:
        return isinstance(self._inner, types.PaymentSavedCredentialsCard)

    def as_card(self) -> Optional[types.PaymentSavedCredentialsCard]:
        return self._inner if self.is_card() else None

    def __repr__(self) -> str:
        return f'PaymentSavedCredentials({self._inner!r})'


class Peer(TLObject):
    """
    Boxed TL type ``Peer`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x59511722: types.PeerUser,
        0x36C6019A: types.PeerChat,
        0xA2A5371E: types.PeerChannel,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Peer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_user(self) -> bool:
        return isinstance(self._inner, types.PeerUser)

    def as_user(self) -> Optional[types.PeerUser]:
        return self._inner if self.is_user() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.PeerChat)

    def as_chat(self) -> Optional[types.PeerChat]:
        return self._inner if self.is_chat() else None

    def is_channel(self) -> bool:
        return isinstance(self._inner, types.PeerChannel)

    def as_channel(self) -> Optional[types.PeerChannel]:
        return self._inner if self.is_channel() else None

    def __repr__(self) -> str:
        return f'Peer({self._inner!r})'


class PeerBlocked(TLObject):
    """
    Boxed TL type ``PeerBlocked`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE8FD8014: types.PeerBlocked,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerBlocked':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_blocked(self) -> bool:
        return isinstance(self._inner, types.PeerBlocked)

    def as_peer_blocked(self) -> Optional[types.PeerBlocked]:
        return self._inner if self.is_peer_blocked() else None

    def __repr__(self) -> str:
        return f'PeerBlocked({self._inner!r})'


class PeerColor(TLObject):
    """
    Boxed TL type ``PeerColor`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB54B5ACF: types.PeerColor,
        0xB9C0639A: types.PeerColorCollectible,
        0xB8EA86A9: types.InputPeerColorCollectible,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerColor':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_color(self) -> bool:
        return isinstance(self._inner, types.PeerColor)

    def as_peer_color(self) -> Optional[types.PeerColor]:
        return self._inner if self.is_peer_color() else None

    def is_collectible(self) -> bool:
        return isinstance(self._inner, types.PeerColorCollectible)

    def as_collectible(self) -> Optional[types.PeerColorCollectible]:
        return self._inner if self.is_collectible() else None

    def is_input_peer_color_collectible(self) -> bool:
        return isinstance(self._inner, types.InputPeerColorCollectible)

    def as_input_peer_color_collectible(self) -> Optional[types.InputPeerColorCollectible]:
        return self._inner if self.is_input_peer_color_collectible() else None

    def __repr__(self) -> str:
        return f'PeerColor({self._inner!r})'


class PeerLocated(TLObject):
    """
    Boxed TL type ``PeerLocated`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCA461B5D: types.PeerLocated,
        0xF8EC284B: types.PeerSelfLocated,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerLocated':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_located(self) -> bool:
        return isinstance(self._inner, types.PeerLocated)

    def as_peer_located(self) -> Optional[types.PeerLocated]:
        return self._inner if self.is_peer_located() else None

    def is_peer_self_located(self) -> bool:
        return isinstance(self._inner, types.PeerSelfLocated)

    def as_peer_self_located(self) -> Optional[types.PeerSelfLocated]:
        return self._inner if self.is_peer_self_located() else None

    def __repr__(self) -> str:
        return f'PeerLocated({self._inner!r})'


class PeerNotifySettings(TLObject):
    """
    Boxed TL type ``PeerNotifySettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x99622C0C: types.PeerNotifySettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerNotifySettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_notify_settings(self) -> bool:
        return isinstance(self._inner, types.PeerNotifySettings)

    def as_peer_notify_settings(self) -> Optional[types.PeerNotifySettings]:
        return self._inner if self.is_peer_notify_settings() else None

    def __repr__(self) -> str:
        return f'PeerNotifySettings({self._inner!r})'


class PeerSettings(TLObject):
    """
    Boxed TL type ``PeerSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF47741F7: types.PeerSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_settings(self) -> bool:
        return isinstance(self._inner, types.PeerSettings)

    def as_peer_settings(self) -> Optional[types.PeerSettings]:
        return self._inner if self.is_peer_settings() else None

    def __repr__(self) -> str:
        return f'PeerSettings({self._inner!r})'


class PeerStories(TLObject):
    """
    Boxed TL type ``PeerStories`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9A35E999: types.PeerStories,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerStories':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_stories(self) -> bool:
        return isinstance(self._inner, types.PeerStories)

    def as_peer_stories(self) -> Optional[types.PeerStories]:
        return self._inner if self.is_peer_stories() else None

    def __repr__(self) -> str:
        return f'PeerStories({self._inner!r})'


class PendingSuggestion(TLObject):
    """
    Boxed TL type ``PendingSuggestion`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE7E82E12: types.PendingSuggestion,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PendingSuggestion':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_pending_suggestion(self) -> bool:
        return isinstance(self._inner, types.PendingSuggestion)

    def as_pending_suggestion(self) -> Optional[types.PendingSuggestion]:
        return self._inner if self.is_pending_suggestion() else None

    def __repr__(self) -> str:
        return f'PendingSuggestion({self._inner!r})'


class PhoneCall(TLObject):
    """
    Boxed TL type ``PhoneCall`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5366C915: types.PhoneCallEmpty,
        0xC5226F17: types.PhoneCallWaiting,
        0x14B0ED0C: types.PhoneCallRequested,
        0x3660C311: types.PhoneCallAccepted,
        0x30535AF5: types.PhoneCall,
        0x50CA4DE1: types.PhoneCallDiscarded,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PhoneCall':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.PhoneCallEmpty)

    def as_empty(self) -> Optional[types.PhoneCallEmpty]:
        return self._inner if self.is_empty() else None

    def is_waiting(self) -> bool:
        return isinstance(self._inner, types.PhoneCallWaiting)

    def as_waiting(self) -> Optional[types.PhoneCallWaiting]:
        return self._inner if self.is_waiting() else None

    def is_requested(self) -> bool:
        return isinstance(self._inner, types.PhoneCallRequested)

    def as_requested(self) -> Optional[types.PhoneCallRequested]:
        return self._inner if self.is_requested() else None

    def is_accepted(self) -> bool:
        return isinstance(self._inner, types.PhoneCallAccepted)

    def as_accepted(self) -> Optional[types.PhoneCallAccepted]:
        return self._inner if self.is_accepted() else None

    def is_phone_call(self) -> bool:
        return isinstance(self._inner, types.PhoneCall)

    def as_phone_call(self) -> Optional[types.PhoneCall]:
        return self._inner if self.is_phone_call() else None

    def is_discarded(self) -> bool:
        return isinstance(self._inner, types.PhoneCallDiscarded)

    def as_discarded(self) -> Optional[types.PhoneCallDiscarded]:
        return self._inner if self.is_discarded() else None

    def __repr__(self) -> str:
        return f'PhoneCall({self._inner!r})'


class PhoneCallDiscardReason(TLObject):
    """
    Boxed TL type ``PhoneCallDiscardReason`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x85E42301: types.PhoneCallDiscardReasonMissed,
        0xE095C1A0: types.PhoneCallDiscardReasonDisconnect,
        0x57ADC690: types.PhoneCallDiscardReasonHangup,
        0xFAF7E8C9: types.PhoneCallDiscardReasonBusy,
        0x9FBBF1F7: types.PhoneCallDiscardReasonMigrateConferenceCall,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PhoneCallDiscardReason':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_missed(self) -> bool:
        return isinstance(self._inner, types.PhoneCallDiscardReasonMissed)

    def as_missed(self) -> Optional[types.PhoneCallDiscardReasonMissed]:
        return self._inner if self.is_missed() else None

    def is_disconnect(self) -> bool:
        return isinstance(self._inner, types.PhoneCallDiscardReasonDisconnect)

    def as_disconnect(self) -> Optional[types.PhoneCallDiscardReasonDisconnect]:
        return self._inner if self.is_disconnect() else None

    def is_hangup(self) -> bool:
        return isinstance(self._inner, types.PhoneCallDiscardReasonHangup)

    def as_hangup(self) -> Optional[types.PhoneCallDiscardReasonHangup]:
        return self._inner if self.is_hangup() else None

    def is_busy(self) -> bool:
        return isinstance(self._inner, types.PhoneCallDiscardReasonBusy)

    def as_busy(self) -> Optional[types.PhoneCallDiscardReasonBusy]:
        return self._inner if self.is_busy() else None

    def is_migrate_conference_call(self) -> bool:
        return isinstance(self._inner, types.PhoneCallDiscardReasonMigrateConferenceCall)

    def as_migrate_conference_call(self) -> Optional[types.PhoneCallDiscardReasonMigrateConferenceCall]:
        return self._inner if self.is_migrate_conference_call() else None

    def __repr__(self) -> str:
        return f'PhoneCallDiscardReason({self._inner!r})'


class PhoneCallProtocol(TLObject):
    """
    Boxed TL type ``PhoneCallProtocol`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFC878FC8: types.PhoneCallProtocol,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PhoneCallProtocol':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_phone_call_protocol(self) -> bool:
        return isinstance(self._inner, types.PhoneCallProtocol)

    def as_phone_call_protocol(self) -> Optional[types.PhoneCallProtocol]:
        return self._inner if self.is_phone_call_protocol() else None

    def __repr__(self) -> str:
        return f'PhoneCallProtocol({self._inner!r})'


class PhoneConnection(TLObject):
    """
    Boxed TL type ``PhoneConnection`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9CC123C7: types.PhoneConnection,
        0x635FE375: types.PhoneConnectionWebrtc,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PhoneConnection':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_phone_connection(self) -> bool:
        return isinstance(self._inner, types.PhoneConnection)

    def as_phone_connection(self) -> Optional[types.PhoneConnection]:
        return self._inner if self.is_phone_connection() else None

    def is_webrtc(self) -> bool:
        return isinstance(self._inner, types.PhoneConnectionWebrtc)

    def as_webrtc(self) -> Optional[types.PhoneConnectionWebrtc]:
        return self._inner if self.is_webrtc() else None

    def __repr__(self) -> str:
        return f'PhoneConnection({self._inner!r})'


class Photo(TLObject):
    """
    Boxed TL type ``Photo`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2331B22D: types.PhotoEmpty,
        0xFB197A65: types.Photo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Photo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.PhotoEmpty)

    def as_empty(self) -> Optional[types.PhotoEmpty]:
        return self._inner if self.is_empty() else None

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.Photo)

    def as_photo(self) -> Optional[types.Photo]:
        return self._inner if self.is_photo() else None

    def __repr__(self) -> str:
        return f'Photo({self._inner!r})'


class PhotoSize(TLObject):
    """
    Boxed TL type ``PhotoSize`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0E17E23C: types.PhotoSizeEmpty,
        0x75C78E60: types.PhotoSize,
        0x021E1AD6: types.PhotoCachedSize,
        0xE0B0BC2E: types.PhotoStrippedSize,
        0xFA3EFB95: types.PhotoSizeProgressive,
        0xD8214D41: types.PhotoPathSize,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PhotoSize':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.PhotoSizeEmpty)

    def as_empty(self) -> Optional[types.PhotoSizeEmpty]:
        return self._inner if self.is_empty() else None

    def is_photo_size(self) -> bool:
        return isinstance(self._inner, types.PhotoSize)

    def as_photo_size(self) -> Optional[types.PhotoSize]:
        return self._inner if self.is_photo_size() else None

    def is_photo_cached_size(self) -> bool:
        return isinstance(self._inner, types.PhotoCachedSize)

    def as_photo_cached_size(self) -> Optional[types.PhotoCachedSize]:
        return self._inner if self.is_photo_cached_size() else None

    def is_photo_stripped_size(self) -> bool:
        return isinstance(self._inner, types.PhotoStrippedSize)

    def as_photo_stripped_size(self) -> Optional[types.PhotoStrippedSize]:
        return self._inner if self.is_photo_stripped_size() else None

    def is_progressive(self) -> bool:
        return isinstance(self._inner, types.PhotoSizeProgressive)

    def as_progressive(self) -> Optional[types.PhotoSizeProgressive]:
        return self._inner if self.is_progressive() else None

    def is_photo_path_size(self) -> bool:
        return isinstance(self._inner, types.PhotoPathSize)

    def as_photo_path_size(self) -> Optional[types.PhotoPathSize]:
        return self._inner if self.is_photo_path_size() else None

    def __repr__(self) -> str:
        return f'PhotoSize({self._inner!r})'


class Poll(TLObject):
    """
    Boxed TL type ``Poll`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x58747131: types.Poll,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Poll':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_poll(self) -> bool:
        return isinstance(self._inner, types.Poll)

    def as_poll(self) -> Optional[types.Poll]:
        return self._inner if self.is_poll() else None

    def __repr__(self) -> str:
        return f'Poll({self._inner!r})'


class PollAnswer(TLObject):
    """
    Boxed TL type ``PollAnswer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFF16E2CA: types.PollAnswer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PollAnswer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_poll_answer(self) -> bool:
        return isinstance(self._inner, types.PollAnswer)

    def as_poll_answer(self) -> Optional[types.PollAnswer]:
        return self._inner if self.is_poll_answer() else None

    def __repr__(self) -> str:
        return f'PollAnswer({self._inner!r})'


class PollAnswerVoters(TLObject):
    """
    Boxed TL type ``PollAnswerVoters`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3B6DDAD2: types.PollAnswerVoters,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PollAnswerVoters':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_poll_answer_voters(self) -> bool:
        return isinstance(self._inner, types.PollAnswerVoters)

    def as_poll_answer_voters(self) -> Optional[types.PollAnswerVoters]:
        return self._inner if self.is_poll_answer_voters() else None

    def __repr__(self) -> str:
        return f'PollAnswerVoters({self._inner!r})'


class PollResults(TLObject):
    """
    Boxed TL type ``PollResults`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7ADF2420: types.PollResults,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PollResults':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_poll_results(self) -> bool:
        return isinstance(self._inner, types.PollResults)

    def as_poll_results(self) -> Optional[types.PollResults]:
        return self._inner if self.is_poll_results() else None

    def __repr__(self) -> str:
        return f'PollResults({self._inner!r})'


class PopularContact(TLObject):
    """
    Boxed TL type ``PopularContact`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5CE14175: types.PopularContact,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PopularContact':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_popular_contact(self) -> bool:
        return isinstance(self._inner, types.PopularContact)

    def as_popular_contact(self) -> Optional[types.PopularContact]:
        return self._inner if self.is_popular_contact() else None

    def __repr__(self) -> str:
        return f'PopularContact({self._inner!r})'


class PostAddress(TLObject):
    """
    Boxed TL type ``PostAddress`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1E8CAAEB: types.PostAddress,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PostAddress':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_post_address(self) -> bool:
        return isinstance(self._inner, types.PostAddress)

    def as_post_address(self) -> Optional[types.PostAddress]:
        return self._inner if self.is_post_address() else None

    def __repr__(self) -> str:
        return f'PostAddress({self._inner!r})'


class PostInteractionCounters(TLObject):
    """
    Boxed TL type ``PostInteractionCounters`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE7058E7F: types.PostInteractionCountersMessage,
        0x8A480E27: types.PostInteractionCountersStory,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PostInteractionCounters':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message(self) -> bool:
        return isinstance(self._inner, types.PostInteractionCountersMessage)

    def as_message(self) -> Optional[types.PostInteractionCountersMessage]:
        return self._inner if self.is_message() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.PostInteractionCountersStory)

    def as_story(self) -> Optional[types.PostInteractionCountersStory]:
        return self._inner if self.is_story() else None

    def __repr__(self) -> str:
        return f'PostInteractionCounters({self._inner!r})'


class PremiumGiftCodeOption(TLObject):
    """
    Boxed TL type ``PremiumGiftCodeOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x257E962B: types.PremiumGiftCodeOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PremiumGiftCodeOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_premium_gift_code_option(self) -> bool:
        return isinstance(self._inner, types.PremiumGiftCodeOption)

    def as_premium_gift_code_option(self) -> Optional[types.PremiumGiftCodeOption]:
        return self._inner if self.is_premium_gift_code_option() else None

    def __repr__(self) -> str:
        return f'PremiumGiftCodeOption({self._inner!r})'


class PremiumSubscriptionOption(TLObject):
    """
    Boxed TL type ``PremiumSubscriptionOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5F2D1DF2: types.PremiumSubscriptionOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PremiumSubscriptionOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_premium_subscription_option(self) -> bool:
        return isinstance(self._inner, types.PremiumSubscriptionOption)

    def as_premium_subscription_option(self) -> Optional[types.PremiumSubscriptionOption]:
        return self._inner if self.is_premium_subscription_option() else None

    def __repr__(self) -> str:
        return f'PremiumSubscriptionOption({self._inner!r})'


class PrepaidGiveaway(TLObject):
    """
    Boxed TL type ``PrepaidGiveaway`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB2539D54: types.PrepaidGiveaway,
        0x9A9D77E0: types.PrepaidStarsGiveaway,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PrepaidGiveaway':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_prepaid_giveaway(self) -> bool:
        return isinstance(self._inner, types.PrepaidGiveaway)

    def as_prepaid_giveaway(self) -> Optional[types.PrepaidGiveaway]:
        return self._inner if self.is_prepaid_giveaway() else None

    def is_prepaid_stars_giveaway(self) -> bool:
        return isinstance(self._inner, types.PrepaidStarsGiveaway)

    def as_prepaid_stars_giveaway(self) -> Optional[types.PrepaidStarsGiveaway]:
        return self._inner if self.is_prepaid_stars_giveaway() else None

    def __repr__(self) -> str:
        return f'PrepaidGiveaway({self._inner!r})'


class PrivacyKey(TLObject):
    """
    Boxed TL type ``PrivacyKey`` — union of 14 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBC2EAB30: types.PrivacyKeyStatusTimestamp,
        0x500E6DFA: types.PrivacyKeyChatInvite,
        0x3D662B7B: types.PrivacyKeyPhoneCall,
        0x39491CC8: types.PrivacyKeyPhoneP2P,
        0x69EC56A3: types.PrivacyKeyForwards,
        0x96151FED: types.PrivacyKeyProfilePhoto,
        0xD19AE46D: types.PrivacyKeyPhoneNumber,
        0x42FFD42B: types.PrivacyKeyAddedByPhone,
        0x0697F414: types.PrivacyKeyVoiceMessages,
        0xA486B761: types.PrivacyKeyAbout,
        0x2000A518: types.PrivacyKeyBirthday,
        0x2CA4FDF8: types.PrivacyKeyStarGiftsAutoSave,
        0x17D348D2: types.PrivacyKeyNoPaidMessages,
        0xFF7A571B: types.PrivacyKeySavedMusic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PrivacyKey':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_status_timestamp(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyStatusTimestamp)

    def as_status_timestamp(self) -> Optional[types.PrivacyKeyStatusTimestamp]:
        return self._inner if self.is_status_timestamp() else None

    def is_chat_invite(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyChatInvite)

    def as_chat_invite(self) -> Optional[types.PrivacyKeyChatInvite]:
        return self._inner if self.is_chat_invite() else None

    def is_phone_call(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyPhoneCall)

    def as_phone_call(self) -> Optional[types.PrivacyKeyPhoneCall]:
        return self._inner if self.is_phone_call() else None

    def is_phone_p2_p(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyPhoneP2P)

    def as_phone_p2_p(self) -> Optional[types.PrivacyKeyPhoneP2P]:
        return self._inner if self.is_phone_p2_p() else None

    def is_forwards(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyForwards)

    def as_forwards(self) -> Optional[types.PrivacyKeyForwards]:
        return self._inner if self.is_forwards() else None

    def is_profile_photo(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyProfilePhoto)

    def as_profile_photo(self) -> Optional[types.PrivacyKeyProfilePhoto]:
        return self._inner if self.is_profile_photo() else None

    def is_phone_number(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyPhoneNumber)

    def as_phone_number(self) -> Optional[types.PrivacyKeyPhoneNumber]:
        return self._inner if self.is_phone_number() else None

    def is_added_by_phone(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyAddedByPhone)

    def as_added_by_phone(self) -> Optional[types.PrivacyKeyAddedByPhone]:
        return self._inner if self.is_added_by_phone() else None

    def is_voice_messages(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyVoiceMessages)

    def as_voice_messages(self) -> Optional[types.PrivacyKeyVoiceMessages]:
        return self._inner if self.is_voice_messages() else None

    def is_about(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyAbout)

    def as_about(self) -> Optional[types.PrivacyKeyAbout]:
        return self._inner if self.is_about() else None

    def is_birthday(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyBirthday)

    def as_birthday(self) -> Optional[types.PrivacyKeyBirthday]:
        return self._inner if self.is_birthday() else None

    def is_star_gifts_auto_save(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyStarGiftsAutoSave)

    def as_star_gifts_auto_save(self) -> Optional[types.PrivacyKeyStarGiftsAutoSave]:
        return self._inner if self.is_star_gifts_auto_save() else None

    def is_no_paid_messages(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeyNoPaidMessages)

    def as_no_paid_messages(self) -> Optional[types.PrivacyKeyNoPaidMessages]:
        return self._inner if self.is_no_paid_messages() else None

    def is_saved_music(self) -> bool:
        return isinstance(self._inner, types.PrivacyKeySavedMusic)

    def as_saved_music(self) -> Optional[types.PrivacyKeySavedMusic]:
        return self._inner if self.is_saved_music() else None

    def __repr__(self) -> str:
        return f'PrivacyKey({self._inner!r})'


class PrivacyRule(TLObject):
    """
    Boxed TL type ``PrivacyRule`` — union of 12 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFFFE1BAC: types.PrivacyValueAllowContacts,
        0x65427B82: types.PrivacyValueAllowAll,
        0xB8905FB2: types.PrivacyValueAllowUsers,
        0xF888FA1A: types.PrivacyValueDisallowContacts,
        0x8B73E763: types.PrivacyValueDisallowAll,
        0xE4621141: types.PrivacyValueDisallowUsers,
        0x6B134E8E: types.PrivacyValueAllowChatParticipants,
        0x41C87565: types.PrivacyValueDisallowChatParticipants,
        0xF7E8D89B: types.PrivacyValueAllowCloseFriends,
        0xECE9814B: types.PrivacyValueAllowPremium,
        0x21461B5D: types.PrivacyValueAllowBots,
        0xF6A5F82F: types.PrivacyValueDisallowBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PrivacyRule':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_privacy_value_allow_contacts(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowContacts)

    def as_privacy_value_allow_contacts(self) -> Optional[types.PrivacyValueAllowContacts]:
        return self._inner if self.is_privacy_value_allow_contacts() else None

    def is_privacy_value_allow_all(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowAll)

    def as_privacy_value_allow_all(self) -> Optional[types.PrivacyValueAllowAll]:
        return self._inner if self.is_privacy_value_allow_all() else None

    def is_privacy_value_allow_users(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowUsers)

    def as_privacy_value_allow_users(self) -> Optional[types.PrivacyValueAllowUsers]:
        return self._inner if self.is_privacy_value_allow_users() else None

    def is_privacy_value_disallow_contacts(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueDisallowContacts)

    def as_privacy_value_disallow_contacts(self) -> Optional[types.PrivacyValueDisallowContacts]:
        return self._inner if self.is_privacy_value_disallow_contacts() else None

    def is_privacy_value_disallow_all(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueDisallowAll)

    def as_privacy_value_disallow_all(self) -> Optional[types.PrivacyValueDisallowAll]:
        return self._inner if self.is_privacy_value_disallow_all() else None

    def is_privacy_value_disallow_users(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueDisallowUsers)

    def as_privacy_value_disallow_users(self) -> Optional[types.PrivacyValueDisallowUsers]:
        return self._inner if self.is_privacy_value_disallow_users() else None

    def is_privacy_value_allow_chat_participants(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowChatParticipants)

    def as_privacy_value_allow_chat_participants(self) -> Optional[types.PrivacyValueAllowChatParticipants]:
        return self._inner if self.is_privacy_value_allow_chat_participants() else None

    def is_privacy_value_disallow_chat_participants(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueDisallowChatParticipants)

    def as_privacy_value_disallow_chat_participants(self) -> Optional[types.PrivacyValueDisallowChatParticipants]:
        return self._inner if self.is_privacy_value_disallow_chat_participants() else None

    def is_privacy_value_allow_close_friends(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowCloseFriends)

    def as_privacy_value_allow_close_friends(self) -> Optional[types.PrivacyValueAllowCloseFriends]:
        return self._inner if self.is_privacy_value_allow_close_friends() else None

    def is_privacy_value_allow_premium(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowPremium)

    def as_privacy_value_allow_premium(self) -> Optional[types.PrivacyValueAllowPremium]:
        return self._inner if self.is_privacy_value_allow_premium() else None

    def is_privacy_value_allow_bots(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueAllowBots)

    def as_privacy_value_allow_bots(self) -> Optional[types.PrivacyValueAllowBots]:
        return self._inner if self.is_privacy_value_allow_bots() else None

    def is_privacy_value_disallow_bots(self) -> bool:
        return isinstance(self._inner, types.PrivacyValueDisallowBots)

    def as_privacy_value_disallow_bots(self) -> Optional[types.PrivacyValueDisallowBots]:
        return self._inner if self.is_privacy_value_disallow_bots() else None

    def __repr__(self) -> str:
        return f'PrivacyRule({self._inner!r})'


class ProfileTab(TLObject):
    """
    Boxed TL type ``ProfileTab`` — union of 8 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB98CD696: types.ProfileTabPosts,
        0x4D4BD46A: types.ProfileTabGifts,
        0x72C64955: types.ProfileTabMedia,
        0xAB339C00: types.ProfileTabFiles,
        0x9F27D26E: types.ProfileTabMusic,
        0xE477092E: types.ProfileTabVoice,
        0xD3656499: types.ProfileTabLinks,
        0xA2C0F695: types.ProfileTabGifs,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ProfileTab':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_posts(self) -> bool:
        return isinstance(self._inner, types.ProfileTabPosts)

    def as_posts(self) -> Optional[types.ProfileTabPosts]:
        return self._inner if self.is_posts() else None

    def is_gifts(self) -> bool:
        return isinstance(self._inner, types.ProfileTabGifts)

    def as_gifts(self) -> Optional[types.ProfileTabGifts]:
        return self._inner if self.is_gifts() else None

    def is_media(self) -> bool:
        return isinstance(self._inner, types.ProfileTabMedia)

    def as_media(self) -> Optional[types.ProfileTabMedia]:
        return self._inner if self.is_media() else None

    def is_files(self) -> bool:
        return isinstance(self._inner, types.ProfileTabFiles)

    def as_files(self) -> Optional[types.ProfileTabFiles]:
        return self._inner if self.is_files() else None

    def is_music(self) -> bool:
        return isinstance(self._inner, types.ProfileTabMusic)

    def as_music(self) -> Optional[types.ProfileTabMusic]:
        return self._inner if self.is_music() else None

    def is_voice(self) -> bool:
        return isinstance(self._inner, types.ProfileTabVoice)

    def as_voice(self) -> Optional[types.ProfileTabVoice]:
        return self._inner if self.is_voice() else None

    def is_links(self) -> bool:
        return isinstance(self._inner, types.ProfileTabLinks)

    def as_links(self) -> Optional[types.ProfileTabLinks]:
        return self._inner if self.is_links() else None

    def is_gifs(self) -> bool:
        return isinstance(self._inner, types.ProfileTabGifs)

    def as_gifs(self) -> Optional[types.ProfileTabGifs]:
        return self._inner if self.is_gifs() else None

    def __repr__(self) -> str:
        return f'ProfileTab({self._inner!r})'


class PublicForward(TLObject):
    """
    Boxed TL type ``PublicForward`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x01F2BF4A: types.PublicForwardMessage,
        0xEDF3ADD0: types.PublicForwardStory,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PublicForward':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message(self) -> bool:
        return isinstance(self._inner, types.PublicForwardMessage)

    def as_message(self) -> Optional[types.PublicForwardMessage]:
        return self._inner if self.is_message() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.PublicForwardStory)

    def as_story(self) -> Optional[types.PublicForwardStory]:
        return self._inner if self.is_story() else None

    def __repr__(self) -> str:
        return f'PublicForward({self._inner!r})'


class QuickReply(TLObject):
    """
    Boxed TL type ``QuickReply`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0697102B: types.QuickReply,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'QuickReply':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_quick_reply(self) -> bool:
        return isinstance(self._inner, types.QuickReply)

    def as_quick_reply(self) -> Optional[types.QuickReply]:
        return self._inner if self.is_quick_reply() else None

    def __repr__(self) -> str:
        return f'QuickReply({self._inner!r})'


class Reaction(TLObject):
    """
    Boxed TL type ``Reaction`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x79F5D419: types.ReactionEmpty,
        0x1B2286B8: types.ReactionEmoji,
        0x8935FC73: types.ReactionCustomEmoji,
        0x523DA4EB: types.ReactionPaid,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Reaction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.ReactionEmpty)

    def as_empty(self) -> Optional[types.ReactionEmpty]:
        return self._inner if self.is_empty() else None

    def is_emoji(self) -> bool:
        return isinstance(self._inner, types.ReactionEmoji)

    def as_emoji(self) -> Optional[types.ReactionEmoji]:
        return self._inner if self.is_emoji() else None

    def is_custom_emoji(self) -> bool:
        return isinstance(self._inner, types.ReactionCustomEmoji)

    def as_custom_emoji(self) -> Optional[types.ReactionCustomEmoji]:
        return self._inner if self.is_custom_emoji() else None

    def is_paid(self) -> bool:
        return isinstance(self._inner, types.ReactionPaid)

    def as_paid(self) -> Optional[types.ReactionPaid]:
        return self._inner if self.is_paid() else None

    def __repr__(self) -> str:
        return f'Reaction({self._inner!r})'


class ReactionCount(TLObject):
    """
    Boxed TL type ``ReactionCount`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA3D1CB80: types.ReactionCount,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReactionCount':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_reaction_count(self) -> bool:
        return isinstance(self._inner, types.ReactionCount)

    def as_reaction_count(self) -> Optional[types.ReactionCount]:
        return self._inner if self.is_reaction_count() else None

    def __repr__(self) -> str:
        return f'ReactionCount({self._inner!r})'


class ReactionNotificationsFrom(TLObject):
    """
    Boxed TL type ``ReactionNotificationsFrom`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBAC3A61A: types.ReactionNotificationsFromContacts,
        0x4B9E22A0: types.ReactionNotificationsFromAll,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReactionNotificationsFrom':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_contacts(self) -> bool:
        return isinstance(self._inner, types.ReactionNotificationsFromContacts)

    def as_contacts(self) -> Optional[types.ReactionNotificationsFromContacts]:
        return self._inner if self.is_contacts() else None

    def is_all(self) -> bool:
        return isinstance(self._inner, types.ReactionNotificationsFromAll)

    def as_all(self) -> Optional[types.ReactionNotificationsFromAll]:
        return self._inner if self.is_all() else None

    def __repr__(self) -> str:
        return f'ReactionNotificationsFrom({self._inner!r})'


class ReactionsNotifySettings(TLObject):
    """
    Boxed TL type ``ReactionsNotifySettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x56E34970: types.ReactionsNotifySettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReactionsNotifySettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_reactions_notify_settings(self) -> bool:
        return isinstance(self._inner, types.ReactionsNotifySettings)

    def as_reactions_notify_settings(self) -> Optional[types.ReactionsNotifySettings]:
        return self._inner if self.is_reactions_notify_settings() else None

    def __repr__(self) -> str:
        return f'ReactionsNotifySettings({self._inner!r})'


class ReadParticipantDate(TLObject):
    """
    Boxed TL type ``ReadParticipantDate`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4A4FF172: types.ReadParticipantDate,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReadParticipantDate':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_read_participant_date(self) -> bool:
        return isinstance(self._inner, types.ReadParticipantDate)

    def as_read_participant_date(self) -> Optional[types.ReadParticipantDate]:
        return self._inner if self.is_read_participant_date() else None

    def __repr__(self) -> str:
        return f'ReadParticipantDate({self._inner!r})'


class ReceivedNotifyMessage(TLObject):
    """
    Boxed TL type ``ReceivedNotifyMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA384B779: types.ReceivedNotifyMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReceivedNotifyMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_received_notify_message(self) -> bool:
        return isinstance(self._inner, types.ReceivedNotifyMessage)

    def as_received_notify_message(self) -> Optional[types.ReceivedNotifyMessage]:
        return self._inner if self.is_received_notify_message() else None

    def __repr__(self) -> str:
        return f'ReceivedNotifyMessage({self._inner!r})'


class RecentMeUrl(TLObject):
    """
    Boxed TL type ``RecentMeUrl`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x46E1D13D: types.RecentMeUrlUnknown,
        0xB92C09E2: types.RecentMeUrlUser,
        0xB2DA71D2: types.RecentMeUrlChat,
        0xEB49081D: types.RecentMeUrlChatInvite,
        0xBC0A57DC: types.RecentMeUrlStickerSet,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RecentMeUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unknown(self) -> bool:
        return isinstance(self._inner, types.RecentMeUrlUnknown)

    def as_unknown(self) -> Optional[types.RecentMeUrlUnknown]:
        return self._inner if self.is_unknown() else None

    def is_user(self) -> bool:
        return isinstance(self._inner, types.RecentMeUrlUser)

    def as_user(self) -> Optional[types.RecentMeUrlUser]:
        return self._inner if self.is_user() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.RecentMeUrlChat)

    def as_chat(self) -> Optional[types.RecentMeUrlChat]:
        return self._inner if self.is_chat() else None

    def is_chat_invite(self) -> bool:
        return isinstance(self._inner, types.RecentMeUrlChatInvite)

    def as_chat_invite(self) -> Optional[types.RecentMeUrlChatInvite]:
        return self._inner if self.is_chat_invite() else None

    def is_sticker_set(self) -> bool:
        return isinstance(self._inner, types.RecentMeUrlStickerSet)

    def as_sticker_set(self) -> Optional[types.RecentMeUrlStickerSet]:
        return self._inner if self.is_sticker_set() else None

    def __repr__(self) -> str:
        return f'RecentMeUrl({self._inner!r})'


class RecentStory(TLObject):
    """
    Boxed TL type ``RecentStory`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x711D692D: types.RecentStory,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RecentStory':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_recent_story(self) -> bool:
        return isinstance(self._inner, types.RecentStory)

    def as_recent_story(self) -> Optional[types.RecentStory]:
        return self._inner if self.is_recent_story() else None

    def __repr__(self) -> str:
        return f'RecentStory({self._inner!r})'


class ReplyMarkup(TLObject):
    """
    Boxed TL type ``ReplyMarkup`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA03E5B85: types.ReplyKeyboardHide,
        0x86B40B08: types.ReplyKeyboardForceReply,
        0x85DD99D1: types.ReplyKeyboardMarkup,
        0x48A30254: types.ReplyInlineMarkup,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReplyMarkup':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_reply_keyboard_hide(self) -> bool:
        return isinstance(self._inner, types.ReplyKeyboardHide)

    def as_reply_keyboard_hide(self) -> Optional[types.ReplyKeyboardHide]:
        return self._inner if self.is_reply_keyboard_hide() else None

    def is_reply_keyboard_force_reply(self) -> bool:
        return isinstance(self._inner, types.ReplyKeyboardForceReply)

    def as_reply_keyboard_force_reply(self) -> Optional[types.ReplyKeyboardForceReply]:
        return self._inner if self.is_reply_keyboard_force_reply() else None

    def is_reply_keyboard_markup(self) -> bool:
        return isinstance(self._inner, types.ReplyKeyboardMarkup)

    def as_reply_keyboard_markup(self) -> Optional[types.ReplyKeyboardMarkup]:
        return self._inner if self.is_reply_keyboard_markup() else None

    def is_reply_inline_markup(self) -> bool:
        return isinstance(self._inner, types.ReplyInlineMarkup)

    def as_reply_inline_markup(self) -> Optional[types.ReplyInlineMarkup]:
        return self._inner if self.is_reply_inline_markup() else None

    def __repr__(self) -> str:
        return f'ReplyMarkup({self._inner!r})'


class ReportReason(TLObject):
    """
    Boxed TL type ``ReportReason`` — union of 10 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x58DBCAB8: types.InputReportReasonSpam,
        0x1E22C78D: types.InputReportReasonViolence,
        0x2E59D922: types.InputReportReasonPornography,
        0xADF44EE3: types.InputReportReasonChildAbuse,
        0xC1E4A2B1: types.InputReportReasonOther,
        0x9B89F93A: types.InputReportReasonCopyright,
        0xDBD4FEED: types.InputReportReasonGeoIrrelevant,
        0xF5DDD6E7: types.InputReportReasonFake,
        0x0A8EB2BE: types.InputReportReasonIllegalDrugs,
        0x9EC7863D: types.InputReportReasonPersonalDetails,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReportReason':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_input_report_reason_spam(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonSpam)

    def as_input_report_reason_spam(self) -> Optional[types.InputReportReasonSpam]:
        return self._inner if self.is_input_report_reason_spam() else None

    def is_input_report_reason_violence(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonViolence)

    def as_input_report_reason_violence(self) -> Optional[types.InputReportReasonViolence]:
        return self._inner if self.is_input_report_reason_violence() else None

    def is_input_report_reason_pornography(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonPornography)

    def as_input_report_reason_pornography(self) -> Optional[types.InputReportReasonPornography]:
        return self._inner if self.is_input_report_reason_pornography() else None

    def is_input_report_reason_child_abuse(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonChildAbuse)

    def as_input_report_reason_child_abuse(self) -> Optional[types.InputReportReasonChildAbuse]:
        return self._inner if self.is_input_report_reason_child_abuse() else None

    def is_input_report_reason_other(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonOther)

    def as_input_report_reason_other(self) -> Optional[types.InputReportReasonOther]:
        return self._inner if self.is_input_report_reason_other() else None

    def is_input_report_reason_copyright(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonCopyright)

    def as_input_report_reason_copyright(self) -> Optional[types.InputReportReasonCopyright]:
        return self._inner if self.is_input_report_reason_copyright() else None

    def is_input_report_reason_geo_irrelevant(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonGeoIrrelevant)

    def as_input_report_reason_geo_irrelevant(self) -> Optional[types.InputReportReasonGeoIrrelevant]:
        return self._inner if self.is_input_report_reason_geo_irrelevant() else None

    def is_input_report_reason_fake(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonFake)

    def as_input_report_reason_fake(self) -> Optional[types.InputReportReasonFake]:
        return self._inner if self.is_input_report_reason_fake() else None

    def is_input_report_reason_illegal_drugs(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonIllegalDrugs)

    def as_input_report_reason_illegal_drugs(self) -> Optional[types.InputReportReasonIllegalDrugs]:
        return self._inner if self.is_input_report_reason_illegal_drugs() else None

    def is_input_report_reason_personal_details(self) -> bool:
        return isinstance(self._inner, types.InputReportReasonPersonalDetails)

    def as_input_report_reason_personal_details(self) -> Optional[types.InputReportReasonPersonalDetails]:
        return self._inner if self.is_input_report_reason_personal_details() else None

    def __repr__(self) -> str:
        return f'ReportReason({self._inner!r})'


class ReportResult(TLObject):
    """
    Boxed TL type ``ReportResult`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF0E4E0B6: types.ReportResultChooseOption,
        0x6F09AC31: types.ReportResultAddComment,
        0x8DB33C4B: types.ReportResultReported,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ReportResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_choose_option(self) -> bool:
        return isinstance(self._inner, types.ReportResultChooseOption)

    def as_choose_option(self) -> Optional[types.ReportResultChooseOption]:
        return self._inner if self.is_choose_option() else None

    def is_add_comment(self) -> bool:
        return isinstance(self._inner, types.ReportResultAddComment)

    def as_add_comment(self) -> Optional[types.ReportResultAddComment]:
        return self._inner if self.is_add_comment() else None

    def is_reported(self) -> bool:
        return isinstance(self._inner, types.ReportResultReported)

    def as_reported(self) -> Optional[types.ReportResultReported]:
        return self._inner if self.is_reported() else None

    def __repr__(self) -> str:
        return f'ReportResult({self._inner!r})'


class RequestPeerType(TLObject):
    """
    Boxed TL type ``RequestPeerType`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5F3B8A00: types.RequestPeerTypeUser,
        0xC9F06E1B: types.RequestPeerTypeChat,
        0x339BEF6C: types.RequestPeerTypeBroadcast,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RequestPeerType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_user(self) -> bool:
        return isinstance(self._inner, types.RequestPeerTypeUser)

    def as_user(self) -> Optional[types.RequestPeerTypeUser]:
        return self._inner if self.is_user() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.RequestPeerTypeChat)

    def as_chat(self) -> Optional[types.RequestPeerTypeChat]:
        return self._inner if self.is_chat() else None

    def is_broadcast(self) -> bool:
        return isinstance(self._inner, types.RequestPeerTypeBroadcast)

    def as_broadcast(self) -> Optional[types.RequestPeerTypeBroadcast]:
        return self._inner if self.is_broadcast() else None

    def __repr__(self) -> str:
        return f'RequestPeerType({self._inner!r})'


class RequestedPeer(TLObject):
    """
    Boxed TL type ``RequestedPeer`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD62FF46A: types.RequestedPeerUser,
        0x7307544F: types.RequestedPeerChat,
        0x8BA403E4: types.RequestedPeerChannel,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RequestedPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_user(self) -> bool:
        return isinstance(self._inner, types.RequestedPeerUser)

    def as_user(self) -> Optional[types.RequestedPeerUser]:
        return self._inner if self.is_user() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.RequestedPeerChat)

    def as_chat(self) -> Optional[types.RequestedPeerChat]:
        return self._inner if self.is_chat() else None

    def is_channel(self) -> bool:
        return isinstance(self._inner, types.RequestedPeerChannel)

    def as_channel(self) -> Optional[types.RequestedPeerChannel]:
        return self._inner if self.is_channel() else None

    def __repr__(self) -> str:
        return f'RequestedPeer({self._inner!r})'


class RequirementToContact(TLObject):
    """
    Boxed TL type ``RequirementToContact`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x050A9839: types.RequirementToContactEmpty,
        0xE581E4E9: types.RequirementToContactPremium,
        0xB4F67E93: types.RequirementToContactPaidMessages,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RequirementToContact':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.RequirementToContactEmpty)

    def as_empty(self) -> Optional[types.RequirementToContactEmpty]:
        return self._inner if self.is_empty() else None

    def is_premium(self) -> bool:
        return isinstance(self._inner, types.RequirementToContactPremium)

    def as_premium(self) -> Optional[types.RequirementToContactPremium]:
        return self._inner if self.is_premium() else None

    def is_paid_messages(self) -> bool:
        return isinstance(self._inner, types.RequirementToContactPaidMessages)

    def as_paid_messages(self) -> Optional[types.RequirementToContactPaidMessages]:
        return self._inner if self.is_paid_messages() else None

    def __repr__(self) -> str:
        return f'RequirementToContact({self._inner!r})'


class RestrictionReason(TLObject):
    """
    Boxed TL type ``RestrictionReason`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD072ACB4: types.RestrictionReason,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RestrictionReason':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_restriction_reason(self) -> bool:
        return isinstance(self._inner, types.RestrictionReason)

    def as_restriction_reason(self) -> Optional[types.RestrictionReason]:
        return self._inner if self.is_restriction_reason() else None

    def __repr__(self) -> str:
        return f'RestrictionReason({self._inner!r})'


class RichText(TLObject):
    """
    Boxed TL type ``RichText`` — union of 16 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDC3D824F: types.TextEmpty,
        0x744694E0: types.TextPlain,
        0x6724ABC4: types.TextBold,
        0xD912A59C: types.TextItalic,
        0xC12622C4: types.TextUnderline,
        0x9BF8BB95: types.TextStrike,
        0x6C3F19B9: types.TextFixed,
        0x3C2884C1: types.TextUrl,
        0xDE5A0DD6: types.TextEmail,
        0x7E6260D7: types.TextConcat,
        0xED6A8504: types.TextSubscript,
        0xC7FB5E01: types.TextSuperscript,
        0x034B8621: types.TextMarked,
        0x1CCB966A: types.TextPhone,
        0x081CCF4F: types.TextImage,
        0x35553762: types.TextAnchor,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RichText':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_text_empty(self) -> bool:
        return isinstance(self._inner, types.TextEmpty)

    def as_text_empty(self) -> Optional[types.TextEmpty]:
        return self._inner if self.is_text_empty() else None

    def is_text_plain(self) -> bool:
        return isinstance(self._inner, types.TextPlain)

    def as_text_plain(self) -> Optional[types.TextPlain]:
        return self._inner if self.is_text_plain() else None

    def is_text_bold(self) -> bool:
        return isinstance(self._inner, types.TextBold)

    def as_text_bold(self) -> Optional[types.TextBold]:
        return self._inner if self.is_text_bold() else None

    def is_text_italic(self) -> bool:
        return isinstance(self._inner, types.TextItalic)

    def as_text_italic(self) -> Optional[types.TextItalic]:
        return self._inner if self.is_text_italic() else None

    def is_text_underline(self) -> bool:
        return isinstance(self._inner, types.TextUnderline)

    def as_text_underline(self) -> Optional[types.TextUnderline]:
        return self._inner if self.is_text_underline() else None

    def is_text_strike(self) -> bool:
        return isinstance(self._inner, types.TextStrike)

    def as_text_strike(self) -> Optional[types.TextStrike]:
        return self._inner if self.is_text_strike() else None

    def is_text_fixed(self) -> bool:
        return isinstance(self._inner, types.TextFixed)

    def as_text_fixed(self) -> Optional[types.TextFixed]:
        return self._inner if self.is_text_fixed() else None

    def is_text_url(self) -> bool:
        return isinstance(self._inner, types.TextUrl)

    def as_text_url(self) -> Optional[types.TextUrl]:
        return self._inner if self.is_text_url() else None

    def is_text_email(self) -> bool:
        return isinstance(self._inner, types.TextEmail)

    def as_text_email(self) -> Optional[types.TextEmail]:
        return self._inner if self.is_text_email() else None

    def is_text_concat(self) -> bool:
        return isinstance(self._inner, types.TextConcat)

    def as_text_concat(self) -> Optional[types.TextConcat]:
        return self._inner if self.is_text_concat() else None

    def is_text_subscript(self) -> bool:
        return isinstance(self._inner, types.TextSubscript)

    def as_text_subscript(self) -> Optional[types.TextSubscript]:
        return self._inner if self.is_text_subscript() else None

    def is_text_superscript(self) -> bool:
        return isinstance(self._inner, types.TextSuperscript)

    def as_text_superscript(self) -> Optional[types.TextSuperscript]:
        return self._inner if self.is_text_superscript() else None

    def is_text_marked(self) -> bool:
        return isinstance(self._inner, types.TextMarked)

    def as_text_marked(self) -> Optional[types.TextMarked]:
        return self._inner if self.is_text_marked() else None

    def is_text_phone(self) -> bool:
        return isinstance(self._inner, types.TextPhone)

    def as_text_phone(self) -> Optional[types.TextPhone]:
        return self._inner if self.is_text_phone() else None

    def is_text_image(self) -> bool:
        return isinstance(self._inner, types.TextImage)

    def as_text_image(self) -> Optional[types.TextImage]:
        return self._inner if self.is_text_image() else None

    def is_text_anchor(self) -> bool:
        return isinstance(self._inner, types.TextAnchor)

    def as_text_anchor(self) -> Optional[types.TextAnchor]:
        return self._inner if self.is_text_anchor() else None

    def __repr__(self) -> str:
        return f'RichText({self._inner!r})'


class SavedContact(TLObject):
    """
    Boxed TL type ``SavedContact`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1142BD56: types.SavedPhoneContact,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedContact':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_phone_contact(self) -> bool:
        return isinstance(self._inner, types.SavedPhoneContact)

    def as_saved_phone_contact(self) -> Optional[types.SavedPhoneContact]:
        return self._inner if self.is_saved_phone_contact() else None

    def __repr__(self) -> str:
        return f'SavedContact({self._inner!r})'


class SavedDialog(TLObject):
    """
    Boxed TL type ``SavedDialog`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBD87CB6C: types.SavedDialog,
        0x64407EA7: types.MonoForumDialog,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedDialog':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_dialog(self) -> bool:
        return isinstance(self._inner, types.SavedDialog)

    def as_saved_dialog(self) -> Optional[types.SavedDialog]:
        return self._inner if self.is_saved_dialog() else None

    def is_mono_forum_dialog(self) -> bool:
        return isinstance(self._inner, types.MonoForumDialog)

    def as_mono_forum_dialog(self) -> Optional[types.MonoForumDialog]:
        return self._inner if self.is_mono_forum_dialog() else None

    def __repr__(self) -> str:
        return f'SavedDialog({self._inner!r})'


class SavedReactionTag(TLObject):
    """
    Boxed TL type ``SavedReactionTag`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCB6FF828: types.SavedReactionTag,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedReactionTag':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_reaction_tag(self) -> bool:
        return isinstance(self._inner, types.SavedReactionTag)

    def as_saved_reaction_tag(self) -> Optional[types.SavedReactionTag]:
        return self._inner if self.is_saved_reaction_tag() else None

    def __repr__(self) -> str:
        return f'SavedReactionTag({self._inner!r})'


class SavedStarGift(TLObject):
    """
    Boxed TL type ``SavedStarGift`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x41DF43FC: types.SavedStarGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedStarGift':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_star_gift(self) -> bool:
        return isinstance(self._inner, types.SavedStarGift)

    def as_saved_star_gift(self) -> Optional[types.SavedStarGift]:
        return self._inner if self.is_saved_star_gift() else None

    def __repr__(self) -> str:
        return f'SavedStarGift({self._inner!r})'


class SearchPostsFlood(TLObject):
    """
    Boxed TL type ``SearchPostsFlood`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3E0B5B6A: types.SearchPostsFlood,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SearchPostsFlood':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_search_posts_flood(self) -> bool:
        return isinstance(self._inner, types.SearchPostsFlood)

    def as_search_posts_flood(self) -> Optional[types.SearchPostsFlood]:
        return self._inner if self.is_search_posts_flood() else None

    def __repr__(self) -> str:
        return f'SearchPostsFlood({self._inner!r})'


class SearchResultsCalendarPeriod(TLObject):
    """
    Boxed TL type ``SearchResultsCalendarPeriod`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC9B0539F: types.SearchResultsCalendarPeriod,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SearchResultsCalendarPeriod':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_search_results_calendar_period(self) -> bool:
        return isinstance(self._inner, types.SearchResultsCalendarPeriod)

    def as_search_results_calendar_period(self) -> Optional[types.SearchResultsCalendarPeriod]:
        return self._inner if self.is_search_results_calendar_period() else None

    def __repr__(self) -> str:
        return f'SearchResultsCalendarPeriod({self._inner!r})'


class SearchResultsPosition(TLObject):
    """
    Boxed TL type ``SearchResultsPosition`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7F648B67: types.SearchResultPosition,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SearchResultsPosition':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_search_result_position(self) -> bool:
        return isinstance(self._inner, types.SearchResultPosition)

    def as_search_result_position(self) -> Optional[types.SearchResultPosition]:
        return self._inner if self.is_search_result_position() else None

    def __repr__(self) -> str:
        return f'SearchResultsPosition({self._inner!r})'


class SecureCredentialsEncrypted(TLObject):
    """
    Boxed TL type ``SecureCredentialsEncrypted`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x33F0EA47: types.SecureCredentialsEncrypted,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureCredentialsEncrypted':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_credentials_encrypted(self) -> bool:
        return isinstance(self._inner, types.SecureCredentialsEncrypted)

    def as_secure_credentials_encrypted(self) -> Optional[types.SecureCredentialsEncrypted]:
        return self._inner if self.is_secure_credentials_encrypted() else None

    def __repr__(self) -> str:
        return f'SecureCredentialsEncrypted({self._inner!r})'


class SecureData(TLObject):
    """
    Boxed TL type ``SecureData`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8AEABEC3: types.SecureData,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureData':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_data(self) -> bool:
        return isinstance(self._inner, types.SecureData)

    def as_secure_data(self) -> Optional[types.SecureData]:
        return self._inner if self.is_secure_data() else None

    def __repr__(self) -> str:
        return f'SecureData({self._inner!r})'


class SecureFile(TLObject):
    """
    Boxed TL type ``SecureFile`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x64199744: types.SecureFileEmpty,
        0x7D09C27E: types.SecureFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.SecureFileEmpty)

    def as_empty(self) -> Optional[types.SecureFileEmpty]:
        return self._inner if self.is_empty() else None

    def is_secure_file(self) -> bool:
        return isinstance(self._inner, types.SecureFile)

    def as_secure_file(self) -> Optional[types.SecureFile]:
        return self._inner if self.is_secure_file() else None

    def __repr__(self) -> str:
        return f'SecureFile({self._inner!r})'


class SecurePasswordKdfAlgo(TLObject):
    """
    Boxed TL type ``SecurePasswordKdfAlgo`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x004A8537: types.SecurePasswordKdfAlgoUnknown,
        0xBBF2DDA0: types.SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000,
        0x86471D92: types.SecurePasswordKdfAlgoSha512,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecurePasswordKdfAlgo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unknown(self) -> bool:
        return isinstance(self._inner, types.SecurePasswordKdfAlgoUnknown)

    def as_unknown(self) -> Optional[types.SecurePasswordKdfAlgoUnknown]:
        return self._inner if self.is_unknown() else None

    def is_pbkdf2_hmacsha512iter100000(self) -> bool:
        return isinstance(self._inner, types.SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000)

    def as_pbkdf2_hmacsha512iter100000(self) -> Optional[types.SecurePasswordKdfAlgoPbkdf2Hmacsha512iter100000]:
        return self._inner if self.is_pbkdf2_hmacsha512iter100000() else None

    def is_sha512(self) -> bool:
        return isinstance(self._inner, types.SecurePasswordKdfAlgoSha512)

    def as_sha512(self) -> Optional[types.SecurePasswordKdfAlgoSha512]:
        return self._inner if self.is_sha512() else None

    def __repr__(self) -> str:
        return f'SecurePasswordKdfAlgo({self._inner!r})'


class SecurePlainData(TLObject):
    """
    Boxed TL type ``SecurePlainData`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7D6099DD: types.SecurePlainPhone,
        0x21EC5A5F: types.SecurePlainEmail,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecurePlainData':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_plain_phone(self) -> bool:
        return isinstance(self._inner, types.SecurePlainPhone)

    def as_secure_plain_phone(self) -> Optional[types.SecurePlainPhone]:
        return self._inner if self.is_secure_plain_phone() else None

    def is_secure_plain_email(self) -> bool:
        return isinstance(self._inner, types.SecurePlainEmail)

    def as_secure_plain_email(self) -> Optional[types.SecurePlainEmail]:
        return self._inner if self.is_secure_plain_email() else None

    def __repr__(self) -> str:
        return f'SecurePlainData({self._inner!r})'


class SecureRequiredType(TLObject):
    """
    Boxed TL type ``SecureRequiredType`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x829D99DA: types.SecureRequiredType,
        0x027477B4: types.SecureRequiredTypeOneOf,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureRequiredType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_required_type(self) -> bool:
        return isinstance(self._inner, types.SecureRequiredType)

    def as_secure_required_type(self) -> Optional[types.SecureRequiredType]:
        return self._inner if self.is_secure_required_type() else None

    def is_one_of(self) -> bool:
        return isinstance(self._inner, types.SecureRequiredTypeOneOf)

    def as_one_of(self) -> Optional[types.SecureRequiredTypeOneOf]:
        return self._inner if self.is_one_of() else None

    def __repr__(self) -> str:
        return f'SecureRequiredType({self._inner!r})'


class SecureSecretSettings(TLObject):
    """
    Boxed TL type ``SecureSecretSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1527BCAC: types.SecureSecretSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureSecretSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_secret_settings(self) -> bool:
        return isinstance(self._inner, types.SecureSecretSettings)

    def as_secure_secret_settings(self) -> Optional[types.SecureSecretSettings]:
        return self._inner if self.is_secure_secret_settings() else None

    def __repr__(self) -> str:
        return f'SecureSecretSettings({self._inner!r})'


class SecureValue(TLObject):
    """
    Boxed TL type ``SecureValue`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x187FA0CA: types.SecureValue,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureValue':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_value(self) -> bool:
        return isinstance(self._inner, types.SecureValue)

    def as_secure_value(self) -> Optional[types.SecureValue]:
        return self._inner if self.is_secure_value() else None

    def __repr__(self) -> str:
        return f'SecureValue({self._inner!r})'


class SecureValueError(TLObject):
    """
    Boxed TL type ``SecureValueError`` — union of 9 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE8A40BD9: types.SecureValueErrorData,
        0x00BE3DFA: types.SecureValueErrorFrontSide,
        0x868A2AA5: types.SecureValueErrorReverseSide,
        0xE537CED6: types.SecureValueErrorSelfie,
        0x7A700873: types.SecureValueErrorFile,
        0x666220E9: types.SecureValueErrorFiles,
        0x869D758F: types.SecureValueError,
        0xA1144770: types.SecureValueErrorTranslationFile,
        0x34636DD8: types.SecureValueErrorTranslationFiles,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureValueError':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_data(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorData)

    def as_data(self) -> Optional[types.SecureValueErrorData]:
        return self._inner if self.is_data() else None

    def is_front_side(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorFrontSide)

    def as_front_side(self) -> Optional[types.SecureValueErrorFrontSide]:
        return self._inner if self.is_front_side() else None

    def is_reverse_side(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorReverseSide)

    def as_reverse_side(self) -> Optional[types.SecureValueErrorReverseSide]:
        return self._inner if self.is_reverse_side() else None

    def is_selfie(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorSelfie)

    def as_selfie(self) -> Optional[types.SecureValueErrorSelfie]:
        return self._inner if self.is_selfie() else None

    def is_file(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorFile)

    def as_file(self) -> Optional[types.SecureValueErrorFile]:
        return self._inner if self.is_file() else None

    def is_files(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorFiles)

    def as_files(self) -> Optional[types.SecureValueErrorFiles]:
        return self._inner if self.is_files() else None

    def is_secure_value_error(self) -> bool:
        return isinstance(self._inner, types.SecureValueError)

    def as_secure_value_error(self) -> Optional[types.SecureValueError]:
        return self._inner if self.is_secure_value_error() else None

    def is_translation_file(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorTranslationFile)

    def as_translation_file(self) -> Optional[types.SecureValueErrorTranslationFile]:
        return self._inner if self.is_translation_file() else None

    def is_translation_files(self) -> bool:
        return isinstance(self._inner, types.SecureValueErrorTranslationFiles)

    def as_translation_files(self) -> Optional[types.SecureValueErrorTranslationFiles]:
        return self._inner if self.is_translation_files() else None

    def __repr__(self) -> str:
        return f'SecureValueError({self._inner!r})'


class SecureValueHash(TLObject):
    """
    Boxed TL type ``SecureValueHash`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xED1ECDB0: types.SecureValueHash,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureValueHash':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_secure_value_hash(self) -> bool:
        return isinstance(self._inner, types.SecureValueHash)

    def as_secure_value_hash(self) -> Optional[types.SecureValueHash]:
        return self._inner if self.is_secure_value_hash() else None

    def __repr__(self) -> str:
        return f'SecureValueHash({self._inner!r})'


class SecureValueType(TLObject):
    """
    Boxed TL type ``SecureValueType`` — union of 13 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9D2A81E3: types.SecureValueTypePersonalDetails,
        0x3DAC6A00: types.SecureValueTypePassport,
        0x06E425C4: types.SecureValueTypeDriverLicense,
        0xA0D0744B: types.SecureValueTypeIdentityCard,
        0x99A48F23: types.SecureValueTypeInternalPassport,
        0xCBE31E26: types.SecureValueTypeAddress,
        0xFC36954E: types.SecureValueTypeUtilityBill,
        0x89137C0D: types.SecureValueTypeBankStatement,
        0x8B883488: types.SecureValueTypeRentalAgreement,
        0x99E3806A: types.SecureValueTypePassportRegistration,
        0xEA02EC33: types.SecureValueTypeTemporaryRegistration,
        0xB320AADB: types.SecureValueTypePhone,
        0x8E3CA7EE: types.SecureValueTypeEmail,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SecureValueType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_personal_details(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypePersonalDetails)

    def as_personal_details(self) -> Optional[types.SecureValueTypePersonalDetails]:
        return self._inner if self.is_personal_details() else None

    def is_passport(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypePassport)

    def as_passport(self) -> Optional[types.SecureValueTypePassport]:
        return self._inner if self.is_passport() else None

    def is_driver_license(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeDriverLicense)

    def as_driver_license(self) -> Optional[types.SecureValueTypeDriverLicense]:
        return self._inner if self.is_driver_license() else None

    def is_identity_card(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeIdentityCard)

    def as_identity_card(self) -> Optional[types.SecureValueTypeIdentityCard]:
        return self._inner if self.is_identity_card() else None

    def is_internal_passport(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeInternalPassport)

    def as_internal_passport(self) -> Optional[types.SecureValueTypeInternalPassport]:
        return self._inner if self.is_internal_passport() else None

    def is_address(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeAddress)

    def as_address(self) -> Optional[types.SecureValueTypeAddress]:
        return self._inner if self.is_address() else None

    def is_utility_bill(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeUtilityBill)

    def as_utility_bill(self) -> Optional[types.SecureValueTypeUtilityBill]:
        return self._inner if self.is_utility_bill() else None

    def is_bank_statement(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeBankStatement)

    def as_bank_statement(self) -> Optional[types.SecureValueTypeBankStatement]:
        return self._inner if self.is_bank_statement() else None

    def is_rental_agreement(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeRentalAgreement)

    def as_rental_agreement(self) -> Optional[types.SecureValueTypeRentalAgreement]:
        return self._inner if self.is_rental_agreement() else None

    def is_passport_registration(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypePassportRegistration)

    def as_passport_registration(self) -> Optional[types.SecureValueTypePassportRegistration]:
        return self._inner if self.is_passport_registration() else None

    def is_temporary_registration(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeTemporaryRegistration)

    def as_temporary_registration(self) -> Optional[types.SecureValueTypeTemporaryRegistration]:
        return self._inner if self.is_temporary_registration() else None

    def is_phone(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypePhone)

    def as_phone(self) -> Optional[types.SecureValueTypePhone]:
        return self._inner if self.is_phone() else None

    def is_email(self) -> bool:
        return isinstance(self._inner, types.SecureValueTypeEmail)

    def as_email(self) -> Optional[types.SecureValueTypeEmail]:
        return self._inner if self.is_email() else None

    def __repr__(self) -> str:
        return f'SecureValueType({self._inner!r})'


class SendAsPeer(TLObject):
    """
    Boxed TL type ``SendAsPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB81C7034: types.SendAsPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SendAsPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_send_as_peer(self) -> bool:
        return isinstance(self._inner, types.SendAsPeer)

    def as_send_as_peer(self) -> Optional[types.SendAsPeer]:
        return self._inner if self.is_send_as_peer() else None

    def __repr__(self) -> str:
        return f'SendAsPeer({self._inner!r})'


class SendMessageAction(TLObject):
    """
    Boxed TL type ``SendMessageAction`` — union of 19 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x16BF744E: types.SendMessageTypingAction,
        0xFD5EC8F5: types.SendMessageCancelAction,
        0xA187D66F: types.SendMessageRecordVideoAction,
        0xE9763AEC: types.SendMessageUploadVideoAction,
        0xD52F73F7: types.SendMessageRecordAudioAction,
        0xF351D7AB: types.SendMessageUploadAudioAction,
        0xD1D34A26: types.SendMessageUploadPhotoAction,
        0xAA0CD9E4: types.SendMessageUploadDocumentAction,
        0x176F8BA1: types.SendMessageGeoLocationAction,
        0x628CBC6F: types.SendMessageChooseContactAction,
        0xDD6A8F48: types.SendMessageGamePlayAction,
        0x88F27FBC: types.SendMessageRecordRoundAction,
        0x243E1C66: types.SendMessageUploadRoundAction,
        0xD92C2285: types.SpeakingInGroupCallAction,
        0xDBDA9246: types.SendMessageHistoryImportAction,
        0xB05AC6B1: types.SendMessageChooseStickerAction,
        0x25972BCB: types.SendMessageEmojiInteraction,
        0xB665902E: types.SendMessageEmojiInteractionSeen,
        0x376D975C: types.SendMessageTextDraftAction,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SendMessageAction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_send_message_typing_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageTypingAction)

    def as_send_message_typing_action(self) -> Optional[types.SendMessageTypingAction]:
        return self._inner if self.is_send_message_typing_action() else None

    def is_send_message_cancel_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageCancelAction)

    def as_send_message_cancel_action(self) -> Optional[types.SendMessageCancelAction]:
        return self._inner if self.is_send_message_cancel_action() else None

    def is_send_message_record_video_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageRecordVideoAction)

    def as_send_message_record_video_action(self) -> Optional[types.SendMessageRecordVideoAction]:
        return self._inner if self.is_send_message_record_video_action() else None

    def is_send_message_upload_video_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageUploadVideoAction)

    def as_send_message_upload_video_action(self) -> Optional[types.SendMessageUploadVideoAction]:
        return self._inner if self.is_send_message_upload_video_action() else None

    def is_send_message_record_audio_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageRecordAudioAction)

    def as_send_message_record_audio_action(self) -> Optional[types.SendMessageRecordAudioAction]:
        return self._inner if self.is_send_message_record_audio_action() else None

    def is_send_message_upload_audio_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageUploadAudioAction)

    def as_send_message_upload_audio_action(self) -> Optional[types.SendMessageUploadAudioAction]:
        return self._inner if self.is_send_message_upload_audio_action() else None

    def is_send_message_upload_photo_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageUploadPhotoAction)

    def as_send_message_upload_photo_action(self) -> Optional[types.SendMessageUploadPhotoAction]:
        return self._inner if self.is_send_message_upload_photo_action() else None

    def is_send_message_upload_document_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageUploadDocumentAction)

    def as_send_message_upload_document_action(self) -> Optional[types.SendMessageUploadDocumentAction]:
        return self._inner if self.is_send_message_upload_document_action() else None

    def is_send_message_geo_location_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageGeoLocationAction)

    def as_send_message_geo_location_action(self) -> Optional[types.SendMessageGeoLocationAction]:
        return self._inner if self.is_send_message_geo_location_action() else None

    def is_send_message_choose_contact_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageChooseContactAction)

    def as_send_message_choose_contact_action(self) -> Optional[types.SendMessageChooseContactAction]:
        return self._inner if self.is_send_message_choose_contact_action() else None

    def is_send_message_game_play_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageGamePlayAction)

    def as_send_message_game_play_action(self) -> Optional[types.SendMessageGamePlayAction]:
        return self._inner if self.is_send_message_game_play_action() else None

    def is_send_message_record_round_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageRecordRoundAction)

    def as_send_message_record_round_action(self) -> Optional[types.SendMessageRecordRoundAction]:
        return self._inner if self.is_send_message_record_round_action() else None

    def is_send_message_upload_round_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageUploadRoundAction)

    def as_send_message_upload_round_action(self) -> Optional[types.SendMessageUploadRoundAction]:
        return self._inner if self.is_send_message_upload_round_action() else None

    def is_speaking_in_group_call_action(self) -> bool:
        return isinstance(self._inner, types.SpeakingInGroupCallAction)

    def as_speaking_in_group_call_action(self) -> Optional[types.SpeakingInGroupCallAction]:
        return self._inner if self.is_speaking_in_group_call_action() else None

    def is_send_message_history_import_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageHistoryImportAction)

    def as_send_message_history_import_action(self) -> Optional[types.SendMessageHistoryImportAction]:
        return self._inner if self.is_send_message_history_import_action() else None

    def is_send_message_choose_sticker_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageChooseStickerAction)

    def as_send_message_choose_sticker_action(self) -> Optional[types.SendMessageChooseStickerAction]:
        return self._inner if self.is_send_message_choose_sticker_action() else None

    def is_send_message_emoji_interaction(self) -> bool:
        return isinstance(self._inner, types.SendMessageEmojiInteraction)

    def as_send_message_emoji_interaction(self) -> Optional[types.SendMessageEmojiInteraction]:
        return self._inner if self.is_send_message_emoji_interaction() else None

    def is_send_message_emoji_interaction_seen(self) -> bool:
        return isinstance(self._inner, types.SendMessageEmojiInteractionSeen)

    def as_send_message_emoji_interaction_seen(self) -> Optional[types.SendMessageEmojiInteractionSeen]:
        return self._inner if self.is_send_message_emoji_interaction_seen() else None

    def is_send_message_text_draft_action(self) -> bool:
        return isinstance(self._inner, types.SendMessageTextDraftAction)

    def as_send_message_text_draft_action(self) -> Optional[types.SendMessageTextDraftAction]:
        return self._inner if self.is_send_message_text_draft_action() else None

    def __repr__(self) -> str:
        return f'SendMessageAction({self._inner!r})'


class ShippingOption(TLObject):
    """
    Boxed TL type ``ShippingOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB6213CDF: types.ShippingOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ShippingOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_shipping_option(self) -> bool:
        return isinstance(self._inner, types.ShippingOption)

    def as_shipping_option(self) -> Optional[types.ShippingOption]:
        return self._inner if self.is_shipping_option() else None

    def __repr__(self) -> str:
        return f'ShippingOption({self._inner!r})'


class SmsJob(TLObject):
    """
    Boxed TL type ``SmsJob`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE6A1EEB8: types.SmsJob,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SmsJob':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sms_job(self) -> bool:
        return isinstance(self._inner, types.SmsJob)

    def as_sms_job(self) -> Optional[types.SmsJob]:
        return self._inner if self.is_sms_job() else None

    def __repr__(self) -> str:
        return f'SmsJob({self._inner!r})'


class SponsoredMessage(TLObject):
    """
    Boxed TL type ``SponsoredMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7DBF8673: types.SponsoredMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SponsoredMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sponsored_message(self) -> bool:
        return isinstance(self._inner, types.SponsoredMessage)

    def as_sponsored_message(self) -> Optional[types.SponsoredMessage]:
        return self._inner if self.is_sponsored_message() else None

    def __repr__(self) -> str:
        return f'SponsoredMessage({self._inner!r})'


class SponsoredMessageReportOption(TLObject):
    """
    Boxed TL type ``SponsoredMessageReportOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x430D3150: types.SponsoredMessageReportOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SponsoredMessageReportOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sponsored_message_report_option(self) -> bool:
        return isinstance(self._inner, types.SponsoredMessageReportOption)

    def as_sponsored_message_report_option(self) -> Optional[types.SponsoredMessageReportOption]:
        return self._inner if self.is_sponsored_message_report_option() else None

    def __repr__(self) -> str:
        return f'SponsoredMessageReportOption({self._inner!r})'


class SponsoredPeer(TLObject):
    """
    Boxed TL type ``SponsoredPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC69708D3: types.SponsoredPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SponsoredPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sponsored_peer(self) -> bool:
        return isinstance(self._inner, types.SponsoredPeer)

    def as_sponsored_peer(self) -> Optional[types.SponsoredPeer]:
        return self._inner if self.is_sponsored_peer() else None

    def __repr__(self) -> str:
        return f'SponsoredPeer({self._inner!r})'


class StarGift(TLObject):
    """
    Boxed TL type ``StarGift`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x313A9547: types.StarGift,
        0x85F0A9CD: types.StarGiftUnique,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGift':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift(self) -> bool:
        return isinstance(self._inner, types.StarGift)

    def as_star_gift(self) -> Optional[types.StarGift]:
        return self._inner if self.is_star_gift() else None

    def is_unique(self) -> bool:
        return isinstance(self._inner, types.StarGiftUnique)

    def as_unique(self) -> Optional[types.StarGiftUnique]:
        return self._inner if self.is_unique() else None

    def __repr__(self) -> str:
        return f'StarGift({self._inner!r})'


class StarGiftActiveAuctionState(TLObject):
    """
    Boxed TL type ``StarGiftActiveAuctionState`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD31BC45D: types.StarGiftActiveAuctionState,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftActiveAuctionState':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_active_auction_state(self) -> bool:
        return isinstance(self._inner, types.StarGiftActiveAuctionState)

    def as_star_gift_active_auction_state(self) -> Optional[types.StarGiftActiveAuctionState]:
        return self._inner if self.is_star_gift_active_auction_state() else None

    def __repr__(self) -> str:
        return f'StarGiftActiveAuctionState({self._inner!r})'


class StarGiftAttribute(TLObject):
    """
    Boxed TL type ``StarGiftAttribute`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x565251E2: types.StarGiftAttributeModel,
        0x4E7085EA: types.StarGiftAttributePattern,
        0x9F2504E4: types.StarGiftAttributeBackdrop,
        0xE0BFF26C: types.StarGiftAttributeOriginalDetails,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAttribute':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_model(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeModel)

    def as_model(self) -> Optional[types.StarGiftAttributeModel]:
        return self._inner if self.is_model() else None

    def is_pattern(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributePattern)

    def as_pattern(self) -> Optional[types.StarGiftAttributePattern]:
        return self._inner if self.is_pattern() else None

    def is_backdrop(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeBackdrop)

    def as_backdrop(self) -> Optional[types.StarGiftAttributeBackdrop]:
        return self._inner if self.is_backdrop() else None

    def is_original_details(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeOriginalDetails)

    def as_original_details(self) -> Optional[types.StarGiftAttributeOriginalDetails]:
        return self._inner if self.is_original_details() else None

    def __repr__(self) -> str:
        return f'StarGiftAttribute({self._inner!r})'


class StarGiftAttributeCounter(TLObject):
    """
    Boxed TL type ``StarGiftAttributeCounter`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2EB1B658: types.StarGiftAttributeCounter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAttributeCounter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_attribute_counter(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeCounter)

    def as_star_gift_attribute_counter(self) -> Optional[types.StarGiftAttributeCounter]:
        return self._inner if self.is_star_gift_attribute_counter() else None

    def __repr__(self) -> str:
        return f'StarGiftAttributeCounter({self._inner!r})'


class StarGiftAttributeId(TLObject):
    """
    Boxed TL type ``StarGiftAttributeId`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x48AAAE3C: types.StarGiftAttributeIdModel,
        0x4A162433: types.StarGiftAttributeIdPattern,
        0x1F01C757: types.StarGiftAttributeIdBackdrop,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAttributeId':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_model(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeIdModel)

    def as_model(self) -> Optional[types.StarGiftAttributeIdModel]:
        return self._inner if self.is_model() else None

    def is_pattern(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeIdPattern)

    def as_pattern(self) -> Optional[types.StarGiftAttributeIdPattern]:
        return self._inner if self.is_pattern() else None

    def is_backdrop(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeIdBackdrop)

    def as_backdrop(self) -> Optional[types.StarGiftAttributeIdBackdrop]:
        return self._inner if self.is_backdrop() else None

    def __repr__(self) -> str:
        return f'StarGiftAttributeId({self._inner!r})'


class StarGiftAttributeRarity(TLObject):
    """
    Boxed TL type ``StarGiftAttributeRarity`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x36437737: types.StarGiftAttributeRarity,
        0xDBCE6389: types.StarGiftAttributeRarityUncommon,
        0xF08D516B: types.StarGiftAttributeRarityRare,
        0x78FBF3A8: types.StarGiftAttributeRarityEpic,
        0xCEF7E7A8: types.StarGiftAttributeRarityLegendary,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAttributeRarity':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_attribute_rarity(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeRarity)

    def as_star_gift_attribute_rarity(self) -> Optional[types.StarGiftAttributeRarity]:
        return self._inner if self.is_star_gift_attribute_rarity() else None

    def is_uncommon(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeRarityUncommon)

    def as_uncommon(self) -> Optional[types.StarGiftAttributeRarityUncommon]:
        return self._inner if self.is_uncommon() else None

    def is_rare(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeRarityRare)

    def as_rare(self) -> Optional[types.StarGiftAttributeRarityRare]:
        return self._inner if self.is_rare() else None

    def is_epic(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeRarityEpic)

    def as_epic(self) -> Optional[types.StarGiftAttributeRarityEpic]:
        return self._inner if self.is_epic() else None

    def is_legendary(self) -> bool:
        return isinstance(self._inner, types.StarGiftAttributeRarityLegendary)

    def as_legendary(self) -> Optional[types.StarGiftAttributeRarityLegendary]:
        return self._inner if self.is_legendary() else None

    def __repr__(self) -> str:
        return f'StarGiftAttributeRarity({self._inner!r})'


class StarGiftAuctionAcquiredGift(TLObject):
    """
    Boxed TL type ``StarGiftAuctionAcquiredGift`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x42B00348: types.StarGiftAuctionAcquiredGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAuctionAcquiredGift':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_auction_acquired_gift(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionAcquiredGift)

    def as_star_gift_auction_acquired_gift(self) -> Optional[types.StarGiftAuctionAcquiredGift]:
        return self._inner if self.is_star_gift_auction_acquired_gift() else None

    def __repr__(self) -> str:
        return f'StarGiftAuctionAcquiredGift({self._inner!r})'


class StarGiftAuctionRound(TLObject):
    """
    Boxed TL type ``StarGiftAuctionRound`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3AAE0528: types.StarGiftAuctionRound,
        0x0AA021E5: types.StarGiftAuctionRoundExtendable,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAuctionRound':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_auction_round(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionRound)

    def as_star_gift_auction_round(self) -> Optional[types.StarGiftAuctionRound]:
        return self._inner if self.is_star_gift_auction_round() else None

    def is_extendable(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionRoundExtendable)

    def as_extendable(self) -> Optional[types.StarGiftAuctionRoundExtendable]:
        return self._inner if self.is_extendable() else None

    def __repr__(self) -> str:
        return f'StarGiftAuctionRound({self._inner!r})'


class StarGiftAuctionState(TLObject):
    """
    Boxed TL type ``StarGiftAuctionState`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFE333952: types.StarGiftAuctionStateNotModified,
        0x771A4E66: types.StarGiftAuctionState,
        0x972DABBF: types.StarGiftAuctionStateFinished,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAuctionState':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionStateNotModified)

    def as_not_modified(self) -> Optional[types.StarGiftAuctionStateNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_star_gift_auction_state(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionState)

    def as_star_gift_auction_state(self) -> Optional[types.StarGiftAuctionState]:
        return self._inner if self.is_star_gift_auction_state() else None

    def is_finished(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionStateFinished)

    def as_finished(self) -> Optional[types.StarGiftAuctionStateFinished]:
        return self._inner if self.is_finished() else None

    def __repr__(self) -> str:
        return f'StarGiftAuctionState({self._inner!r})'


class StarGiftAuctionUserState(TLObject):
    """
    Boxed TL type ``StarGiftAuctionUserState`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2EEED1C4: types.StarGiftAuctionUserState,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAuctionUserState':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_auction_user_state(self) -> bool:
        return isinstance(self._inner, types.StarGiftAuctionUserState)

    def as_star_gift_auction_user_state(self) -> Optional[types.StarGiftAuctionUserState]:
        return self._inner if self.is_star_gift_auction_user_state() else None

    def __repr__(self) -> str:
        return f'StarGiftAuctionUserState({self._inner!r})'


class StarGiftBackground(TLObject):
    """
    Boxed TL type ``StarGiftBackground`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAFF56398: types.StarGiftBackground,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftBackground':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_background(self) -> bool:
        return isinstance(self._inner, types.StarGiftBackground)

    def as_star_gift_background(self) -> Optional[types.StarGiftBackground]:
        return self._inner if self.is_star_gift_background() else None

    def __repr__(self) -> str:
        return f'StarGiftBackground({self._inner!r})'


class StarGiftCollection(TLObject):
    """
    Boxed TL type ``StarGiftCollection`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9D6B13B0: types.StarGiftCollection,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftCollection':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_collection(self) -> bool:
        return isinstance(self._inner, types.StarGiftCollection)

    def as_star_gift_collection(self) -> Optional[types.StarGiftCollection]:
        return self._inner if self.is_star_gift_collection() else None

    def __repr__(self) -> str:
        return f'StarGiftCollection({self._inner!r})'


class StarGiftUpgradePrice(TLObject):
    """
    Boxed TL type ``StarGiftUpgradePrice`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x99EA331D: types.StarGiftUpgradePrice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftUpgradePrice':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_upgrade_price(self) -> bool:
        return isinstance(self._inner, types.StarGiftUpgradePrice)

    def as_star_gift_upgrade_price(self) -> Optional[types.StarGiftUpgradePrice]:
        return self._inner if self.is_star_gift_upgrade_price() else None

    def __repr__(self) -> str:
        return f'StarGiftUpgradePrice({self._inner!r})'


class StarRefProgram(TLObject):
    """
    Boxed TL type ``StarRefProgram`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDD0C66F2: types.StarRefProgram,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarRefProgram':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_ref_program(self) -> bool:
        return isinstance(self._inner, types.StarRefProgram)

    def as_star_ref_program(self) -> Optional[types.StarRefProgram]:
        return self._inner if self.is_star_ref_program() else None

    def __repr__(self) -> str:
        return f'StarRefProgram({self._inner!r})'


class StarsAmount(TLObject):
    """
    Boxed TL type ``StarsAmount`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBBB6B4A3: types.StarsAmount,
        0x74AEE3E0: types.StarsTonAmount,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsAmount':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_amount(self) -> bool:
        return isinstance(self._inner, types.StarsAmount)

    def as_stars_amount(self) -> Optional[types.StarsAmount]:
        return self._inner if self.is_stars_amount() else None

    def is_stars_ton_amount(self) -> bool:
        return isinstance(self._inner, types.StarsTonAmount)

    def as_stars_ton_amount(self) -> Optional[types.StarsTonAmount]:
        return self._inner if self.is_stars_ton_amount() else None

    def __repr__(self) -> str:
        return f'StarsAmount({self._inner!r})'


class StarsGiftOption(TLObject):
    """
    Boxed TL type ``StarsGiftOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5E0589F1: types.StarsGiftOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsGiftOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_gift_option(self) -> bool:
        return isinstance(self._inner, types.StarsGiftOption)

    def as_stars_gift_option(self) -> Optional[types.StarsGiftOption]:
        return self._inner if self.is_stars_gift_option() else None

    def __repr__(self) -> str:
        return f'StarsGiftOption({self._inner!r})'


class StarsGiveawayOption(TLObject):
    """
    Boxed TL type ``StarsGiveawayOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x94CE852A: types.StarsGiveawayOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsGiveawayOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_giveaway_option(self) -> bool:
        return isinstance(self._inner, types.StarsGiveawayOption)

    def as_stars_giveaway_option(self) -> Optional[types.StarsGiveawayOption]:
        return self._inner if self.is_stars_giveaway_option() else None

    def __repr__(self) -> str:
        return f'StarsGiveawayOption({self._inner!r})'


class StarsGiveawayWinnersOption(TLObject):
    """
    Boxed TL type ``StarsGiveawayWinnersOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x54236209: types.StarsGiveawayWinnersOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsGiveawayWinnersOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_giveaway_winners_option(self) -> bool:
        return isinstance(self._inner, types.StarsGiveawayWinnersOption)

    def as_stars_giveaway_winners_option(self) -> Optional[types.StarsGiveawayWinnersOption]:
        return self._inner if self.is_stars_giveaway_winners_option() else None

    def __repr__(self) -> str:
        return f'StarsGiveawayWinnersOption({self._inner!r})'


class StarsRating(TLObject):
    """
    Boxed TL type ``StarsRating`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1B0E4F07: types.StarsRating,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsRating':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_rating(self) -> bool:
        return isinstance(self._inner, types.StarsRating)

    def as_stars_rating(self) -> Optional[types.StarsRating]:
        return self._inner if self.is_stars_rating() else None

    def __repr__(self) -> str:
        return f'StarsRating({self._inner!r})'


class StarsRevenueStatus(TLObject):
    """
    Boxed TL type ``StarsRevenueStatus`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFEBE5491: types.StarsRevenueStatus,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsRevenueStatus':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_revenue_status(self) -> bool:
        return isinstance(self._inner, types.StarsRevenueStatus)

    def as_stars_revenue_status(self) -> Optional[types.StarsRevenueStatus]:
        return self._inner if self.is_stars_revenue_status() else None

    def __repr__(self) -> str:
        return f'StarsRevenueStatus({self._inner!r})'


class StarsSubscription(TLObject):
    """
    Boxed TL type ``StarsSubscription`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2E6EAB1A: types.StarsSubscription,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsSubscription':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_subscription(self) -> bool:
        return isinstance(self._inner, types.StarsSubscription)

    def as_stars_subscription(self) -> Optional[types.StarsSubscription]:
        return self._inner if self.is_stars_subscription() else None

    def __repr__(self) -> str:
        return f'StarsSubscription({self._inner!r})'


class StarsSubscriptionPricing(TLObject):
    """
    Boxed TL type ``StarsSubscriptionPricing`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x05416D58: types.StarsSubscriptionPricing,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsSubscriptionPricing':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_subscription_pricing(self) -> bool:
        return isinstance(self._inner, types.StarsSubscriptionPricing)

    def as_stars_subscription_pricing(self) -> Optional[types.StarsSubscriptionPricing]:
        return self._inner if self.is_stars_subscription_pricing() else None

    def __repr__(self) -> str:
        return f'StarsSubscriptionPricing({self._inner!r})'


class StarsTopupOption(TLObject):
    """
    Boxed TL type ``StarsTopupOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0BD915C0: types.StarsTopupOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsTopupOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_topup_option(self) -> bool:
        return isinstance(self._inner, types.StarsTopupOption)

    def as_stars_topup_option(self) -> Optional[types.StarsTopupOption]:
        return self._inner if self.is_stars_topup_option() else None

    def __repr__(self) -> str:
        return f'StarsTopupOption({self._inner!r})'


class StarsTransaction(TLObject):
    """
    Boxed TL type ``StarsTransaction`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x13659EB0: types.StarsTransaction,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsTransaction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_transaction(self) -> bool:
        return isinstance(self._inner, types.StarsTransaction)

    def as_stars_transaction(self) -> Optional[types.StarsTransaction]:
        return self._inner if self.is_stars_transaction() else None

    def __repr__(self) -> str:
        return f'StarsTransaction({self._inner!r})'


class StarsTransactionPeer(TLObject):
    """
    Boxed TL type ``StarsTransactionPeer`` — union of 8 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x95F2BFE4: types.StarsTransactionPeerUnsupported,
        0xB457B375: types.StarsTransactionPeerAppStore,
        0x7B560A0B: types.StarsTransactionPeerPlayMarket,
        0x250DBAF8: types.StarsTransactionPeerPremiumBot,
        0xE92FD902: types.StarsTransactionPeerFragment,
        0xD80DA15D: types.StarsTransactionPeer,
        0x60682812: types.StarsTransactionPeerAds,
        0xF9677AAD: types.StarsTransactionPeerApi,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsTransactionPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unsupported(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerUnsupported)

    def as_unsupported(self) -> Optional[types.StarsTransactionPeerUnsupported]:
        return self._inner if self.is_unsupported() else None

    def is_app_store(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerAppStore)

    def as_app_store(self) -> Optional[types.StarsTransactionPeerAppStore]:
        return self._inner if self.is_app_store() else None

    def is_play_market(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerPlayMarket)

    def as_play_market(self) -> Optional[types.StarsTransactionPeerPlayMarket]:
        return self._inner if self.is_play_market() else None

    def is_premium_bot(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerPremiumBot)

    def as_premium_bot(self) -> Optional[types.StarsTransactionPeerPremiumBot]:
        return self._inner if self.is_premium_bot() else None

    def is_fragment(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerFragment)

    def as_fragment(self) -> Optional[types.StarsTransactionPeerFragment]:
        return self._inner if self.is_fragment() else None

    def is_stars_transaction_peer(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeer)

    def as_stars_transaction_peer(self) -> Optional[types.StarsTransactionPeer]:
        return self._inner if self.is_stars_transaction_peer() else None

    def is_ads(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerAds)

    def as_ads(self) -> Optional[types.StarsTransactionPeerAds]:
        return self._inner if self.is_ads() else None

    def is_api(self) -> bool:
        return isinstance(self._inner, types.StarsTransactionPeerApi)

    def as_api(self) -> Optional[types.StarsTransactionPeerApi]:
        return self._inner if self.is_api() else None

    def __repr__(self) -> str:
        return f'StarsTransactionPeer({self._inner!r})'


class StatsAbsValueAndPrev(TLObject):
    """
    Boxed TL type ``StatsAbsValueAndPrev`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCB43ACDE: types.StatsAbsValueAndPrev,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsAbsValueAndPrev':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_abs_value_and_prev(self) -> bool:
        return isinstance(self._inner, types.StatsAbsValueAndPrev)

    def as_stats_abs_value_and_prev(self) -> Optional[types.StatsAbsValueAndPrev]:
        return self._inner if self.is_stats_abs_value_and_prev() else None

    def __repr__(self) -> str:
        return f'StatsAbsValueAndPrev({self._inner!r})'


class StatsDateRangeDays(TLObject):
    """
    Boxed TL type ``StatsDateRangeDays`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB637EDAF: types.StatsDateRangeDays,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsDateRangeDays':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_date_range_days(self) -> bool:
        return isinstance(self._inner, types.StatsDateRangeDays)

    def as_stats_date_range_days(self) -> Optional[types.StatsDateRangeDays]:
        return self._inner if self.is_stats_date_range_days() else None

    def __repr__(self) -> str:
        return f'StatsDateRangeDays({self._inner!r})'


class StatsGraph(TLObject):
    """
    Boxed TL type ``StatsGraph`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4A27EB2D: types.StatsGraphAsync,
        0xBEDC9822: types.StatsGraphError,
        0x8EA464B6: types.StatsGraph,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsGraph':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_async(self) -> bool:
        return isinstance(self._inner, types.StatsGraphAsync)

    def as_async(self) -> Optional[types.StatsGraphAsync]:
        return self._inner if self.is_async() else None

    def is_error(self) -> bool:
        return isinstance(self._inner, types.StatsGraphError)

    def as_error(self) -> Optional[types.StatsGraphError]:
        return self._inner if self.is_error() else None

    def is_stats_graph(self) -> bool:
        return isinstance(self._inner, types.StatsGraph)

    def as_stats_graph(self) -> Optional[types.StatsGraph]:
        return self._inner if self.is_stats_graph() else None

    def __repr__(self) -> str:
        return f'StatsGraph({self._inner!r})'


class StatsGroupTopAdmin(TLObject):
    """
    Boxed TL type ``StatsGroupTopAdmin`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD7584C87: types.StatsGroupTopAdmin,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsGroupTopAdmin':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_group_top_admin(self) -> bool:
        return isinstance(self._inner, types.StatsGroupTopAdmin)

    def as_stats_group_top_admin(self) -> Optional[types.StatsGroupTopAdmin]:
        return self._inner if self.is_stats_group_top_admin() else None

    def __repr__(self) -> str:
        return f'StatsGroupTopAdmin({self._inner!r})'


class StatsGroupTopInviter(TLObject):
    """
    Boxed TL type ``StatsGroupTopInviter`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x535F779D: types.StatsGroupTopInviter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsGroupTopInviter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_group_top_inviter(self) -> bool:
        return isinstance(self._inner, types.StatsGroupTopInviter)

    def as_stats_group_top_inviter(self) -> Optional[types.StatsGroupTopInviter]:
        return self._inner if self.is_stats_group_top_inviter() else None

    def __repr__(self) -> str:
        return f'StatsGroupTopInviter({self._inner!r})'


class StatsGroupTopPoster(TLObject):
    """
    Boxed TL type ``StatsGroupTopPoster`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9D04AF9B: types.StatsGroupTopPoster,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsGroupTopPoster':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_group_top_poster(self) -> bool:
        return isinstance(self._inner, types.StatsGroupTopPoster)

    def as_stats_group_top_poster(self) -> Optional[types.StatsGroupTopPoster]:
        return self._inner if self.is_stats_group_top_poster() else None

    def __repr__(self) -> str:
        return f'StatsGroupTopPoster({self._inner!r})'


class StatsPercentValue(TLObject):
    """
    Boxed TL type ``StatsPercentValue`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCBCE2FE0: types.StatsPercentValue,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsPercentValue':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_percent_value(self) -> bool:
        return isinstance(self._inner, types.StatsPercentValue)

    def as_stats_percent_value(self) -> Optional[types.StatsPercentValue]:
        return self._inner if self.is_stats_percent_value() else None

    def __repr__(self) -> str:
        return f'StatsPercentValue({self._inner!r})'


class StatsUrl(TLObject):
    """
    Boxed TL type ``StatsURL`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x47A971E0: types.StatsUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StatsUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stats_url(self) -> bool:
        return isinstance(self._inner, types.StatsUrl)

    def as_stats_url(self) -> Optional[types.StatsUrl]:
        return self._inner if self.is_stats_url() else None

    def __repr__(self) -> str:
        return f'StatsUrl({self._inner!r})'


class StickerKeyword(TLObject):
    """
    Boxed TL type ``StickerKeyword`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFCFEB29C: types.StickerKeyword,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StickerKeyword':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sticker_keyword(self) -> bool:
        return isinstance(self._inner, types.StickerKeyword)

    def as_sticker_keyword(self) -> Optional[types.StickerKeyword]:
        return self._inner if self.is_sticker_keyword() else None

    def __repr__(self) -> str:
        return f'StickerKeyword({self._inner!r})'


class StickerPack(TLObject):
    """
    Boxed TL type ``StickerPack`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x12B299D4: types.StickerPack,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StickerPack':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sticker_pack(self) -> bool:
        return isinstance(self._inner, types.StickerPack)

    def as_sticker_pack(self) -> Optional[types.StickerPack]:
        return self._inner if self.is_sticker_pack() else None

    def __repr__(self) -> str:
        return f'StickerPack({self._inner!r})'


class StickerSet(TLObject):
    """
    Boxed TL type ``StickerSet`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2DD14EDC: types.StickerSet,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StickerSet':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sticker_set(self) -> bool:
        return isinstance(self._inner, types.StickerSet)

    def as_sticker_set(self) -> Optional[types.StickerSet]:
        return self._inner if self.is_sticker_set() else None

    def __repr__(self) -> str:
        return f'StickerSet({self._inner!r})'


class StickerSetCovered(TLObject):
    """
    Boxed TL type ``StickerSetCovered`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6410A5D2: types.StickerSetCovered,
        0x3407E51B: types.StickerSetMultiCovered,
        0x40D13C0E: types.StickerSetFullCovered,
        0x77B15D1C: types.StickerSetNoCovered,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StickerSetCovered':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sticker_set_covered(self) -> bool:
        return isinstance(self._inner, types.StickerSetCovered)

    def as_sticker_set_covered(self) -> Optional[types.StickerSetCovered]:
        return self._inner if self.is_sticker_set_covered() else None

    def is_sticker_set_multi_covered(self) -> bool:
        return isinstance(self._inner, types.StickerSetMultiCovered)

    def as_sticker_set_multi_covered(self) -> Optional[types.StickerSetMultiCovered]:
        return self._inner if self.is_sticker_set_multi_covered() else None

    def is_sticker_set_full_covered(self) -> bool:
        return isinstance(self._inner, types.StickerSetFullCovered)

    def as_sticker_set_full_covered(self) -> Optional[types.StickerSetFullCovered]:
        return self._inner if self.is_sticker_set_full_covered() else None

    def is_sticker_set_no_covered(self) -> bool:
        return isinstance(self._inner, types.StickerSetNoCovered)

    def as_sticker_set_no_covered(self) -> Optional[types.StickerSetNoCovered]:
        return self._inner if self.is_sticker_set_no_covered() else None

    def __repr__(self) -> str:
        return f'StickerSetCovered({self._inner!r})'


class StoriesStealthMode(TLObject):
    """
    Boxed TL type ``StoriesStealthMode`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x712E27FD: types.StoriesStealthMode,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoriesStealthMode':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stories_stealth_mode(self) -> bool:
        return isinstance(self._inner, types.StoriesStealthMode)

    def as_stories_stealth_mode(self) -> Optional[types.StoriesStealthMode]:
        return self._inner if self.is_stories_stealth_mode() else None

    def __repr__(self) -> str:
        return f'StoriesStealthMode({self._inner!r})'


class StoryAlbum(TLObject):
    """
    Boxed TL type ``StoryAlbum`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9325705A: types.StoryAlbum,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryAlbum':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_album(self) -> bool:
        return isinstance(self._inner, types.StoryAlbum)

    def as_story_album(self) -> Optional[types.StoryAlbum]:
        return self._inner if self.is_story_album() else None

    def __repr__(self) -> str:
        return f'StoryAlbum({self._inner!r})'


class StoryFwdHeader(TLObject):
    """
    Boxed TL type ``StoryFwdHeader`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB826E150: types.StoryFwdHeader,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryFwdHeader':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_fwd_header(self) -> bool:
        return isinstance(self._inner, types.StoryFwdHeader)

    def as_story_fwd_header(self) -> Optional[types.StoryFwdHeader]:
        return self._inner if self.is_story_fwd_header() else None

    def __repr__(self) -> str:
        return f'StoryFwdHeader({self._inner!r})'


class StoryItem(TLObject):
    """
    Boxed TL type ``StoryItem`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x51E6EE4F: types.StoryItemDeleted,
        0xFFADC913: types.StoryItemSkipped,
        0xEDF164F1: types.StoryItem,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryItem':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_deleted(self) -> bool:
        return isinstance(self._inner, types.StoryItemDeleted)

    def as_deleted(self) -> Optional[types.StoryItemDeleted]:
        return self._inner if self.is_deleted() else None

    def is_skipped(self) -> bool:
        return isinstance(self._inner, types.StoryItemSkipped)

    def as_skipped(self) -> Optional[types.StoryItemSkipped]:
        return self._inner if self.is_skipped() else None

    def is_story_item(self) -> bool:
        return isinstance(self._inner, types.StoryItem)

    def as_story_item(self) -> Optional[types.StoryItem]:
        return self._inner if self.is_story_item() else None

    def __repr__(self) -> str:
        return f'StoryItem({self._inner!r})'


class StoryReaction(TLObject):
    """
    Boxed TL type ``StoryReaction`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6090D6D5: types.StoryReaction,
        0xBBAB2643: types.StoryReactionPublicForward,
        0xCFCD0F13: types.StoryReactionPublicRepost,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryReaction':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_reaction(self) -> bool:
        return isinstance(self._inner, types.StoryReaction)

    def as_story_reaction(self) -> Optional[types.StoryReaction]:
        return self._inner if self.is_story_reaction() else None

    def is_public_forward(self) -> bool:
        return isinstance(self._inner, types.StoryReactionPublicForward)

    def as_public_forward(self) -> Optional[types.StoryReactionPublicForward]:
        return self._inner if self.is_public_forward() else None

    def is_public_repost(self) -> bool:
        return isinstance(self._inner, types.StoryReactionPublicRepost)

    def as_public_repost(self) -> Optional[types.StoryReactionPublicRepost]:
        return self._inner if self.is_public_repost() else None

    def __repr__(self) -> str:
        return f'StoryReaction({self._inner!r})'


class StoryView(TLObject):
    """
    Boxed TL type ``StoryView`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB0BDEAC5: types.StoryView,
        0x9083670B: types.StoryViewPublicForward,
        0xBD74CF49: types.StoryViewPublicRepost,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryView':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_view(self) -> bool:
        return isinstance(self._inner, types.StoryView)

    def as_story_view(self) -> Optional[types.StoryView]:
        return self._inner if self.is_story_view() else None

    def is_public_forward(self) -> bool:
        return isinstance(self._inner, types.StoryViewPublicForward)

    def as_public_forward(self) -> Optional[types.StoryViewPublicForward]:
        return self._inner if self.is_public_forward() else None

    def is_public_repost(self) -> bool:
        return isinstance(self._inner, types.StoryViewPublicRepost)

    def as_public_repost(self) -> Optional[types.StoryViewPublicRepost]:
        return self._inner if self.is_public_repost() else None

    def __repr__(self) -> str:
        return f'StoryView({self._inner!r})'


class StoryViews(TLObject):
    """
    Boxed TL type ``StoryViews`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8D595CD6: types.StoryViews,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryViews':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_views(self) -> bool:
        return isinstance(self._inner, types.StoryViews)

    def as_story_views(self) -> Optional[types.StoryViews]:
        return self._inner if self.is_story_views() else None

    def __repr__(self) -> str:
        return f'StoryViews({self._inner!r})'


class SuggestedPost(TLObject):
    """
    Boxed TL type ``SuggestedPost`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0E8E37E5: types.SuggestedPost,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SuggestedPost':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_suggested_post(self) -> bool:
        return isinstance(self._inner, types.SuggestedPost)

    def as_suggested_post(self) -> Optional[types.SuggestedPost]:
        return self._inner if self.is_suggested_post() else None

    def __repr__(self) -> str:
        return f'SuggestedPost({self._inner!r})'


class TextWithEntities(TLObject):
    """
    Boxed TL type ``TextWithEntities`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x751F3146: types.TextWithEntities,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TextWithEntities':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_text_with_entities(self) -> bool:
        return isinstance(self._inner, types.TextWithEntities)

    def as_text_with_entities(self) -> Optional[types.TextWithEntities]:
        return self._inner if self.is_text_with_entities() else None

    def __repr__(self) -> str:
        return f'TextWithEntities({self._inner!r})'


class Theme(TLObject):
    """
    Boxed TL type ``Theme`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA00E67D6: types.Theme,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Theme':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_theme(self) -> bool:
        return isinstance(self._inner, types.Theme)

    def as_theme(self) -> Optional[types.Theme]:
        return self._inner if self.is_theme() else None

    def __repr__(self) -> str:
        return f'Theme({self._inner!r})'


class ThemeSettings(TLObject):
    """
    Boxed TL type ``ThemeSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFA58B6D4: types.ThemeSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ThemeSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_theme_settings(self) -> bool:
        return isinstance(self._inner, types.ThemeSettings)

    def as_theme_settings(self) -> Optional[types.ThemeSettings]:
        return self._inner if self.is_theme_settings() else None

    def __repr__(self) -> str:
        return f'ThemeSettings({self._inner!r})'


class Timezone(TLObject):
    """
    Boxed TL type ``Timezone`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFF9289F5: types.Timezone,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Timezone':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_timezone(self) -> bool:
        return isinstance(self._inner, types.Timezone)

    def as_timezone(self) -> Optional[types.Timezone]:
        return self._inner if self.is_timezone() else None

    def __repr__(self) -> str:
        return f'Timezone({self._inner!r})'


class TodoCompletion(TLObject):
    """
    Boxed TL type ``TodoCompletion`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x221BB5E4: types.TodoCompletion,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TodoCompletion':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_todo_completion(self) -> bool:
        return isinstance(self._inner, types.TodoCompletion)

    def as_todo_completion(self) -> Optional[types.TodoCompletion]:
        return self._inner if self.is_todo_completion() else None

    def __repr__(self) -> str:
        return f'TodoCompletion({self._inner!r})'


class TodoItem(TLObject):
    """
    Boxed TL type ``TodoItem`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCBA9A52F: types.TodoItem,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TodoItem':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_todo_item(self) -> bool:
        return isinstance(self._inner, types.TodoItem)

    def as_todo_item(self) -> Optional[types.TodoItem]:
        return self._inner if self.is_todo_item() else None

    def __repr__(self) -> str:
        return f'TodoItem({self._inner!r})'


class TodoList(TLObject):
    """
    Boxed TL type ``TodoList`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x49B92A26: types.TodoList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TodoList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_todo_list(self) -> bool:
        return isinstance(self._inner, types.TodoList)

    def as_todo_list(self) -> Optional[types.TodoList]:
        return self._inner if self.is_todo_list() else None

    def __repr__(self) -> str:
        return f'TodoList({self._inner!r})'


class TopPeer(TLObject):
    """
    Boxed TL type ``TopPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEDCDC05B: types.TopPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TopPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_top_peer(self) -> bool:
        return isinstance(self._inner, types.TopPeer)

    def as_top_peer(self) -> Optional[types.TopPeer]:
        return self._inner if self.is_top_peer() else None

    def __repr__(self) -> str:
        return f'TopPeer({self._inner!r})'


class TopPeerCategory(TLObject):
    """
    Boxed TL type ``TopPeerCategory`` — union of 9 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAB661B5B: types.TopPeerCategoryBotsPm,
        0x148677E2: types.TopPeerCategoryBotsInline,
        0x0637B7ED: types.TopPeerCategoryCorrespondents,
        0xBD17A14A: types.TopPeerCategoryGroups,
        0x161D9628: types.TopPeerCategoryChannels,
        0x1E76A78C: types.TopPeerCategoryPhoneCalls,
        0xA8406CA9: types.TopPeerCategoryForwardUsers,
        0xFBEEC0F0: types.TopPeerCategoryForwardChats,
        0xFD9E7BEC: types.TopPeerCategoryBotsApp,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TopPeerCategory':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bots_pm(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryBotsPm)

    def as_bots_pm(self) -> Optional[types.TopPeerCategoryBotsPm]:
        return self._inner if self.is_bots_pm() else None

    def is_bots_inline(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryBotsInline)

    def as_bots_inline(self) -> Optional[types.TopPeerCategoryBotsInline]:
        return self._inner if self.is_bots_inline() else None

    def is_correspondents(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryCorrespondents)

    def as_correspondents(self) -> Optional[types.TopPeerCategoryCorrespondents]:
        return self._inner if self.is_correspondents() else None

    def is_groups(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryGroups)

    def as_groups(self) -> Optional[types.TopPeerCategoryGroups]:
        return self._inner if self.is_groups() else None

    def is_channels(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryChannels)

    def as_channels(self) -> Optional[types.TopPeerCategoryChannels]:
        return self._inner if self.is_channels() else None

    def is_phone_calls(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryPhoneCalls)

    def as_phone_calls(self) -> Optional[types.TopPeerCategoryPhoneCalls]:
        return self._inner if self.is_phone_calls() else None

    def is_forward_users(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryForwardUsers)

    def as_forward_users(self) -> Optional[types.TopPeerCategoryForwardUsers]:
        return self._inner if self.is_forward_users() else None

    def is_forward_chats(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryForwardChats)

    def as_forward_chats(self) -> Optional[types.TopPeerCategoryForwardChats]:
        return self._inner if self.is_forward_chats() else None

    def is_bots_app(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryBotsApp)

    def as_bots_app(self) -> Optional[types.TopPeerCategoryBotsApp]:
        return self._inner if self.is_bots_app() else None

    def __repr__(self) -> str:
        return f'TopPeerCategory({self._inner!r})'


class TopPeerCategoryPeers(TLObject):
    """
    Boxed TL type ``TopPeerCategoryPeers`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFB834291: types.TopPeerCategoryPeers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TopPeerCategoryPeers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_top_peer_category_peers(self) -> bool:
        return isinstance(self._inner, types.TopPeerCategoryPeers)

    def as_top_peer_category_peers(self) -> Optional[types.TopPeerCategoryPeers]:
        return self._inner if self.is_top_peer_category_peers() else None

    def __repr__(self) -> str:
        return f'TopPeerCategoryPeers({self._inner!r})'


class Update(TLObject):
    """
    Boxed TL type ``Update`` — union of 152 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1F2B0AFD: types.UpdateNewMessage,
        0x4E90BFD6: types.UpdateMessageId,
        0xA20DB0E5: types.UpdateDeleteMessages,
        0x2A17BF5C: types.UpdateUserTyping,
        0x83487AF0: types.UpdateChatUserTyping,
        0x07761198: types.UpdateChatParticipants,
        0xE5BDF8DE: types.UpdateUserStatus,
        0xA7848924: types.UpdateUserName,
        0x8951ABEF: types.UpdateNewAuthorization,
        0x12BCBD9A: types.UpdateNewEncryptedMessage,
        0x1710F156: types.UpdateEncryptedChatTyping,
        0xB4A2E88D: types.UpdateEncryption,
        0x38FE25B7: types.UpdateEncryptedMessagesRead,
        0x3DDA5451: types.UpdateChatParticipantAdd,
        0xE32F3D77: types.UpdateChatParticipantDelete,
        0x8E5E9873: types.UpdateDcOptions,
        0xBEC268EF: types.UpdateNotifySettings,
        0xEBE46819: types.UpdateServiceNotification,
        0xEE3B272A: types.UpdatePrivacy,
        0x05492A13: types.UpdateUserPhone,
        0x9E84BC99: types.UpdateReadHistoryInbox,
        0x2F2F21BF: types.UpdateReadHistoryOutbox,
        0x7F891213: types.UpdateWebPage,
        0xF8227181: types.UpdateReadMessagesContents,
        0x108D941F: types.UpdateChannelTooLong,
        0x635B4C09: types.UpdateChannel,
        0x62BA04D9: types.UpdateNewChannelMessage,
        0x922E6E10: types.UpdateReadChannelInbox,
        0xC32D5B12: types.UpdateDeleteChannelMessages,
        0xF226AC08: types.UpdateChannelMessageViews,
        0xD7CA61A2: types.UpdateChatParticipantAdmin,
        0x688A30AA: types.UpdateNewStickerSet,
        0x0BB2D201: types.UpdateStickerSetsOrder,
        0x31C24808: types.UpdateStickerSets,
        0x9375341E: types.UpdateSavedGifs,
        0x496F379C: types.UpdateBotInlineQuery,
        0x12F12A07: types.UpdateBotInlineSend,
        0x1B3F4DF7: types.UpdateEditChannelMessage,
        0xB9CFC48D: types.UpdateBotCallbackQuery,
        0xE40370A3: types.UpdateEditMessage,
        0x691E9052: types.UpdateInlineBotCallbackQuery,
        0xB75F99A9: types.UpdateReadChannelOutbox,
        0xEDFC111E: types.UpdateDraftMessage,
        0x571D2742: types.UpdateReadFeaturedStickers,
        0x9A422C20: types.UpdateRecentStickers,
        0xA229DD06: types.UpdateConfig,
        0x3354678F: types.UpdatePtsChanged,
        0x2F2BA99F: types.UpdateChannelWebPage,
        0x6E6FE51C: types.UpdateDialogPinned,
        0xFA0F3CA2: types.UpdatePinnedDialogs,
        0x8317C0C3: types.UpdateBotWebhookJson,
        0x9B9240A6: types.UpdateBotWebhookJsonquery,
        0xB5AEFD7D: types.UpdateBotShippingQuery,
        0x8CAA9A96: types.UpdateBotPrecheckoutQuery,
        0xAB0F6B1E: types.UpdatePhoneCall,
        0x46560264: types.UpdateLangPackTooLong,
        0x56022F4D: types.UpdateLangPack,
        0xE511996D: types.UpdateFavedStickers,
        0x25F324F7: types.UpdateChannelReadMessagesContents,
        0x7084A7BE: types.UpdateContactsReset,
        0xB23FC698: types.UpdateChannelAvailableMessages,
        0xB658F23E: types.UpdateDialogUnreadMark,
        0xACA1657B: types.UpdateMessagePoll,
        0x54C01850: types.UpdateChatDefaultBannedRights,
        0x19360DC0: types.UpdateFolderPeers,
        0x6A7E7366: types.UpdatePeerSettings,
        0xB4AFCFB0: types.UpdatePeerLocated,
        0x39A51DFB: types.UpdateNewScheduledMessage,
        0xF2A71983: types.UpdateDeleteScheduledMessages,
        0x8216FBA3: types.UpdateTheme,
        0x871FB939: types.UpdateGeoLiveViewed,
        0x564FE691: types.UpdateLoginToken,
        0x24F40E77: types.UpdateMessagePollVote,
        0x26FFDE7D: types.UpdateDialogFilter,
        0xA5D72105: types.UpdateDialogFilterOrder,
        0x3504914F: types.UpdateDialogFilters,
        0x2661BF09: types.UpdatePhoneCallSignalingData,
        0xD29A27F4: types.UpdateChannelMessageForwards,
        0xD6B19546: types.UpdateReadChannelDiscussionInbox,
        0x695C9E7C: types.UpdateReadChannelDiscussionOutbox,
        0xEBE07752: types.UpdatePeerBlocked,
        0x8C88C923: types.UpdateChannelUserTyping,
        0xED85EAB5: types.UpdatePinnedMessages,
        0x5BB98608: types.UpdatePinnedChannelMessages,
        0xF89A6A4E: types.UpdateChat,
        0xF2EBDB4E: types.UpdateGroupCallParticipants,
        0x9D2216E0: types.UpdateGroupCall,
        0xBB9BB9A5: types.UpdatePeerHistoryTtl,
        0xD087663A: types.UpdateChatParticipant,
        0x985D3ABB: types.UpdateChannelParticipant,
        0xC4870A49: types.UpdateBotStopped,
        0x0B783982: types.UpdateGroupCallConnection,
        0x4D712F2E: types.UpdateBotCommands,
        0x7063C3DB: types.UpdatePendingJoinRequests,
        0x11DFA986: types.UpdateBotChatInviteRequester,
        0x1E297BFA: types.UpdateMessageReactions,
        0x17B7A20B: types.UpdateAttachMenuBots,
        0x1592B79D: types.UpdateWebViewResultSent,
        0x14B85813: types.UpdateBotMenuButton,
        0x74D8BE99: types.UpdateSavedRingtones,
        0x0084CD5A: types.UpdateTranscribedAudio,
        0xFB4C496C: types.UpdateReadFeaturedEmojiStickers,
        0x28373599: types.UpdateUserEmojiStatus,
        0x30F443DB: types.UpdateRecentEmojiStatuses,
        0x6F7863F4: types.UpdateRecentReactions,
        0x86FCCF85: types.UpdateMoveStickerSetToTop,
        0xD5A41724: types.UpdateMessageExtendedMedia,
        0x20529438: types.UpdateUser,
        0xEC05B097: types.UpdateAutoSaveSettings,
        0x75B3B798: types.UpdateStory,
        0xF74E932B: types.UpdateReadStories,
        0x1BF335B9: types.UpdateStoryId,
        0x2C084DC1: types.UpdateStoriesStealthMode,
        0x7D627683: types.UpdateSentStoryReaction,
        0x904DD49C: types.UpdateBotChatBoost,
        0x07B68920: types.UpdateChannelViewForumAsMessages,
        0xAE3F101D: types.UpdatePeerWallpaper,
        0xAC21D3CE: types.UpdateBotMessageReaction,
        0x09CB7759: types.UpdateBotMessageReactions,
        0xAEAF9E74: types.UpdateSavedDialogPinned,
        0x686C85A6: types.UpdatePinnedSavedDialogs,
        0x39C67432: types.UpdateSavedReactionTags,
        0xF16269D4: types.UpdateSmsJob,
        0xF9470AB2: types.UpdateQuickReplies,
        0xF53DA717: types.UpdateNewQuickReply,
        0x53E6F1EC: types.UpdateDeleteQuickReply,
        0x3E050D0F: types.UpdateQuickReplyMessage,
        0x566FE7CD: types.UpdateDeleteQuickReplyMessages,
        0x8AE5C97A: types.UpdateBotBusinessConnect,
        0x9DDB347C: types.UpdateBotNewBusinessMessage,
        0x07DF587C: types.UpdateBotEditBusinessMessage,
        0xA02A982E: types.UpdateBotDeleteBusinessMessage,
        0x1824E40B: types.UpdateNewStoryReaction,
        0x4E80A379: types.UpdateStarsBalance,
        0x1EA2FDA7: types.UpdateBusinessBotCallbackQuery,
        0xA584B019: types.UpdateStarsRevenueStatus,
        0x283BD312: types.UpdateBotPurchasedPaidMedia,
        0x8B725FCE: types.UpdatePaidReactionPrivacy,
        0x504AA18F: types.UpdateSentPhoneCode,
        0xA477288F: types.UpdateGroupCallChainBlocks,
        0x77B0E372: types.UpdateReadMonoForumInbox,
        0xA4A79376: types.UpdateReadMonoForumOutbox,
        0x9F812B08: types.UpdateMonoForumNoPaidException,
        0xD8326F0D: types.UpdateGroupCallMessage,
        0xC957A766: types.UpdateGroupCallEncryptedMessage,
        0x683B2C52: types.UpdatePinnedForumTopic,
        0xDEF143D0: types.UpdatePinnedForumTopics,
        0x3E85E92C: types.UpdateDeleteGroupCallMessages,
        0x48E246C2: types.UpdateStarGiftAuctionState,
        0xDC58F31E: types.UpdateStarGiftAuctionUserState,
        0xFB9C547A: types.UpdateEmojiGameInfo,
        0xAC072444: types.UpdateStarGiftCraftFail,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Update':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_new_message(self) -> bool:
        return isinstance(self._inner, types.UpdateNewMessage)

    def as_new_message(self) -> Optional[types.UpdateNewMessage]:
        return self._inner if self.is_new_message() else None

    def is_message_id(self) -> bool:
        return isinstance(self._inner, types.UpdateMessageId)

    def as_message_id(self) -> Optional[types.UpdateMessageId]:
        return self._inner if self.is_message_id() else None

    def is_delete_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateDeleteMessages)

    def as_delete_messages(self) -> Optional[types.UpdateDeleteMessages]:
        return self._inner if self.is_delete_messages() else None

    def is_user_typing(self) -> bool:
        return isinstance(self._inner, types.UpdateUserTyping)

    def as_user_typing(self) -> Optional[types.UpdateUserTyping]:
        return self._inner if self.is_user_typing() else None

    def is_chat_user_typing(self) -> bool:
        return isinstance(self._inner, types.UpdateChatUserTyping)

    def as_chat_user_typing(self) -> Optional[types.UpdateChatUserTyping]:
        return self._inner if self.is_chat_user_typing() else None

    def is_chat_participants(self) -> bool:
        return isinstance(self._inner, types.UpdateChatParticipants)

    def as_chat_participants(self) -> Optional[types.UpdateChatParticipants]:
        return self._inner if self.is_chat_participants() else None

    def is_user_status(self) -> bool:
        return isinstance(self._inner, types.UpdateUserStatus)

    def as_user_status(self) -> Optional[types.UpdateUserStatus]:
        return self._inner if self.is_user_status() else None

    def is_user_name(self) -> bool:
        return isinstance(self._inner, types.UpdateUserName)

    def as_user_name(self) -> Optional[types.UpdateUserName]:
        return self._inner if self.is_user_name() else None

    def is_new_authorization(self) -> bool:
        return isinstance(self._inner, types.UpdateNewAuthorization)

    def as_new_authorization(self) -> Optional[types.UpdateNewAuthorization]:
        return self._inner if self.is_new_authorization() else None

    def is_new_encrypted_message(self) -> bool:
        return isinstance(self._inner, types.UpdateNewEncryptedMessage)

    def as_new_encrypted_message(self) -> Optional[types.UpdateNewEncryptedMessage]:
        return self._inner if self.is_new_encrypted_message() else None

    def is_encrypted_chat_typing(self) -> bool:
        return isinstance(self._inner, types.UpdateEncryptedChatTyping)

    def as_encrypted_chat_typing(self) -> Optional[types.UpdateEncryptedChatTyping]:
        return self._inner if self.is_encrypted_chat_typing() else None

    def is_encryption(self) -> bool:
        return isinstance(self._inner, types.UpdateEncryption)

    def as_encryption(self) -> Optional[types.UpdateEncryption]:
        return self._inner if self.is_encryption() else None

    def is_encrypted_messages_read(self) -> bool:
        return isinstance(self._inner, types.UpdateEncryptedMessagesRead)

    def as_encrypted_messages_read(self) -> Optional[types.UpdateEncryptedMessagesRead]:
        return self._inner if self.is_encrypted_messages_read() else None

    def is_chat_participant_add(self) -> bool:
        return isinstance(self._inner, types.UpdateChatParticipantAdd)

    def as_chat_participant_add(self) -> Optional[types.UpdateChatParticipantAdd]:
        return self._inner if self.is_chat_participant_add() else None

    def is_chat_participant_delete(self) -> bool:
        return isinstance(self._inner, types.UpdateChatParticipantDelete)

    def as_chat_participant_delete(self) -> Optional[types.UpdateChatParticipantDelete]:
        return self._inner if self.is_chat_participant_delete() else None

    def is_dc_options(self) -> bool:
        return isinstance(self._inner, types.UpdateDcOptions)

    def as_dc_options(self) -> Optional[types.UpdateDcOptions]:
        return self._inner if self.is_dc_options() else None

    def is_notify_settings(self) -> bool:
        return isinstance(self._inner, types.UpdateNotifySettings)

    def as_notify_settings(self) -> Optional[types.UpdateNotifySettings]:
        return self._inner if self.is_notify_settings() else None

    def is_service_notification(self) -> bool:
        return isinstance(self._inner, types.UpdateServiceNotification)

    def as_service_notification(self) -> Optional[types.UpdateServiceNotification]:
        return self._inner if self.is_service_notification() else None

    def is_privacy(self) -> bool:
        return isinstance(self._inner, types.UpdatePrivacy)

    def as_privacy(self) -> Optional[types.UpdatePrivacy]:
        return self._inner if self.is_privacy() else None

    def is_user_phone(self) -> bool:
        return isinstance(self._inner, types.UpdateUserPhone)

    def as_user_phone(self) -> Optional[types.UpdateUserPhone]:
        return self._inner if self.is_user_phone() else None

    def is_read_history_inbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadHistoryInbox)

    def as_read_history_inbox(self) -> Optional[types.UpdateReadHistoryInbox]:
        return self._inner if self.is_read_history_inbox() else None

    def is_read_history_outbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadHistoryOutbox)

    def as_read_history_outbox(self) -> Optional[types.UpdateReadHistoryOutbox]:
        return self._inner if self.is_read_history_outbox() else None

    def is_web_page(self) -> bool:
        return isinstance(self._inner, types.UpdateWebPage)

    def as_web_page(self) -> Optional[types.UpdateWebPage]:
        return self._inner if self.is_web_page() else None

    def is_read_messages_contents(self) -> bool:
        return isinstance(self._inner, types.UpdateReadMessagesContents)

    def as_read_messages_contents(self) -> Optional[types.UpdateReadMessagesContents]:
        return self._inner if self.is_read_messages_contents() else None

    def is_channel_too_long(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelTooLong)

    def as_channel_too_long(self) -> Optional[types.UpdateChannelTooLong]:
        return self._inner if self.is_channel_too_long() else None

    def is_channel(self) -> bool:
        return isinstance(self._inner, types.UpdateChannel)

    def as_channel(self) -> Optional[types.UpdateChannel]:
        return self._inner if self.is_channel() else None

    def is_new_channel_message(self) -> bool:
        return isinstance(self._inner, types.UpdateNewChannelMessage)

    def as_new_channel_message(self) -> Optional[types.UpdateNewChannelMessage]:
        return self._inner if self.is_new_channel_message() else None

    def is_read_channel_inbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadChannelInbox)

    def as_read_channel_inbox(self) -> Optional[types.UpdateReadChannelInbox]:
        return self._inner if self.is_read_channel_inbox() else None

    def is_delete_channel_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateDeleteChannelMessages)

    def as_delete_channel_messages(self) -> Optional[types.UpdateDeleteChannelMessages]:
        return self._inner if self.is_delete_channel_messages() else None

    def is_channel_message_views(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelMessageViews)

    def as_channel_message_views(self) -> Optional[types.UpdateChannelMessageViews]:
        return self._inner if self.is_channel_message_views() else None

    def is_chat_participant_admin(self) -> bool:
        return isinstance(self._inner, types.UpdateChatParticipantAdmin)

    def as_chat_participant_admin(self) -> Optional[types.UpdateChatParticipantAdmin]:
        return self._inner if self.is_chat_participant_admin() else None

    def is_new_sticker_set(self) -> bool:
        return isinstance(self._inner, types.UpdateNewStickerSet)

    def as_new_sticker_set(self) -> Optional[types.UpdateNewStickerSet]:
        return self._inner if self.is_new_sticker_set() else None

    def is_sticker_sets_order(self) -> bool:
        return isinstance(self._inner, types.UpdateStickerSetsOrder)

    def as_sticker_sets_order(self) -> Optional[types.UpdateStickerSetsOrder]:
        return self._inner if self.is_sticker_sets_order() else None

    def is_sticker_sets(self) -> bool:
        return isinstance(self._inner, types.UpdateStickerSets)

    def as_sticker_sets(self) -> Optional[types.UpdateStickerSets]:
        return self._inner if self.is_sticker_sets() else None

    def is_saved_gifs(self) -> bool:
        return isinstance(self._inner, types.UpdateSavedGifs)

    def as_saved_gifs(self) -> Optional[types.UpdateSavedGifs]:
        return self._inner if self.is_saved_gifs() else None

    def is_bot_inline_query(self) -> bool:
        return isinstance(self._inner, types.UpdateBotInlineQuery)

    def as_bot_inline_query(self) -> Optional[types.UpdateBotInlineQuery]:
        return self._inner if self.is_bot_inline_query() else None

    def is_bot_inline_send(self) -> bool:
        return isinstance(self._inner, types.UpdateBotInlineSend)

    def as_bot_inline_send(self) -> Optional[types.UpdateBotInlineSend]:
        return self._inner if self.is_bot_inline_send() else None

    def is_edit_channel_message(self) -> bool:
        return isinstance(self._inner, types.UpdateEditChannelMessage)

    def as_edit_channel_message(self) -> Optional[types.UpdateEditChannelMessage]:
        return self._inner if self.is_edit_channel_message() else None

    def is_bot_callback_query(self) -> bool:
        return isinstance(self._inner, types.UpdateBotCallbackQuery)

    def as_bot_callback_query(self) -> Optional[types.UpdateBotCallbackQuery]:
        return self._inner if self.is_bot_callback_query() else None

    def is_edit_message(self) -> bool:
        return isinstance(self._inner, types.UpdateEditMessage)

    def as_edit_message(self) -> Optional[types.UpdateEditMessage]:
        return self._inner if self.is_edit_message() else None

    def is_inline_bot_callback_query(self) -> bool:
        return isinstance(self._inner, types.UpdateInlineBotCallbackQuery)

    def as_inline_bot_callback_query(self) -> Optional[types.UpdateInlineBotCallbackQuery]:
        return self._inner if self.is_inline_bot_callback_query() else None

    def is_read_channel_outbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadChannelOutbox)

    def as_read_channel_outbox(self) -> Optional[types.UpdateReadChannelOutbox]:
        return self._inner if self.is_read_channel_outbox() else None

    def is_draft_message(self) -> bool:
        return isinstance(self._inner, types.UpdateDraftMessage)

    def as_draft_message(self) -> Optional[types.UpdateDraftMessage]:
        return self._inner if self.is_draft_message() else None

    def is_read_featured_stickers(self) -> bool:
        return isinstance(self._inner, types.UpdateReadFeaturedStickers)

    def as_read_featured_stickers(self) -> Optional[types.UpdateReadFeaturedStickers]:
        return self._inner if self.is_read_featured_stickers() else None

    def is_recent_stickers(self) -> bool:
        return isinstance(self._inner, types.UpdateRecentStickers)

    def as_recent_stickers(self) -> Optional[types.UpdateRecentStickers]:
        return self._inner if self.is_recent_stickers() else None

    def is_config(self) -> bool:
        return isinstance(self._inner, types.UpdateConfig)

    def as_config(self) -> Optional[types.UpdateConfig]:
        return self._inner if self.is_config() else None

    def is_pts_changed(self) -> bool:
        return isinstance(self._inner, types.UpdatePtsChanged)

    def as_pts_changed(self) -> Optional[types.UpdatePtsChanged]:
        return self._inner if self.is_pts_changed() else None

    def is_channel_web_page(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelWebPage)

    def as_channel_web_page(self) -> Optional[types.UpdateChannelWebPage]:
        return self._inner if self.is_channel_web_page() else None

    def is_dialog_pinned(self) -> bool:
        return isinstance(self._inner, types.UpdateDialogPinned)

    def as_dialog_pinned(self) -> Optional[types.UpdateDialogPinned]:
        return self._inner if self.is_dialog_pinned() else None

    def is_pinned_dialogs(self) -> bool:
        return isinstance(self._inner, types.UpdatePinnedDialogs)

    def as_pinned_dialogs(self) -> Optional[types.UpdatePinnedDialogs]:
        return self._inner if self.is_pinned_dialogs() else None

    def is_bot_webhook_json(self) -> bool:
        return isinstance(self._inner, types.UpdateBotWebhookJson)

    def as_bot_webhook_json(self) -> Optional[types.UpdateBotWebhookJson]:
        return self._inner if self.is_bot_webhook_json() else None

    def is_bot_webhook_jsonquery(self) -> bool:
        return isinstance(self._inner, types.UpdateBotWebhookJsonquery)

    def as_bot_webhook_jsonquery(self) -> Optional[types.UpdateBotWebhookJsonquery]:
        return self._inner if self.is_bot_webhook_jsonquery() else None

    def is_bot_shipping_query(self) -> bool:
        return isinstance(self._inner, types.UpdateBotShippingQuery)

    def as_bot_shipping_query(self) -> Optional[types.UpdateBotShippingQuery]:
        return self._inner if self.is_bot_shipping_query() else None

    def is_bot_precheckout_query(self) -> bool:
        return isinstance(self._inner, types.UpdateBotPrecheckoutQuery)

    def as_bot_precheckout_query(self) -> Optional[types.UpdateBotPrecheckoutQuery]:
        return self._inner if self.is_bot_precheckout_query() else None

    def is_phone_call(self) -> bool:
        return isinstance(self._inner, types.UpdatePhoneCall)

    def as_phone_call(self) -> Optional[types.UpdatePhoneCall]:
        return self._inner if self.is_phone_call() else None

    def is_lang_pack_too_long(self) -> bool:
        return isinstance(self._inner, types.UpdateLangPackTooLong)

    def as_lang_pack_too_long(self) -> Optional[types.UpdateLangPackTooLong]:
        return self._inner if self.is_lang_pack_too_long() else None

    def is_lang_pack(self) -> bool:
        return isinstance(self._inner, types.UpdateLangPack)

    def as_lang_pack(self) -> Optional[types.UpdateLangPack]:
        return self._inner if self.is_lang_pack() else None

    def is_faved_stickers(self) -> bool:
        return isinstance(self._inner, types.UpdateFavedStickers)

    def as_faved_stickers(self) -> Optional[types.UpdateFavedStickers]:
        return self._inner if self.is_faved_stickers() else None

    def is_channel_read_messages_contents(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelReadMessagesContents)

    def as_channel_read_messages_contents(self) -> Optional[types.UpdateChannelReadMessagesContents]:
        return self._inner if self.is_channel_read_messages_contents() else None

    def is_contacts_reset(self) -> bool:
        return isinstance(self._inner, types.UpdateContactsReset)

    def as_contacts_reset(self) -> Optional[types.UpdateContactsReset]:
        return self._inner if self.is_contacts_reset() else None

    def is_channel_available_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelAvailableMessages)

    def as_channel_available_messages(self) -> Optional[types.UpdateChannelAvailableMessages]:
        return self._inner if self.is_channel_available_messages() else None

    def is_dialog_unread_mark(self) -> bool:
        return isinstance(self._inner, types.UpdateDialogUnreadMark)

    def as_dialog_unread_mark(self) -> Optional[types.UpdateDialogUnreadMark]:
        return self._inner if self.is_dialog_unread_mark() else None

    def is_message_poll(self) -> bool:
        return isinstance(self._inner, types.UpdateMessagePoll)

    def as_message_poll(self) -> Optional[types.UpdateMessagePoll]:
        return self._inner if self.is_message_poll() else None

    def is_chat_default_banned_rights(self) -> bool:
        return isinstance(self._inner, types.UpdateChatDefaultBannedRights)

    def as_chat_default_banned_rights(self) -> Optional[types.UpdateChatDefaultBannedRights]:
        return self._inner if self.is_chat_default_banned_rights() else None

    def is_folder_peers(self) -> bool:
        return isinstance(self._inner, types.UpdateFolderPeers)

    def as_folder_peers(self) -> Optional[types.UpdateFolderPeers]:
        return self._inner if self.is_folder_peers() else None

    def is_peer_settings(self) -> bool:
        return isinstance(self._inner, types.UpdatePeerSettings)

    def as_peer_settings(self) -> Optional[types.UpdatePeerSettings]:
        return self._inner if self.is_peer_settings() else None

    def is_peer_located(self) -> bool:
        return isinstance(self._inner, types.UpdatePeerLocated)

    def as_peer_located(self) -> Optional[types.UpdatePeerLocated]:
        return self._inner if self.is_peer_located() else None

    def is_new_scheduled_message(self) -> bool:
        return isinstance(self._inner, types.UpdateNewScheduledMessage)

    def as_new_scheduled_message(self) -> Optional[types.UpdateNewScheduledMessage]:
        return self._inner if self.is_new_scheduled_message() else None

    def is_delete_scheduled_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateDeleteScheduledMessages)

    def as_delete_scheduled_messages(self) -> Optional[types.UpdateDeleteScheduledMessages]:
        return self._inner if self.is_delete_scheduled_messages() else None

    def is_theme(self) -> bool:
        return isinstance(self._inner, types.UpdateTheme)

    def as_theme(self) -> Optional[types.UpdateTheme]:
        return self._inner if self.is_theme() else None

    def is_geo_live_viewed(self) -> bool:
        return isinstance(self._inner, types.UpdateGeoLiveViewed)

    def as_geo_live_viewed(self) -> Optional[types.UpdateGeoLiveViewed]:
        return self._inner if self.is_geo_live_viewed() else None

    def is_login_token(self) -> bool:
        return isinstance(self._inner, types.UpdateLoginToken)

    def as_login_token(self) -> Optional[types.UpdateLoginToken]:
        return self._inner if self.is_login_token() else None

    def is_message_poll_vote(self) -> bool:
        return isinstance(self._inner, types.UpdateMessagePollVote)

    def as_message_poll_vote(self) -> Optional[types.UpdateMessagePollVote]:
        return self._inner if self.is_message_poll_vote() else None

    def is_dialog_filter(self) -> bool:
        return isinstance(self._inner, types.UpdateDialogFilter)

    def as_dialog_filter(self) -> Optional[types.UpdateDialogFilter]:
        return self._inner if self.is_dialog_filter() else None

    def is_dialog_filter_order(self) -> bool:
        return isinstance(self._inner, types.UpdateDialogFilterOrder)

    def as_dialog_filter_order(self) -> Optional[types.UpdateDialogFilterOrder]:
        return self._inner if self.is_dialog_filter_order() else None

    def is_dialog_filters(self) -> bool:
        return isinstance(self._inner, types.UpdateDialogFilters)

    def as_dialog_filters(self) -> Optional[types.UpdateDialogFilters]:
        return self._inner if self.is_dialog_filters() else None

    def is_phone_call_signaling_data(self) -> bool:
        return isinstance(self._inner, types.UpdatePhoneCallSignalingData)

    def as_phone_call_signaling_data(self) -> Optional[types.UpdatePhoneCallSignalingData]:
        return self._inner if self.is_phone_call_signaling_data() else None

    def is_channel_message_forwards(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelMessageForwards)

    def as_channel_message_forwards(self) -> Optional[types.UpdateChannelMessageForwards]:
        return self._inner if self.is_channel_message_forwards() else None

    def is_read_channel_discussion_inbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadChannelDiscussionInbox)

    def as_read_channel_discussion_inbox(self) -> Optional[types.UpdateReadChannelDiscussionInbox]:
        return self._inner if self.is_read_channel_discussion_inbox() else None

    def is_read_channel_discussion_outbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadChannelDiscussionOutbox)

    def as_read_channel_discussion_outbox(self) -> Optional[types.UpdateReadChannelDiscussionOutbox]:
        return self._inner if self.is_read_channel_discussion_outbox() else None

    def is_peer_blocked(self) -> bool:
        return isinstance(self._inner, types.UpdatePeerBlocked)

    def as_peer_blocked(self) -> Optional[types.UpdatePeerBlocked]:
        return self._inner if self.is_peer_blocked() else None

    def is_channel_user_typing(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelUserTyping)

    def as_channel_user_typing(self) -> Optional[types.UpdateChannelUserTyping]:
        return self._inner if self.is_channel_user_typing() else None

    def is_pinned_messages(self) -> bool:
        return isinstance(self._inner, types.UpdatePinnedMessages)

    def as_pinned_messages(self) -> Optional[types.UpdatePinnedMessages]:
        return self._inner if self.is_pinned_messages() else None

    def is_pinned_channel_messages(self) -> bool:
        return isinstance(self._inner, types.UpdatePinnedChannelMessages)

    def as_pinned_channel_messages(self) -> Optional[types.UpdatePinnedChannelMessages]:
        return self._inner if self.is_pinned_channel_messages() else None

    def is_chat(self) -> bool:
        return isinstance(self._inner, types.UpdateChat)

    def as_chat(self) -> Optional[types.UpdateChat]:
        return self._inner if self.is_chat() else None

    def is_group_call_participants(self) -> bool:
        return isinstance(self._inner, types.UpdateGroupCallParticipants)

    def as_group_call_participants(self) -> Optional[types.UpdateGroupCallParticipants]:
        return self._inner if self.is_group_call_participants() else None

    def is_group_call(self) -> bool:
        return isinstance(self._inner, types.UpdateGroupCall)

    def as_group_call(self) -> Optional[types.UpdateGroupCall]:
        return self._inner if self.is_group_call() else None

    def is_peer_history_ttl(self) -> bool:
        return isinstance(self._inner, types.UpdatePeerHistoryTtl)

    def as_peer_history_ttl(self) -> Optional[types.UpdatePeerHistoryTtl]:
        return self._inner if self.is_peer_history_ttl() else None

    def is_chat_participant(self) -> bool:
        return isinstance(self._inner, types.UpdateChatParticipant)

    def as_chat_participant(self) -> Optional[types.UpdateChatParticipant]:
        return self._inner if self.is_chat_participant() else None

    def is_channel_participant(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelParticipant)

    def as_channel_participant(self) -> Optional[types.UpdateChannelParticipant]:
        return self._inner if self.is_channel_participant() else None

    def is_bot_stopped(self) -> bool:
        return isinstance(self._inner, types.UpdateBotStopped)

    def as_bot_stopped(self) -> Optional[types.UpdateBotStopped]:
        return self._inner if self.is_bot_stopped() else None

    def is_group_call_connection(self) -> bool:
        return isinstance(self._inner, types.UpdateGroupCallConnection)

    def as_group_call_connection(self) -> Optional[types.UpdateGroupCallConnection]:
        return self._inner if self.is_group_call_connection() else None

    def is_bot_commands(self) -> bool:
        return isinstance(self._inner, types.UpdateBotCommands)

    def as_bot_commands(self) -> Optional[types.UpdateBotCommands]:
        return self._inner if self.is_bot_commands() else None

    def is_pending_join_requests(self) -> bool:
        return isinstance(self._inner, types.UpdatePendingJoinRequests)

    def as_pending_join_requests(self) -> Optional[types.UpdatePendingJoinRequests]:
        return self._inner if self.is_pending_join_requests() else None

    def is_bot_chat_invite_requester(self) -> bool:
        return isinstance(self._inner, types.UpdateBotChatInviteRequester)

    def as_bot_chat_invite_requester(self) -> Optional[types.UpdateBotChatInviteRequester]:
        return self._inner if self.is_bot_chat_invite_requester() else None

    def is_message_reactions(self) -> bool:
        return isinstance(self._inner, types.UpdateMessageReactions)

    def as_message_reactions(self) -> Optional[types.UpdateMessageReactions]:
        return self._inner if self.is_message_reactions() else None

    def is_attach_menu_bots(self) -> bool:
        return isinstance(self._inner, types.UpdateAttachMenuBots)

    def as_attach_menu_bots(self) -> Optional[types.UpdateAttachMenuBots]:
        return self._inner if self.is_attach_menu_bots() else None

    def is_web_view_result_sent(self) -> bool:
        return isinstance(self._inner, types.UpdateWebViewResultSent)

    def as_web_view_result_sent(self) -> Optional[types.UpdateWebViewResultSent]:
        return self._inner if self.is_web_view_result_sent() else None

    def is_bot_menu_button(self) -> bool:
        return isinstance(self._inner, types.UpdateBotMenuButton)

    def as_bot_menu_button(self) -> Optional[types.UpdateBotMenuButton]:
        return self._inner if self.is_bot_menu_button() else None

    def is_saved_ringtones(self) -> bool:
        return isinstance(self._inner, types.UpdateSavedRingtones)

    def as_saved_ringtones(self) -> Optional[types.UpdateSavedRingtones]:
        return self._inner if self.is_saved_ringtones() else None

    def is_transcribed_audio(self) -> bool:
        return isinstance(self._inner, types.UpdateTranscribedAudio)

    def as_transcribed_audio(self) -> Optional[types.UpdateTranscribedAudio]:
        return self._inner if self.is_transcribed_audio() else None

    def is_read_featured_emoji_stickers(self) -> bool:
        return isinstance(self._inner, types.UpdateReadFeaturedEmojiStickers)

    def as_read_featured_emoji_stickers(self) -> Optional[types.UpdateReadFeaturedEmojiStickers]:
        return self._inner if self.is_read_featured_emoji_stickers() else None

    def is_user_emoji_status(self) -> bool:
        return isinstance(self._inner, types.UpdateUserEmojiStatus)

    def as_user_emoji_status(self) -> Optional[types.UpdateUserEmojiStatus]:
        return self._inner if self.is_user_emoji_status() else None

    def is_recent_emoji_statuses(self) -> bool:
        return isinstance(self._inner, types.UpdateRecentEmojiStatuses)

    def as_recent_emoji_statuses(self) -> Optional[types.UpdateRecentEmojiStatuses]:
        return self._inner if self.is_recent_emoji_statuses() else None

    def is_recent_reactions(self) -> bool:
        return isinstance(self._inner, types.UpdateRecentReactions)

    def as_recent_reactions(self) -> Optional[types.UpdateRecentReactions]:
        return self._inner if self.is_recent_reactions() else None

    def is_move_sticker_set_to_top(self) -> bool:
        return isinstance(self._inner, types.UpdateMoveStickerSetToTop)

    def as_move_sticker_set_to_top(self) -> Optional[types.UpdateMoveStickerSetToTop]:
        return self._inner if self.is_move_sticker_set_to_top() else None

    def is_message_extended_media(self) -> bool:
        return isinstance(self._inner, types.UpdateMessageExtendedMedia)

    def as_message_extended_media(self) -> Optional[types.UpdateMessageExtendedMedia]:
        return self._inner if self.is_message_extended_media() else None

    def is_user(self) -> bool:
        return isinstance(self._inner, types.UpdateUser)

    def as_user(self) -> Optional[types.UpdateUser]:
        return self._inner if self.is_user() else None

    def is_auto_save_settings(self) -> bool:
        return isinstance(self._inner, types.UpdateAutoSaveSettings)

    def as_auto_save_settings(self) -> Optional[types.UpdateAutoSaveSettings]:
        return self._inner if self.is_auto_save_settings() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.UpdateStory)

    def as_story(self) -> Optional[types.UpdateStory]:
        return self._inner if self.is_story() else None

    def is_read_stories(self) -> bool:
        return isinstance(self._inner, types.UpdateReadStories)

    def as_read_stories(self) -> Optional[types.UpdateReadStories]:
        return self._inner if self.is_read_stories() else None

    def is_story_id(self) -> bool:
        return isinstance(self._inner, types.UpdateStoryId)

    def as_story_id(self) -> Optional[types.UpdateStoryId]:
        return self._inner if self.is_story_id() else None

    def is_stories_stealth_mode(self) -> bool:
        return isinstance(self._inner, types.UpdateStoriesStealthMode)

    def as_stories_stealth_mode(self) -> Optional[types.UpdateStoriesStealthMode]:
        return self._inner if self.is_stories_stealth_mode() else None

    def is_sent_story_reaction(self) -> bool:
        return isinstance(self._inner, types.UpdateSentStoryReaction)

    def as_sent_story_reaction(self) -> Optional[types.UpdateSentStoryReaction]:
        return self._inner if self.is_sent_story_reaction() else None

    def is_bot_chat_boost(self) -> bool:
        return isinstance(self._inner, types.UpdateBotChatBoost)

    def as_bot_chat_boost(self) -> Optional[types.UpdateBotChatBoost]:
        return self._inner if self.is_bot_chat_boost() else None

    def is_channel_view_forum_as_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateChannelViewForumAsMessages)

    def as_channel_view_forum_as_messages(self) -> Optional[types.UpdateChannelViewForumAsMessages]:
        return self._inner if self.is_channel_view_forum_as_messages() else None

    def is_peer_wallpaper(self) -> bool:
        return isinstance(self._inner, types.UpdatePeerWallpaper)

    def as_peer_wallpaper(self) -> Optional[types.UpdatePeerWallpaper]:
        return self._inner if self.is_peer_wallpaper() else None

    def is_bot_message_reaction(self) -> bool:
        return isinstance(self._inner, types.UpdateBotMessageReaction)

    def as_bot_message_reaction(self) -> Optional[types.UpdateBotMessageReaction]:
        return self._inner if self.is_bot_message_reaction() else None

    def is_bot_message_reactions(self) -> bool:
        return isinstance(self._inner, types.UpdateBotMessageReactions)

    def as_bot_message_reactions(self) -> Optional[types.UpdateBotMessageReactions]:
        return self._inner if self.is_bot_message_reactions() else None

    def is_saved_dialog_pinned(self) -> bool:
        return isinstance(self._inner, types.UpdateSavedDialogPinned)

    def as_saved_dialog_pinned(self) -> Optional[types.UpdateSavedDialogPinned]:
        return self._inner if self.is_saved_dialog_pinned() else None

    def is_pinned_saved_dialogs(self) -> bool:
        return isinstance(self._inner, types.UpdatePinnedSavedDialogs)

    def as_pinned_saved_dialogs(self) -> Optional[types.UpdatePinnedSavedDialogs]:
        return self._inner if self.is_pinned_saved_dialogs() else None

    def is_saved_reaction_tags(self) -> bool:
        return isinstance(self._inner, types.UpdateSavedReactionTags)

    def as_saved_reaction_tags(self) -> Optional[types.UpdateSavedReactionTags]:
        return self._inner if self.is_saved_reaction_tags() else None

    def is_sms_job(self) -> bool:
        return isinstance(self._inner, types.UpdateSmsJob)

    def as_sms_job(self) -> Optional[types.UpdateSmsJob]:
        return self._inner if self.is_sms_job() else None

    def is_quick_replies(self) -> bool:
        return isinstance(self._inner, types.UpdateQuickReplies)

    def as_quick_replies(self) -> Optional[types.UpdateQuickReplies]:
        return self._inner if self.is_quick_replies() else None

    def is_new_quick_reply(self) -> bool:
        return isinstance(self._inner, types.UpdateNewQuickReply)

    def as_new_quick_reply(self) -> Optional[types.UpdateNewQuickReply]:
        return self._inner if self.is_new_quick_reply() else None

    def is_delete_quick_reply(self) -> bool:
        return isinstance(self._inner, types.UpdateDeleteQuickReply)

    def as_delete_quick_reply(self) -> Optional[types.UpdateDeleteQuickReply]:
        return self._inner if self.is_delete_quick_reply() else None

    def is_quick_reply_message(self) -> bool:
        return isinstance(self._inner, types.UpdateQuickReplyMessage)

    def as_quick_reply_message(self) -> Optional[types.UpdateQuickReplyMessage]:
        return self._inner if self.is_quick_reply_message() else None

    def is_delete_quick_reply_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateDeleteQuickReplyMessages)

    def as_delete_quick_reply_messages(self) -> Optional[types.UpdateDeleteQuickReplyMessages]:
        return self._inner if self.is_delete_quick_reply_messages() else None

    def is_bot_business_connect(self) -> bool:
        return isinstance(self._inner, types.UpdateBotBusinessConnect)

    def as_bot_business_connect(self) -> Optional[types.UpdateBotBusinessConnect]:
        return self._inner if self.is_bot_business_connect() else None

    def is_bot_new_business_message(self) -> bool:
        return isinstance(self._inner, types.UpdateBotNewBusinessMessage)

    def as_bot_new_business_message(self) -> Optional[types.UpdateBotNewBusinessMessage]:
        return self._inner if self.is_bot_new_business_message() else None

    def is_bot_edit_business_message(self) -> bool:
        return isinstance(self._inner, types.UpdateBotEditBusinessMessage)

    def as_bot_edit_business_message(self) -> Optional[types.UpdateBotEditBusinessMessage]:
        return self._inner if self.is_bot_edit_business_message() else None

    def is_bot_delete_business_message(self) -> bool:
        return isinstance(self._inner, types.UpdateBotDeleteBusinessMessage)

    def as_bot_delete_business_message(self) -> Optional[types.UpdateBotDeleteBusinessMessage]:
        return self._inner if self.is_bot_delete_business_message() else None

    def is_new_story_reaction(self) -> bool:
        return isinstance(self._inner, types.UpdateNewStoryReaction)

    def as_new_story_reaction(self) -> Optional[types.UpdateNewStoryReaction]:
        return self._inner if self.is_new_story_reaction() else None

    def is_stars_balance(self) -> bool:
        return isinstance(self._inner, types.UpdateStarsBalance)

    def as_stars_balance(self) -> Optional[types.UpdateStarsBalance]:
        return self._inner if self.is_stars_balance() else None

    def is_business_bot_callback_query(self) -> bool:
        return isinstance(self._inner, types.UpdateBusinessBotCallbackQuery)

    def as_business_bot_callback_query(self) -> Optional[types.UpdateBusinessBotCallbackQuery]:
        return self._inner if self.is_business_bot_callback_query() else None

    def is_stars_revenue_status(self) -> bool:
        return isinstance(self._inner, types.UpdateStarsRevenueStatus)

    def as_stars_revenue_status(self) -> Optional[types.UpdateStarsRevenueStatus]:
        return self._inner if self.is_stars_revenue_status() else None

    def is_bot_purchased_paid_media(self) -> bool:
        return isinstance(self._inner, types.UpdateBotPurchasedPaidMedia)

    def as_bot_purchased_paid_media(self) -> Optional[types.UpdateBotPurchasedPaidMedia]:
        return self._inner if self.is_bot_purchased_paid_media() else None

    def is_paid_reaction_privacy(self) -> bool:
        return isinstance(self._inner, types.UpdatePaidReactionPrivacy)

    def as_paid_reaction_privacy(self) -> Optional[types.UpdatePaidReactionPrivacy]:
        return self._inner if self.is_paid_reaction_privacy() else None

    def is_sent_phone_code(self) -> bool:
        return isinstance(self._inner, types.UpdateSentPhoneCode)

    def as_sent_phone_code(self) -> Optional[types.UpdateSentPhoneCode]:
        return self._inner if self.is_sent_phone_code() else None

    def is_group_call_chain_blocks(self) -> bool:
        return isinstance(self._inner, types.UpdateGroupCallChainBlocks)

    def as_group_call_chain_blocks(self) -> Optional[types.UpdateGroupCallChainBlocks]:
        return self._inner if self.is_group_call_chain_blocks() else None

    def is_read_mono_forum_inbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadMonoForumInbox)

    def as_read_mono_forum_inbox(self) -> Optional[types.UpdateReadMonoForumInbox]:
        return self._inner if self.is_read_mono_forum_inbox() else None

    def is_read_mono_forum_outbox(self) -> bool:
        return isinstance(self._inner, types.UpdateReadMonoForumOutbox)

    def as_read_mono_forum_outbox(self) -> Optional[types.UpdateReadMonoForumOutbox]:
        return self._inner if self.is_read_mono_forum_outbox() else None

    def is_mono_forum_no_paid_exception(self) -> bool:
        return isinstance(self._inner, types.UpdateMonoForumNoPaidException)

    def as_mono_forum_no_paid_exception(self) -> Optional[types.UpdateMonoForumNoPaidException]:
        return self._inner if self.is_mono_forum_no_paid_exception() else None

    def is_group_call_message(self) -> bool:
        return isinstance(self._inner, types.UpdateGroupCallMessage)

    def as_group_call_message(self) -> Optional[types.UpdateGroupCallMessage]:
        return self._inner if self.is_group_call_message() else None

    def is_group_call_encrypted_message(self) -> bool:
        return isinstance(self._inner, types.UpdateGroupCallEncryptedMessage)

    def as_group_call_encrypted_message(self) -> Optional[types.UpdateGroupCallEncryptedMessage]:
        return self._inner if self.is_group_call_encrypted_message() else None

    def is_pinned_forum_topic(self) -> bool:
        return isinstance(self._inner, types.UpdatePinnedForumTopic)

    def as_pinned_forum_topic(self) -> Optional[types.UpdatePinnedForumTopic]:
        return self._inner if self.is_pinned_forum_topic() else None

    def is_pinned_forum_topics(self) -> bool:
        return isinstance(self._inner, types.UpdatePinnedForumTopics)

    def as_pinned_forum_topics(self) -> Optional[types.UpdatePinnedForumTopics]:
        return self._inner if self.is_pinned_forum_topics() else None

    def is_delete_group_call_messages(self) -> bool:
        return isinstance(self._inner, types.UpdateDeleteGroupCallMessages)

    def as_delete_group_call_messages(self) -> Optional[types.UpdateDeleteGroupCallMessages]:
        return self._inner if self.is_delete_group_call_messages() else None

    def is_star_gift_auction_state(self) -> bool:
        return isinstance(self._inner, types.UpdateStarGiftAuctionState)

    def as_star_gift_auction_state(self) -> Optional[types.UpdateStarGiftAuctionState]:
        return self._inner if self.is_star_gift_auction_state() else None

    def is_star_gift_auction_user_state(self) -> bool:
        return isinstance(self._inner, types.UpdateStarGiftAuctionUserState)

    def as_star_gift_auction_user_state(self) -> Optional[types.UpdateStarGiftAuctionUserState]:
        return self._inner if self.is_star_gift_auction_user_state() else None

    def is_emoji_game_info(self) -> bool:
        return isinstance(self._inner, types.UpdateEmojiGameInfo)

    def as_emoji_game_info(self) -> Optional[types.UpdateEmojiGameInfo]:
        return self._inner if self.is_emoji_game_info() else None

    def is_star_gift_craft_fail(self) -> bool:
        return isinstance(self._inner, types.UpdateStarGiftCraftFail)

    def as_star_gift_craft_fail(self) -> Optional[types.UpdateStarGiftCraftFail]:
        return self._inner if self.is_star_gift_craft_fail() else None

    def __repr__(self) -> str:
        return f'Update({self._inner!r})'


class Updates(TLObject):
    """
    Boxed TL type ``Updates`` — union of 7 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE317AF7E: types.UpdatesTooLong,
        0x313BC7F8: types.UpdateShortMessage,
        0x4D6DEEA5: types.UpdateShortChatMessage,
        0x78D4DEC1: types.UpdateShort,
        0x725B04C3: types.UpdatesCombined,
        0x74AE4240: types.Updates,
        0x9015E101: types.UpdateShortSentMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Updates':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_too_long(self) -> bool:
        return isinstance(self._inner, types.UpdatesTooLong)

    def as_too_long(self) -> Optional[types.UpdatesTooLong]:
        return self._inner if self.is_too_long() else None

    def is_update_short_message(self) -> bool:
        return isinstance(self._inner, types.UpdateShortMessage)

    def as_update_short_message(self) -> Optional[types.UpdateShortMessage]:
        return self._inner if self.is_update_short_message() else None

    def is_update_short_chat_message(self) -> bool:
        return isinstance(self._inner, types.UpdateShortChatMessage)

    def as_update_short_chat_message(self) -> Optional[types.UpdateShortChatMessage]:
        return self._inner if self.is_update_short_chat_message() else None

    def is_update_short(self) -> bool:
        return isinstance(self._inner, types.UpdateShort)

    def as_update_short(self) -> Optional[types.UpdateShort]:
        return self._inner if self.is_update_short() else None

    def is_combined(self) -> bool:
        return isinstance(self._inner, types.UpdatesCombined)

    def as_combined(self) -> Optional[types.UpdatesCombined]:
        return self._inner if self.is_combined() else None

    def is_updates(self) -> bool:
        return isinstance(self._inner, types.Updates)

    def as_updates(self) -> Optional[types.Updates]:
        return self._inner if self.is_updates() else None

    def is_update_short_sent_message(self) -> bool:
        return isinstance(self._inner, types.UpdateShortSentMessage)

    def as_update_short_sent_message(self) -> Optional[types.UpdateShortSentMessage]:
        return self._inner if self.is_update_short_sent_message() else None

    def __repr__(self) -> str:
        return f'Updates({self._inner!r})'


class UrlAuthResult(TLObject):
    """
    Boxed TL type ``UrlAuthResult`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x32FABF1A: types.UrlAuthResultRequest,
        0x623A8FA0: types.UrlAuthResultAccepted,
        0xA9D6DB1F: types.UrlAuthResultDefault,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UrlAuthResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_request(self) -> bool:
        return isinstance(self._inner, types.UrlAuthResultRequest)

    def as_request(self) -> Optional[types.UrlAuthResultRequest]:
        return self._inner if self.is_request() else None

    def is_accepted(self) -> bool:
        return isinstance(self._inner, types.UrlAuthResultAccepted)

    def as_accepted(self) -> Optional[types.UrlAuthResultAccepted]:
        return self._inner if self.is_accepted() else None

    def is_default(self) -> bool:
        return isinstance(self._inner, types.UrlAuthResultDefault)

    def as_default(self) -> Optional[types.UrlAuthResultDefault]:
        return self._inner if self.is_default() else None

    def __repr__(self) -> str:
        return f'UrlAuthResult({self._inner!r})'


class User(TLObject):
    """
    Boxed TL type ``User`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD3BC4B7A: types.UserEmpty,
        0x31774388: types.User,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'User':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.UserEmpty)

    def as_empty(self) -> Optional[types.UserEmpty]:
        return self._inner if self.is_empty() else None

    def is_user(self) -> bool:
        return isinstance(self._inner, types.User)

    def as_user(self) -> Optional[types.User]:
        return self._inner if self.is_user() else None

    def __repr__(self) -> str:
        return f'User({self._inner!r})'


class UserFull(TLObject):
    """
    Boxed TL type ``UserFull`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA02BC13E: types.UserFull,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UserFull':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_user_full(self) -> bool:
        return isinstance(self._inner, types.UserFull)

    def as_user_full(self) -> Optional[types.UserFull]:
        return self._inner if self.is_user_full() else None

    def __repr__(self) -> str:
        return f'UserFull({self._inner!r})'


class UserProfilePhoto(TLObject):
    """
    Boxed TL type ``UserProfilePhoto`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4F11BAE1: types.UserProfilePhotoEmpty,
        0x82D1F706: types.UserProfilePhoto,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UserProfilePhoto':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.UserProfilePhotoEmpty)

    def as_empty(self) -> Optional[types.UserProfilePhotoEmpty]:
        return self._inner if self.is_empty() else None

    def is_user_profile_photo(self) -> bool:
        return isinstance(self._inner, types.UserProfilePhoto)

    def as_user_profile_photo(self) -> Optional[types.UserProfilePhoto]:
        return self._inner if self.is_user_profile_photo() else None

    def __repr__(self) -> str:
        return f'UserProfilePhoto({self._inner!r})'


class UserStatus(TLObject):
    """
    Boxed TL type ``UserStatus`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x09D05049: types.UserStatusEmpty,
        0xEDB93949: types.UserStatusOnline,
        0x008C703F: types.UserStatusOffline,
        0x7B197DC8: types.UserStatusRecently,
        0x541A1D1A: types.UserStatusLastWeek,
        0x65899777: types.UserStatusLastMonth,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UserStatus':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.UserStatusEmpty)

    def as_empty(self) -> Optional[types.UserStatusEmpty]:
        return self._inner if self.is_empty() else None

    def is_online(self) -> bool:
        return isinstance(self._inner, types.UserStatusOnline)

    def as_online(self) -> Optional[types.UserStatusOnline]:
        return self._inner if self.is_online() else None

    def is_offline(self) -> bool:
        return isinstance(self._inner, types.UserStatusOffline)

    def as_offline(self) -> Optional[types.UserStatusOffline]:
        return self._inner if self.is_offline() else None

    def is_recently(self) -> bool:
        return isinstance(self._inner, types.UserStatusRecently)

    def as_recently(self) -> Optional[types.UserStatusRecently]:
        return self._inner if self.is_recently() else None

    def is_last_week(self) -> bool:
        return isinstance(self._inner, types.UserStatusLastWeek)

    def as_last_week(self) -> Optional[types.UserStatusLastWeek]:
        return self._inner if self.is_last_week() else None

    def is_last_month(self) -> bool:
        return isinstance(self._inner, types.UserStatusLastMonth)

    def as_last_month(self) -> Optional[types.UserStatusLastMonth]:
        return self._inner if self.is_last_month() else None

    def __repr__(self) -> str:
        return f'UserStatus({self._inner!r})'


class Username(TLObject):
    """
    Boxed TL type ``Username`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB4073647: types.Username,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Username':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_username(self) -> bool:
        return isinstance(self._inner, types.Username)

    def as_username(self) -> Optional[types.Username]:
        return self._inner if self.is_username() else None

    def __repr__(self) -> str:
        return f'Username({self._inner!r})'


class VideoSize(TLObject):
    """
    Boxed TL type ``VideoSize`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDE33B094: types.VideoSize,
        0xF85C413C: types.VideoSizeEmojiMarkup,
        0x0DA082FE: types.VideoSizeStickerMarkup,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'VideoSize':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_video_size(self) -> bool:
        return isinstance(self._inner, types.VideoSize)

    def as_video_size(self) -> Optional[types.VideoSize]:
        return self._inner if self.is_video_size() else None

    def is_emoji_markup(self) -> bool:
        return isinstance(self._inner, types.VideoSizeEmojiMarkup)

    def as_emoji_markup(self) -> Optional[types.VideoSizeEmojiMarkup]:
        return self._inner if self.is_emoji_markup() else None

    def is_sticker_markup(self) -> bool:
        return isinstance(self._inner, types.VideoSizeStickerMarkup)

    def as_sticker_markup(self) -> Optional[types.VideoSizeStickerMarkup]:
        return self._inner if self.is_sticker_markup() else None

    def __repr__(self) -> str:
        return f'VideoSize({self._inner!r})'


class WallPaper(TLObject):
    """
    Boxed TL type ``WallPaper`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA437C3ED: types.WallPaper,
        0xE0804116: types.WallPaperNoFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WallPaper':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_wall_paper(self) -> bool:
        return isinstance(self._inner, types.WallPaper)

    def as_wall_paper(self) -> Optional[types.WallPaper]:
        return self._inner if self.is_wall_paper() else None

    def is_no_file(self) -> bool:
        return isinstance(self._inner, types.WallPaperNoFile)

    def as_no_file(self) -> Optional[types.WallPaperNoFile]:
        return self._inner if self.is_no_file() else None

    def __repr__(self) -> str:
        return f'WallPaper({self._inner!r})'


class WallPaperSettings(TLObject):
    """
    Boxed TL type ``WallPaperSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x372EFCD0: types.WallPaperSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WallPaperSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_wall_paper_settings(self) -> bool:
        return isinstance(self._inner, types.WallPaperSettings)

    def as_wall_paper_settings(self) -> Optional[types.WallPaperSettings]:
        return self._inner if self.is_wall_paper_settings() else None

    def __repr__(self) -> str:
        return f'WallPaperSettings({self._inner!r})'


class WebAuthorization(TLObject):
    """
    Boxed TL type ``WebAuthorization`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA6F8F452: types.WebAuthorization,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebAuthorization':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_authorization(self) -> bool:
        return isinstance(self._inner, types.WebAuthorization)

    def as_web_authorization(self) -> Optional[types.WebAuthorization]:
        return self._inner if self.is_web_authorization() else None

    def __repr__(self) -> str:
        return f'WebAuthorization({self._inner!r})'


class WebDocument(TLObject):
    """
    Boxed TL type ``WebDocument`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1C570ED1: types.WebDocument,
        0xF9C8BCC6: types.WebDocumentNoProxy,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebDocument':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_document(self) -> bool:
        return isinstance(self._inner, types.WebDocument)

    def as_web_document(self) -> Optional[types.WebDocument]:
        return self._inner if self.is_web_document() else None

    def is_no_proxy(self) -> bool:
        return isinstance(self._inner, types.WebDocumentNoProxy)

    def as_no_proxy(self) -> Optional[types.WebDocumentNoProxy]:
        return self._inner if self.is_no_proxy() else None

    def __repr__(self) -> str:
        return f'WebDocument({self._inner!r})'


class WebPage(TLObject):
    """
    Boxed TL type ``WebPage`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x211A1788: types.WebPageEmpty,
        0xB0D13E47: types.WebPagePending,
        0xE89C45B2: types.WebPage,
        0x7311CA11: types.WebPageNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebPage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.WebPageEmpty)

    def as_empty(self) -> Optional[types.WebPageEmpty]:
        return self._inner if self.is_empty() else None

    def is_pending(self) -> bool:
        return isinstance(self._inner, types.WebPagePending)

    def as_pending(self) -> Optional[types.WebPagePending]:
        return self._inner if self.is_pending() else None

    def is_web_page(self) -> bool:
        return isinstance(self._inner, types.WebPage)

    def as_web_page(self) -> Optional[types.WebPage]:
        return self._inner if self.is_web_page() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.WebPageNotModified)

    def as_not_modified(self) -> Optional[types.WebPageNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'WebPage({self._inner!r})'


class WebPageAttribute(TLObject):
    """
    Boxed TL type ``WebPageAttribute`` — union of 6 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x54B56617: types.WebPageAttributeTheme,
        0x2E94C3E7: types.WebPageAttributeStory,
        0x50CC03D3: types.WebPageAttributeStickerSet,
        0xCF6F6DB8: types.WebPageAttributeUniqueStarGift,
        0x31CAD303: types.WebPageAttributeStarGiftCollection,
        0x01C641C2: types.WebPageAttributeStarGiftAuction,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebPageAttribute':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_theme(self) -> bool:
        return isinstance(self._inner, types.WebPageAttributeTheme)

    def as_theme(self) -> Optional[types.WebPageAttributeTheme]:
        return self._inner if self.is_theme() else None

    def is_story(self) -> bool:
        return isinstance(self._inner, types.WebPageAttributeStory)

    def as_story(self) -> Optional[types.WebPageAttributeStory]:
        return self._inner if self.is_story() else None

    def is_sticker_set(self) -> bool:
        return isinstance(self._inner, types.WebPageAttributeStickerSet)

    def as_sticker_set(self) -> Optional[types.WebPageAttributeStickerSet]:
        return self._inner if self.is_sticker_set() else None

    def is_unique_star_gift(self) -> bool:
        return isinstance(self._inner, types.WebPageAttributeUniqueStarGift)

    def as_unique_star_gift(self) -> Optional[types.WebPageAttributeUniqueStarGift]:
        return self._inner if self.is_unique_star_gift() else None

    def is_star_gift_collection(self) -> bool:
        return isinstance(self._inner, types.WebPageAttributeStarGiftCollection)

    def as_star_gift_collection(self) -> Optional[types.WebPageAttributeStarGiftCollection]:
        return self._inner if self.is_star_gift_collection() else None

    def is_star_gift_auction(self) -> bool:
        return isinstance(self._inner, types.WebPageAttributeStarGiftAuction)

    def as_star_gift_auction(self) -> Optional[types.WebPageAttributeStarGiftAuction]:
        return self._inner if self.is_star_gift_auction() else None

    def __repr__(self) -> str:
        return f'WebPageAttribute({self._inner!r})'


class WebViewMessageSent(TLObject):
    """
    Boxed TL type ``WebViewMessageSent`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0C94511C: types.WebViewMessageSent,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebViewMessageSent':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_view_message_sent(self) -> bool:
        return isinstance(self._inner, types.WebViewMessageSent)

    def as_web_view_message_sent(self) -> Optional[types.WebViewMessageSent]:
        return self._inner if self.is_web_view_message_sent() else None

    def __repr__(self) -> str:
        return f'WebViewMessageSent({self._inner!r})'


class WebViewResult(TLObject):
    """
    Boxed TL type ``WebViewResult`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4D22FF98: types.WebViewResultUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebViewResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_url(self) -> bool:
        return isinstance(self._inner, types.WebViewResultUrl)

    def as_url(self) -> Optional[types.WebViewResultUrl]:
        return self._inner if self.is_url() else None

    def __repr__(self) -> str:
        return f'WebViewResult({self._inner!r})'


class AuthorizationForm(TLObject):
    """
    Boxed TL type ``account.AuthorizationForm`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAD2E1CD8: types.account.AuthorizationForm,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AuthorizationForm':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_authorization_form(self) -> bool:
        return isinstance(self._inner, types.account.AuthorizationForm)

    def as_authorization_form(self) -> Optional[types.account.AuthorizationForm]:
        return self._inner if self.is_authorization_form() else None

    def __repr__(self) -> str:
        return f'AuthorizationForm({self._inner!r})'


class Authorizations(TLObject):
    """
    Boxed TL type ``account.Authorizations`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4BFF8EA0: types.account.Authorizations,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Authorizations':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_authorizations(self) -> bool:
        return isinstance(self._inner, types.account.Authorizations)

    def as_authorizations(self) -> Optional[types.account.Authorizations]:
        return self._inner if self.is_authorizations() else None

    def __repr__(self) -> str:
        return f'Authorizations({self._inner!r})'


class AutoDownloadSettings(TLObject):
    """
    Boxed TL type ``account.AutoDownloadSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x63CACF26: types.account.AutoDownloadSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AutoDownloadSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_auto_download_settings(self) -> bool:
        return isinstance(self._inner, types.account.AutoDownloadSettings)

    def as_auto_download_settings(self) -> Optional[types.account.AutoDownloadSettings]:
        return self._inner if self.is_auto_download_settings() else None

    def __repr__(self) -> str:
        return f'AutoDownloadSettings({self._inner!r})'


class AutoSaveSettings(TLObject):
    """
    Boxed TL type ``account.AutoSaveSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4C3E069D: types.account.AutoSaveSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AutoSaveSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_auto_save_settings(self) -> bool:
        return isinstance(self._inner, types.account.AutoSaveSettings)

    def as_auto_save_settings(self) -> Optional[types.account.AutoSaveSettings]:
        return self._inner if self.is_auto_save_settings() else None

    def __repr__(self) -> str:
        return f'AutoSaveSettings({self._inner!r})'


class BusinessChatLinks(TLObject):
    """
    Boxed TL type ``account.BusinessChatLinks`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEC43A2D1: types.account.BusinessChatLinks,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BusinessChatLinks':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_business_chat_links(self) -> bool:
        return isinstance(self._inner, types.account.BusinessChatLinks)

    def as_business_chat_links(self) -> Optional[types.account.BusinessChatLinks]:
        return self._inner if self.is_business_chat_links() else None

    def __repr__(self) -> str:
        return f'BusinessChatLinks({self._inner!r})'


class ChatThemes(TLObject):
    """
    Boxed TL type ``account.ChatThemes`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE011E1C4: types.account.ChatThemesNotModified,
        0xBE098173: types.account.ChatThemes,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatThemes':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.account.ChatThemesNotModified)

    def as_not_modified(self) -> Optional[types.account.ChatThemesNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_chat_themes(self) -> bool:
        return isinstance(self._inner, types.account.ChatThemes)

    def as_chat_themes(self) -> Optional[types.account.ChatThemes]:
        return self._inner if self.is_chat_themes() else None

    def __repr__(self) -> str:
        return f'ChatThemes({self._inner!r})'


class ConnectedBots(TLObject):
    """
    Boxed TL type ``account.ConnectedBots`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x17D7F87B: types.account.ConnectedBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ConnectedBots':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_connected_bots(self) -> bool:
        return isinstance(self._inner, types.account.ConnectedBots)

    def as_connected_bots(self) -> Optional[types.account.ConnectedBots]:
        return self._inner if self.is_connected_bots() else None

    def __repr__(self) -> str:
        return f'ConnectedBots({self._inner!r})'


class ContentSettings(TLObject):
    """
    Boxed TL type ``account.ContentSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x57E28221: types.account.ContentSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ContentSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_content_settings(self) -> bool:
        return isinstance(self._inner, types.account.ContentSettings)

    def as_content_settings(self) -> Optional[types.account.ContentSettings]:
        return self._inner if self.is_content_settings() else None

    def __repr__(self) -> str:
        return f'ContentSettings({self._inner!r})'


class EmailVerified(TLObject):
    """
    Boxed TL type ``account.EmailVerified`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2B96CD1B: types.account.EmailVerified,
        0xE1BB0D61: types.account.EmailVerifiedLogin,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmailVerified':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_email_verified(self) -> bool:
        return isinstance(self._inner, types.account.EmailVerified)

    def as_email_verified(self) -> Optional[types.account.EmailVerified]:
        return self._inner if self.is_email_verified() else None

    def is_login(self) -> bool:
        return isinstance(self._inner, types.account.EmailVerifiedLogin)

    def as_login(self) -> Optional[types.account.EmailVerifiedLogin]:
        return self._inner if self.is_login() else None

    def __repr__(self) -> str:
        return f'EmailVerified({self._inner!r})'


class EmojiStatuses(TLObject):
    """
    Boxed TL type ``account.EmojiStatuses`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD08CE645: types.account.EmojiStatusesNotModified,
        0x90C467D1: types.account.EmojiStatuses,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiStatuses':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.account.EmojiStatusesNotModified)

    def as_not_modified(self) -> Optional[types.account.EmojiStatusesNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_emoji_statuses(self) -> bool:
        return isinstance(self._inner, types.account.EmojiStatuses)

    def as_emoji_statuses(self) -> Optional[types.account.EmojiStatuses]:
        return self._inner if self.is_emoji_statuses() else None

    def __repr__(self) -> str:
        return f'EmojiStatuses({self._inner!r})'


class PaidMessagesRevenue(TLObject):
    """
    Boxed TL type ``account.PaidMessagesRevenue`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1E109708: types.account.PaidMessagesRevenue,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaidMessagesRevenue':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_paid_messages_revenue(self) -> bool:
        return isinstance(self._inner, types.account.PaidMessagesRevenue)

    def as_paid_messages_revenue(self) -> Optional[types.account.PaidMessagesRevenue]:
        return self._inner if self.is_paid_messages_revenue() else None

    def __repr__(self) -> str:
        return f'PaidMessagesRevenue({self._inner!r})'


class PasskeyRegistrationOptions(TLObject):
    """
    Boxed TL type ``account.PasskeyRegistrationOptions`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE16B5CE1: types.account.PasskeyRegistrationOptions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PasskeyRegistrationOptions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_passkey_registration_options(self) -> bool:
        return isinstance(self._inner, types.account.PasskeyRegistrationOptions)

    def as_passkey_registration_options(self) -> Optional[types.account.PasskeyRegistrationOptions]:
        return self._inner if self.is_passkey_registration_options() else None

    def __repr__(self) -> str:
        return f'PasskeyRegistrationOptions({self._inner!r})'


class Passkeys(TLObject):
    """
    Boxed TL type ``account.Passkeys`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF8E0AA1C: types.account.Passkeys,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Passkeys':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_passkeys(self) -> bool:
        return isinstance(self._inner, types.account.Passkeys)

    def as_passkeys(self) -> Optional[types.account.Passkeys]:
        return self._inner if self.is_passkeys() else None

    def __repr__(self) -> str:
        return f'Passkeys({self._inner!r})'


class Password(TLObject):
    """
    Boxed TL type ``account.Password`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x957B50FB: types.account.Password,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Password':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_password(self) -> bool:
        return isinstance(self._inner, types.account.Password)

    def as_password(self) -> Optional[types.account.Password]:
        return self._inner if self.is_password() else None

    def __repr__(self) -> str:
        return f'Password({self._inner!r})'


class PasswordInputSettings(TLObject):
    """
    Boxed TL type ``account.PasswordInputSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC23727C9: types.account.PasswordInputSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PasswordInputSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_password_input_settings(self) -> bool:
        return isinstance(self._inner, types.account.PasswordInputSettings)

    def as_password_input_settings(self) -> Optional[types.account.PasswordInputSettings]:
        return self._inner if self.is_password_input_settings() else None

    def __repr__(self) -> str:
        return f'PasswordInputSettings({self._inner!r})'


class PasswordSettings(TLObject):
    """
    Boxed TL type ``account.PasswordSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9A5C33E5: types.account.PasswordSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PasswordSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_password_settings(self) -> bool:
        return isinstance(self._inner, types.account.PasswordSettings)

    def as_password_settings(self) -> Optional[types.account.PasswordSettings]:
        return self._inner if self.is_password_settings() else None

    def __repr__(self) -> str:
        return f'PasswordSettings({self._inner!r})'


class PrivacyRules(TLObject):
    """
    Boxed TL type ``account.PrivacyRules`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x50A04E45: types.account.PrivacyRules,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PrivacyRules':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_privacy_rules(self) -> bool:
        return isinstance(self._inner, types.account.PrivacyRules)

    def as_privacy_rules(self) -> Optional[types.account.PrivacyRules]:
        return self._inner if self.is_privacy_rules() else None

    def __repr__(self) -> str:
        return f'PrivacyRules({self._inner!r})'


class ResetPasswordResult(TLObject):
    """
    Boxed TL type ``account.ResetPasswordResult`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE3779861: types.account.ResetPasswordFailedWait,
        0xE9EFFC7D: types.account.ResetPasswordRequestedWait,
        0xE926D63E: types.account.ResetPasswordOk,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ResetPasswordResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_reset_password_failed_wait(self) -> bool:
        return isinstance(self._inner, types.account.ResetPasswordFailedWait)

    def as_reset_password_failed_wait(self) -> Optional[types.account.ResetPasswordFailedWait]:
        return self._inner if self.is_reset_password_failed_wait() else None

    def is_reset_password_requested_wait(self) -> bool:
        return isinstance(self._inner, types.account.ResetPasswordRequestedWait)

    def as_reset_password_requested_wait(self) -> Optional[types.account.ResetPasswordRequestedWait]:
        return self._inner if self.is_reset_password_requested_wait() else None

    def is_reset_password_ok(self) -> bool:
        return isinstance(self._inner, types.account.ResetPasswordOk)

    def as_reset_password_ok(self) -> Optional[types.account.ResetPasswordOk]:
        return self._inner if self.is_reset_password_ok() else None

    def __repr__(self) -> str:
        return f'ResetPasswordResult({self._inner!r})'


class ResolvedBusinessChatLinks(TLObject):
    """
    Boxed TL type ``account.ResolvedBusinessChatLinks`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9A23AF21: types.account.ResolvedBusinessChatLinks,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ResolvedBusinessChatLinks':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_resolved_business_chat_links(self) -> bool:
        return isinstance(self._inner, types.account.ResolvedBusinessChatLinks)

    def as_resolved_business_chat_links(self) -> Optional[types.account.ResolvedBusinessChatLinks]:
        return self._inner if self.is_resolved_business_chat_links() else None

    def __repr__(self) -> str:
        return f'ResolvedBusinessChatLinks({self._inner!r})'


class SavedMusicIds(TLObject):
    """
    Boxed TL type ``account.SavedMusicIds`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4FC81D6E: types.account.SavedMusicIdsNotModified,
        0x998D6636: types.account.SavedMusicIds,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedMusicIds':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.account.SavedMusicIdsNotModified)

    def as_not_modified(self) -> Optional[types.account.SavedMusicIdsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_saved_music_ids(self) -> bool:
        return isinstance(self._inner, types.account.SavedMusicIds)

    def as_saved_music_ids(self) -> Optional[types.account.SavedMusicIds]:
        return self._inner if self.is_saved_music_ids() else None

    def __repr__(self) -> str:
        return f'SavedMusicIds({self._inner!r})'


class SavedRingtone(TLObject):
    """
    Boxed TL type ``account.SavedRingtone`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB7263F6D: types.account.SavedRingtone,
        0x1F307EB7: types.account.SavedRingtoneConverted,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedRingtone':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_ringtone(self) -> bool:
        return isinstance(self._inner, types.account.SavedRingtone)

    def as_saved_ringtone(self) -> Optional[types.account.SavedRingtone]:
        return self._inner if self.is_saved_ringtone() else None

    def is_converted(self) -> bool:
        return isinstance(self._inner, types.account.SavedRingtoneConverted)

    def as_converted(self) -> Optional[types.account.SavedRingtoneConverted]:
        return self._inner if self.is_converted() else None

    def __repr__(self) -> str:
        return f'SavedRingtone({self._inner!r})'


class SavedRingtones(TLObject):
    """
    Boxed TL type ``account.SavedRingtones`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFBF6E8B1: types.account.SavedRingtonesNotModified,
        0xC1E92CC5: types.account.SavedRingtones,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedRingtones':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.account.SavedRingtonesNotModified)

    def as_not_modified(self) -> Optional[types.account.SavedRingtonesNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_saved_ringtones(self) -> bool:
        return isinstance(self._inner, types.account.SavedRingtones)

    def as_saved_ringtones(self) -> Optional[types.account.SavedRingtones]:
        return self._inner if self.is_saved_ringtones() else None

    def __repr__(self) -> str:
        return f'SavedRingtones({self._inner!r})'


class SentEmailCode(TLObject):
    """
    Boxed TL type ``account.SentEmailCode`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x811F854F: types.account.SentEmailCode,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SentEmailCode':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sent_email_code(self) -> bool:
        return isinstance(self._inner, types.account.SentEmailCode)

    def as_sent_email_code(self) -> Optional[types.account.SentEmailCode]:
        return self._inner if self.is_sent_email_code() else None

    def __repr__(self) -> str:
        return f'SentEmailCode({self._inner!r})'


class Takeout(TLObject):
    """
    Boxed TL type ``account.Takeout`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4DBA4501: types.account.Takeout,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Takeout':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_takeout(self) -> bool:
        return isinstance(self._inner, types.account.Takeout)

    def as_takeout(self) -> Optional[types.account.Takeout]:
        return self._inner if self.is_takeout() else None

    def __repr__(self) -> str:
        return f'Takeout({self._inner!r})'


class Themes(TLObject):
    """
    Boxed TL type ``account.Themes`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF41EB622: types.account.ThemesNotModified,
        0x9A3D8C6D: types.account.Themes,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Themes':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.account.ThemesNotModified)

    def as_not_modified(self) -> Optional[types.account.ThemesNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_themes(self) -> bool:
        return isinstance(self._inner, types.account.Themes)

    def as_themes(self) -> Optional[types.account.Themes]:
        return self._inner if self.is_themes() else None

    def __repr__(self) -> str:
        return f'Themes({self._inner!r})'


class TmpPassword(TLObject):
    """
    Boxed TL type ``account.TmpPassword`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDB64FD34: types.account.TmpPassword,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TmpPassword':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_tmp_password(self) -> bool:
        return isinstance(self._inner, types.account.TmpPassword)

    def as_tmp_password(self) -> Optional[types.account.TmpPassword]:
        return self._inner if self.is_tmp_password() else None

    def __repr__(self) -> str:
        return f'TmpPassword({self._inner!r})'


class WallPapers(TLObject):
    """
    Boxed TL type ``account.WallPapers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1C199183: types.account.WallPapersNotModified,
        0xCDC3858C: types.account.WallPapers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WallPapers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.account.WallPapersNotModified)

    def as_not_modified(self) -> Optional[types.account.WallPapersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_wall_papers(self) -> bool:
        return isinstance(self._inner, types.account.WallPapers)

    def as_wall_papers(self) -> Optional[types.account.WallPapers]:
        return self._inner if self.is_wall_papers() else None

    def __repr__(self) -> str:
        return f'WallPapers({self._inner!r})'


class WebAuthorizations(TLObject):
    """
    Boxed TL type ``account.WebAuthorizations`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xED56C9FC: types.account.WebAuthorizations,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebAuthorizations':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_authorizations(self) -> bool:
        return isinstance(self._inner, types.account.WebAuthorizations)

    def as_web_authorizations(self) -> Optional[types.account.WebAuthorizations]:
        return self._inner if self.is_web_authorizations() else None

    def __repr__(self) -> str:
        return f'WebAuthorizations({self._inner!r})'


class Authorization(TLObject):
    """
    Boxed TL type ``auth.Authorization`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2EA2C0D4: types.auth.Authorization,
        0x44747E9A: types.auth.AuthorizationSignUpRequired,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Authorization':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_authorization(self) -> bool:
        return isinstance(self._inner, types.auth.Authorization)

    def as_authorization(self) -> Optional[types.auth.Authorization]:
        return self._inner if self.is_authorization() else None

    def is_sign_up_required(self) -> bool:
        return isinstance(self._inner, types.auth.AuthorizationSignUpRequired)

    def as_sign_up_required(self) -> Optional[types.auth.AuthorizationSignUpRequired]:
        return self._inner if self.is_sign_up_required() else None

    def __repr__(self) -> str:
        return f'Authorization({self._inner!r})'


class CodeType(TLObject):
    """
    Boxed TL type ``auth.CodeType`` — union of 5 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x72A3158C: types.auth.CodeTypeSms,
        0x741CD3E3: types.auth.CodeTypeCall,
        0x226CCEFB: types.auth.CodeTypeFlashCall,
        0xD61AD6EE: types.auth.CodeTypeMissedCall,
        0x06ED998C: types.auth.CodeTypeFragmentSms,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CodeType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sms(self) -> bool:
        return isinstance(self._inner, types.auth.CodeTypeSms)

    def as_sms(self) -> Optional[types.auth.CodeTypeSms]:
        return self._inner if self.is_sms() else None

    def is_call(self) -> bool:
        return isinstance(self._inner, types.auth.CodeTypeCall)

    def as_call(self) -> Optional[types.auth.CodeTypeCall]:
        return self._inner if self.is_call() else None

    def is_flash_call(self) -> bool:
        return isinstance(self._inner, types.auth.CodeTypeFlashCall)

    def as_flash_call(self) -> Optional[types.auth.CodeTypeFlashCall]:
        return self._inner if self.is_flash_call() else None

    def is_missed_call(self) -> bool:
        return isinstance(self._inner, types.auth.CodeTypeMissedCall)

    def as_missed_call(self) -> Optional[types.auth.CodeTypeMissedCall]:
        return self._inner if self.is_missed_call() else None

    def is_fragment_sms(self) -> bool:
        return isinstance(self._inner, types.auth.CodeTypeFragmentSms)

    def as_fragment_sms(self) -> Optional[types.auth.CodeTypeFragmentSms]:
        return self._inner if self.is_fragment_sms() else None

    def __repr__(self) -> str:
        return f'CodeType({self._inner!r})'


class ExportedAuthorization(TLObject):
    """
    Boxed TL type ``auth.ExportedAuthorization`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB434E2B8: types.auth.ExportedAuthorization,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedAuthorization':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_authorization(self) -> bool:
        return isinstance(self._inner, types.auth.ExportedAuthorization)

    def as_exported_authorization(self) -> Optional[types.auth.ExportedAuthorization]:
        return self._inner if self.is_exported_authorization() else None

    def __repr__(self) -> str:
        return f'ExportedAuthorization({self._inner!r})'


class LoggedOut(TLObject):
    """
    Boxed TL type ``auth.LoggedOut`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC3A2835F: types.auth.LoggedOut,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'LoggedOut':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_logged_out(self) -> bool:
        return isinstance(self._inner, types.auth.LoggedOut)

    def as_logged_out(self) -> Optional[types.auth.LoggedOut]:
        return self._inner if self.is_logged_out() else None

    def __repr__(self) -> str:
        return f'LoggedOut({self._inner!r})'


class LoginToken(TLObject):
    """
    Boxed TL type ``auth.LoginToken`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x629F1980: types.auth.LoginToken,
        0x068E9916: types.auth.LoginTokenMigrateTo,
        0x390D5C5E: types.auth.LoginTokenSuccess,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'LoginToken':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_login_token(self) -> bool:
        return isinstance(self._inner, types.auth.LoginToken)

    def as_login_token(self) -> Optional[types.auth.LoginToken]:
        return self._inner if self.is_login_token() else None

    def is_migrate_to(self) -> bool:
        return isinstance(self._inner, types.auth.LoginTokenMigrateTo)

    def as_migrate_to(self) -> Optional[types.auth.LoginTokenMigrateTo]:
        return self._inner if self.is_migrate_to() else None

    def is_success(self) -> bool:
        return isinstance(self._inner, types.auth.LoginTokenSuccess)

    def as_success(self) -> Optional[types.auth.LoginTokenSuccess]:
        return self._inner if self.is_success() else None

    def __repr__(self) -> str:
        return f'LoginToken({self._inner!r})'


class PasskeyLoginOptions(TLObject):
    """
    Boxed TL type ``auth.PasskeyLoginOptions`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE2037789: types.auth.PasskeyLoginOptions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PasskeyLoginOptions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_passkey_login_options(self) -> bool:
        return isinstance(self._inner, types.auth.PasskeyLoginOptions)

    def as_passkey_login_options(self) -> Optional[types.auth.PasskeyLoginOptions]:
        return self._inner if self.is_passkey_login_options() else None

    def __repr__(self) -> str:
        return f'PasskeyLoginOptions({self._inner!r})'


class PasswordRecovery(TLObject):
    """
    Boxed TL type ``auth.PasswordRecovery`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x137948A5: types.auth.PasswordRecovery,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PasswordRecovery':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_password_recovery(self) -> bool:
        return isinstance(self._inner, types.auth.PasswordRecovery)

    def as_password_recovery(self) -> Optional[types.auth.PasswordRecovery]:
        return self._inner if self.is_password_recovery() else None

    def __repr__(self) -> str:
        return f'PasswordRecovery({self._inner!r})'


class SentCode(TLObject):
    """
    Boxed TL type ``auth.SentCode`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5E002502: types.auth.SentCode,
        0x2390FE44: types.auth.SentCodeSuccess,
        0xE0955A3C: types.auth.SentCodePaymentRequired,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SentCode':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sent_code(self) -> bool:
        return isinstance(self._inner, types.auth.SentCode)

    def as_sent_code(self) -> Optional[types.auth.SentCode]:
        return self._inner if self.is_sent_code() else None

    def is_success(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeSuccess)

    def as_success(self) -> Optional[types.auth.SentCodeSuccess]:
        return self._inner if self.is_success() else None

    def is_payment_required(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodePaymentRequired)

    def as_payment_required(self) -> Optional[types.auth.SentCodePaymentRequired]:
        return self._inner if self.is_payment_required() else None

    def __repr__(self) -> str:
        return f'SentCode({self._inner!r})'


class SentCodeType(TLObject):
    """
    Boxed TL type ``auth.SentCodeType`` — union of 11 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3DBB5986: types.auth.SentCodeTypeApp,
        0xC000BBA2: types.auth.SentCodeTypeSms,
        0x5353E5A7: types.auth.SentCodeTypeCall,
        0xAB03C6D9: types.auth.SentCodeTypeFlashCall,
        0x82006484: types.auth.SentCodeTypeMissedCall,
        0xF450F59B: types.auth.SentCodeTypeEmailCode,
        0xA5491DEA: types.auth.SentCodeTypeSetUpEmailRequired,
        0xD9565C39: types.auth.SentCodeTypeFragmentSms,
        0x009FD736: types.auth.SentCodeTypeFirebaseSms,
        0xA416AC81: types.auth.SentCodeTypeSmsWord,
        0xB37794AF: types.auth.SentCodeTypeSmsPhrase,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SentCodeType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_app(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeApp)

    def as_app(self) -> Optional[types.auth.SentCodeTypeApp]:
        return self._inner if self.is_app() else None

    def is_sms(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeSms)

    def as_sms(self) -> Optional[types.auth.SentCodeTypeSms]:
        return self._inner if self.is_sms() else None

    def is_call(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeCall)

    def as_call(self) -> Optional[types.auth.SentCodeTypeCall]:
        return self._inner if self.is_call() else None

    def is_flash_call(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeFlashCall)

    def as_flash_call(self) -> Optional[types.auth.SentCodeTypeFlashCall]:
        return self._inner if self.is_flash_call() else None

    def is_missed_call(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeMissedCall)

    def as_missed_call(self) -> Optional[types.auth.SentCodeTypeMissedCall]:
        return self._inner if self.is_missed_call() else None

    def is_email_code(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeEmailCode)

    def as_email_code(self) -> Optional[types.auth.SentCodeTypeEmailCode]:
        return self._inner if self.is_email_code() else None

    def is_set_up_email_required(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeSetUpEmailRequired)

    def as_set_up_email_required(self) -> Optional[types.auth.SentCodeTypeSetUpEmailRequired]:
        return self._inner if self.is_set_up_email_required() else None

    def is_fragment_sms(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeFragmentSms)

    def as_fragment_sms(self) -> Optional[types.auth.SentCodeTypeFragmentSms]:
        return self._inner if self.is_fragment_sms() else None

    def is_firebase_sms(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeFirebaseSms)

    def as_firebase_sms(self) -> Optional[types.auth.SentCodeTypeFirebaseSms]:
        return self._inner if self.is_firebase_sms() else None

    def is_sms_word(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeSmsWord)

    def as_sms_word(self) -> Optional[types.auth.SentCodeTypeSmsWord]:
        return self._inner if self.is_sms_word() else None

    def is_sms_phrase(self) -> bool:
        return isinstance(self._inner, types.auth.SentCodeTypeSmsPhrase)

    def as_sms_phrase(self) -> Optional[types.auth.SentCodeTypeSmsPhrase]:
        return self._inner if self.is_sms_phrase() else None

    def __repr__(self) -> str:
        return f'SentCodeType({self._inner!r})'


class BotInfo(TLObject):
    """
    Boxed TL type ``bots.BotInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE8A775B0: types.bots.BotInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_info(self) -> bool:
        return isinstance(self._inner, types.bots.BotInfo)

    def as_bot_info(self) -> Optional[types.bots.BotInfo]:
        return self._inner if self.is_bot_info() else None

    def __repr__(self) -> str:
        return f'BotInfo({self._inner!r})'


class PopularAppBots(TLObject):
    """
    Boxed TL type ``bots.PopularAppBots`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1991B13B: types.bots.PopularAppBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PopularAppBots':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_popular_app_bots(self) -> bool:
        return isinstance(self._inner, types.bots.PopularAppBots)

    def as_popular_app_bots(self) -> Optional[types.bots.PopularAppBots]:
        return self._inner if self.is_popular_app_bots() else None

    def __repr__(self) -> str:
        return f'PopularAppBots({self._inner!r})'


class PreviewInfo(TLObject):
    """
    Boxed TL type ``bots.PreviewInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0CA71D64: types.bots.PreviewInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PreviewInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_preview_info(self) -> bool:
        return isinstance(self._inner, types.bots.PreviewInfo)

    def as_preview_info(self) -> Optional[types.bots.PreviewInfo]:
        return self._inner if self.is_preview_info() else None

    def __repr__(self) -> str:
        return f'PreviewInfo({self._inner!r})'


class AdminLogResults(TLObject):
    """
    Boxed TL type ``channels.AdminLogResults`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xED8AF74D: types.channels.AdminLogResults,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AdminLogResults':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_admin_log_results(self) -> bool:
        return isinstance(self._inner, types.channels.AdminLogResults)

    def as_admin_log_results(self) -> Optional[types.channels.AdminLogResults]:
        return self._inner if self.is_admin_log_results() else None

    def __repr__(self) -> str:
        return f'AdminLogResults({self._inner!r})'


class ChannelParticipant(TLObject):
    """
    Boxed TL type ``channels.ChannelParticipant`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDFB80317: types.channels.ChannelParticipant,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelParticipant':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_channel_participant(self) -> bool:
        return isinstance(self._inner, types.channels.ChannelParticipant)

    def as_channel_participant(self) -> Optional[types.channels.ChannelParticipant]:
        return self._inner if self.is_channel_participant() else None

    def __repr__(self) -> str:
        return f'ChannelParticipant({self._inner!r})'


class ChannelParticipants(TLObject):
    """
    Boxed TL type ``channels.ChannelParticipants`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9AB0FEAF: types.channels.ChannelParticipants,
        0xF0173FE9: types.channels.ChannelParticipantsNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelParticipants':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_channel_participants(self) -> bool:
        return isinstance(self._inner, types.channels.ChannelParticipants)

    def as_channel_participants(self) -> Optional[types.channels.ChannelParticipants]:
        return self._inner if self.is_channel_participants() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.channels.ChannelParticipantsNotModified)

    def as_not_modified(self) -> Optional[types.channels.ChannelParticipantsNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'ChannelParticipants({self._inner!r})'


class SendAsPeers(TLObject):
    """
    Boxed TL type ``channels.SendAsPeers`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF496B0C6: types.channels.SendAsPeers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SendAsPeers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_send_as_peers(self) -> bool:
        return isinstance(self._inner, types.channels.SendAsPeers)

    def as_send_as_peers(self) -> Optional[types.channels.SendAsPeers]:
        return self._inner if self.is_send_as_peers() else None

    def __repr__(self) -> str:
        return f'SendAsPeers({self._inner!r})'


class SponsoredMessageReportResult(TLObject):
    """
    Boxed TL type ``channels.SponsoredMessageReportResult`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x846F9E42: types.channels.SponsoredMessageReportResultChooseOption,
        0x3E3BCF2F: types.channels.SponsoredMessageReportResultAdsHidden,
        0xAD798849: types.channels.SponsoredMessageReportResultReported,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SponsoredMessageReportResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_choose_option(self) -> bool:
        return isinstance(self._inner, types.channels.SponsoredMessageReportResultChooseOption)

    def as_choose_option(self) -> Optional[types.channels.SponsoredMessageReportResultChooseOption]:
        return self._inner if self.is_choose_option() else None

    def is_ads_hidden(self) -> bool:
        return isinstance(self._inner, types.channels.SponsoredMessageReportResultAdsHidden)

    def as_ads_hidden(self) -> Optional[types.channels.SponsoredMessageReportResultAdsHidden]:
        return self._inner if self.is_ads_hidden() else None

    def is_reported(self) -> bool:
        return isinstance(self._inner, types.channels.SponsoredMessageReportResultReported)

    def as_reported(self) -> Optional[types.channels.SponsoredMessageReportResultReported]:
        return self._inner if self.is_reported() else None

    def __repr__(self) -> str:
        return f'SponsoredMessageReportResult({self._inner!r})'


class ChatlistInvite(TLObject):
    """
    Boxed TL type ``chatlists.ChatlistInvite`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFA87F659: types.chatlists.ChatlistInviteAlready,
        0xF10ECE2F: types.chatlists.ChatlistInvite,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatlistInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_already(self) -> bool:
        return isinstance(self._inner, types.chatlists.ChatlistInviteAlready)

    def as_already(self) -> Optional[types.chatlists.ChatlistInviteAlready]:
        return self._inner if self.is_already() else None

    def is_chatlist_invite(self) -> bool:
        return isinstance(self._inner, types.chatlists.ChatlistInvite)

    def as_chatlist_invite(self) -> Optional[types.chatlists.ChatlistInvite]:
        return self._inner if self.is_chatlist_invite() else None

    def __repr__(self) -> str:
        return f'ChatlistInvite({self._inner!r})'


class ChatlistUpdates(TLObject):
    """
    Boxed TL type ``chatlists.ChatlistUpdates`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x93BD878D: types.chatlists.ChatlistUpdates,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatlistUpdates':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chatlist_updates(self) -> bool:
        return isinstance(self._inner, types.chatlists.ChatlistUpdates)

    def as_chatlist_updates(self) -> Optional[types.chatlists.ChatlistUpdates]:
        return self._inner if self.is_chatlist_updates() else None

    def __repr__(self) -> str:
        return f'ChatlistUpdates({self._inner!r})'


class ExportedChatlistInvite(TLObject):
    """
    Boxed TL type ``chatlists.ExportedChatlistInvite`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x10E6E3A6: types.chatlists.ExportedChatlistInvite,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedChatlistInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_chatlist_invite(self) -> bool:
        return isinstance(self._inner, types.chatlists.ExportedChatlistInvite)

    def as_exported_chatlist_invite(self) -> Optional[types.chatlists.ExportedChatlistInvite]:
        return self._inner if self.is_exported_chatlist_invite() else None

    def __repr__(self) -> str:
        return f'ExportedChatlistInvite({self._inner!r})'


class ExportedInvites(TLObject):
    """
    Boxed TL type ``chatlists.ExportedInvites`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x10AB6DC7: types.chatlists.ExportedInvites,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedInvites':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_invites(self) -> bool:
        return isinstance(self._inner, types.chatlists.ExportedInvites)

    def as_exported_invites(self) -> Optional[types.chatlists.ExportedInvites]:
        return self._inner if self.is_exported_invites() else None

    def __repr__(self) -> str:
        return f'ExportedInvites({self._inner!r})'


class Blocked(TLObject):
    """
    Boxed TL type ``contacts.Blocked`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0ADE1591: types.contacts.Blocked,
        0xE1664194: types.contacts.BlockedSlice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Blocked':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_blocked(self) -> bool:
        return isinstance(self._inner, types.contacts.Blocked)

    def as_blocked(self) -> Optional[types.contacts.Blocked]:
        return self._inner if self.is_blocked() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.contacts.BlockedSlice)

    def as_slice(self) -> Optional[types.contacts.BlockedSlice]:
        return self._inner if self.is_slice() else None

    def __repr__(self) -> str:
        return f'Blocked({self._inner!r})'


class ContactBirthdays(TLObject):
    """
    Boxed TL type ``contacts.ContactBirthdays`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x114FF30D: types.contacts.ContactBirthdays,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ContactBirthdays':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_contact_birthdays(self) -> bool:
        return isinstance(self._inner, types.contacts.ContactBirthdays)

    def as_contact_birthdays(self) -> Optional[types.contacts.ContactBirthdays]:
        return self._inner if self.is_contact_birthdays() else None

    def __repr__(self) -> str:
        return f'ContactBirthdays({self._inner!r})'


class Contacts(TLObject):
    """
    Boxed TL type ``contacts.Contacts`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB74BA9D2: types.contacts.ContactsNotModified,
        0xEAE87E42: types.contacts.Contacts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Contacts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.contacts.ContactsNotModified)

    def as_not_modified(self) -> Optional[types.contacts.ContactsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_contacts(self) -> bool:
        return isinstance(self._inner, types.contacts.Contacts)

    def as_contacts(self) -> Optional[types.contacts.Contacts]:
        return self._inner if self.is_contacts() else None

    def __repr__(self) -> str:
        return f'Contacts({self._inner!r})'


class Found(TLObject):
    """
    Boxed TL type ``contacts.Found`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB3134D9D: types.contacts.Found,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Found':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_found(self) -> bool:
        return isinstance(self._inner, types.contacts.Found)

    def as_found(self) -> Optional[types.contacts.Found]:
        return self._inner if self.is_found() else None

    def __repr__(self) -> str:
        return f'Found({self._inner!r})'


class ImportedContacts(TLObject):
    """
    Boxed TL type ``contacts.ImportedContacts`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x77D01C3B: types.contacts.ImportedContacts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ImportedContacts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_imported_contacts(self) -> bool:
        return isinstance(self._inner, types.contacts.ImportedContacts)

    def as_imported_contacts(self) -> Optional[types.contacts.ImportedContacts]:
        return self._inner if self.is_imported_contacts() else None

    def __repr__(self) -> str:
        return f'ImportedContacts({self._inner!r})'


class ResolvedPeer(TLObject):
    """
    Boxed TL type ``contacts.ResolvedPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7F077AD9: types.contacts.ResolvedPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ResolvedPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_resolved_peer(self) -> bool:
        return isinstance(self._inner, types.contacts.ResolvedPeer)

    def as_resolved_peer(self) -> Optional[types.contacts.ResolvedPeer]:
        return self._inner if self.is_resolved_peer() else None

    def __repr__(self) -> str:
        return f'ResolvedPeer({self._inner!r})'


class SponsoredPeers(TLObject):
    """
    Boxed TL type ``contacts.SponsoredPeers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEA32B4B1: types.contacts.SponsoredPeersEmpty,
        0xEB032884: types.contacts.SponsoredPeers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SponsoredPeers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.contacts.SponsoredPeersEmpty)

    def as_empty(self) -> Optional[types.contacts.SponsoredPeersEmpty]:
        return self._inner if self.is_empty() else None

    def is_sponsored_peers(self) -> bool:
        return isinstance(self._inner, types.contacts.SponsoredPeers)

    def as_sponsored_peers(self) -> Optional[types.contacts.SponsoredPeers]:
        return self._inner if self.is_sponsored_peers() else None

    def __repr__(self) -> str:
        return f'SponsoredPeers({self._inner!r})'


class TopPeers(TLObject):
    """
    Boxed TL type ``contacts.TopPeers`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDE266EF5: types.contacts.TopPeersNotModified,
        0x70B772A8: types.contacts.TopPeers,
        0xB52C939D: types.contacts.TopPeersDisabled,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TopPeers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.contacts.TopPeersNotModified)

    def as_not_modified(self) -> Optional[types.contacts.TopPeersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_top_peers(self) -> bool:
        return isinstance(self._inner, types.contacts.TopPeers)

    def as_top_peers(self) -> Optional[types.contacts.TopPeers]:
        return self._inner if self.is_top_peers() else None

    def is_disabled(self) -> bool:
        return isinstance(self._inner, types.contacts.TopPeersDisabled)

    def as_disabled(self) -> Optional[types.contacts.TopPeersDisabled]:
        return self._inner if self.is_disabled() else None

    def __repr__(self) -> str:
        return f'TopPeers({self._inner!r})'


class CollectibleInfo(TLObject):
    """
    Boxed TL type ``fragment.CollectibleInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6EBDFF91: types.fragment.CollectibleInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CollectibleInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_collectible_info(self) -> bool:
        return isinstance(self._inner, types.fragment.CollectibleInfo)

    def as_collectible_info(self) -> Optional[types.fragment.CollectibleInfo]:
        return self._inner if self.is_collectible_info() else None

    def __repr__(self) -> str:
        return f'CollectibleInfo({self._inner!r})'


class AppConfig(TLObject):
    """
    Boxed TL type ``help.AppConfig`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7CDE641D: types.help.AppConfigNotModified,
        0xDD18782E: types.help.AppConfig,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AppConfig':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.help.AppConfigNotModified)

    def as_not_modified(self) -> Optional[types.help.AppConfigNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_app_config(self) -> bool:
        return isinstance(self._inner, types.help.AppConfig)

    def as_app_config(self) -> Optional[types.help.AppConfig]:
        return self._inner if self.is_app_config() else None

    def __repr__(self) -> str:
        return f'AppConfig({self._inner!r})'


class AppUpdate(TLObject):
    """
    Boxed TL type ``help.AppUpdate`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCCBBCE30: types.help.AppUpdate,
        0xC45A6536: types.help.NoAppUpdate,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AppUpdate':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_app_update(self) -> bool:
        return isinstance(self._inner, types.help.AppUpdate)

    def as_app_update(self) -> Optional[types.help.AppUpdate]:
        return self._inner if self.is_app_update() else None

    def is_no_app_update(self) -> bool:
        return isinstance(self._inner, types.help.NoAppUpdate)

    def as_no_app_update(self) -> Optional[types.help.NoAppUpdate]:
        return self._inner if self.is_no_app_update() else None

    def __repr__(self) -> str:
        return f'AppUpdate({self._inner!r})'


class CountriesList(TLObject):
    """
    Boxed TL type ``help.CountriesList`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x93CC1F32: types.help.CountriesListNotModified,
        0x87D0759E: types.help.CountriesList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CountriesList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.help.CountriesListNotModified)

    def as_not_modified(self) -> Optional[types.help.CountriesListNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_countries_list(self) -> bool:
        return isinstance(self._inner, types.help.CountriesList)

    def as_countries_list(self) -> Optional[types.help.CountriesList]:
        return self._inner if self.is_countries_list() else None

    def __repr__(self) -> str:
        return f'CountriesList({self._inner!r})'


class Country(TLObject):
    """
    Boxed TL type ``help.Country`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC3878E23: types.help.Country,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Country':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_country(self) -> bool:
        return isinstance(self._inner, types.help.Country)

    def as_country(self) -> Optional[types.help.Country]:
        return self._inner if self.is_country() else None

    def __repr__(self) -> str:
        return f'Country({self._inner!r})'


class CountryCode(TLObject):
    """
    Boxed TL type ``help.CountryCode`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4203C5EF: types.help.CountryCode,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CountryCode':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_country_code(self) -> bool:
        return isinstance(self._inner, types.help.CountryCode)

    def as_country_code(self) -> Optional[types.help.CountryCode]:
        return self._inner if self.is_country_code() else None

    def __repr__(self) -> str:
        return f'CountryCode({self._inner!r})'


class DeepLinkInfo(TLObject):
    """
    Boxed TL type ``help.DeepLinkInfo`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x66AFA166: types.help.DeepLinkInfoEmpty,
        0x6A4EE832: types.help.DeepLinkInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DeepLinkInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.help.DeepLinkInfoEmpty)

    def as_empty(self) -> Optional[types.help.DeepLinkInfoEmpty]:
        return self._inner if self.is_empty() else None

    def is_deep_link_info(self) -> bool:
        return isinstance(self._inner, types.help.DeepLinkInfo)

    def as_deep_link_info(self) -> Optional[types.help.DeepLinkInfo]:
        return self._inner if self.is_deep_link_info() else None

    def __repr__(self) -> str:
        return f'DeepLinkInfo({self._inner!r})'


class InviteText(TLObject):
    """
    Boxed TL type ``help.InviteText`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x18CB9F78: types.help.InviteText,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InviteText':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_invite_text(self) -> bool:
        return isinstance(self._inner, types.help.InviteText)

    def as_invite_text(self) -> Optional[types.help.InviteText]:
        return self._inner if self.is_invite_text() else None

    def __repr__(self) -> str:
        return f'InviteText({self._inner!r})'


class PassportConfig(TLObject):
    """
    Boxed TL type ``help.PassportConfig`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBFB9F457: types.help.PassportConfigNotModified,
        0xA098D6AF: types.help.PassportConfig,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PassportConfig':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.help.PassportConfigNotModified)

    def as_not_modified(self) -> Optional[types.help.PassportConfigNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_passport_config(self) -> bool:
        return isinstance(self._inner, types.help.PassportConfig)

    def as_passport_config(self) -> Optional[types.help.PassportConfig]:
        return self._inner if self.is_passport_config() else None

    def __repr__(self) -> str:
        return f'PassportConfig({self._inner!r})'


class PeerColorOption(TLObject):
    """
    Boxed TL type ``help.PeerColorOption`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xADEC6EBE: types.help.PeerColorOption,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerColorOption':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_color_option(self) -> bool:
        return isinstance(self._inner, types.help.PeerColorOption)

    def as_peer_color_option(self) -> Optional[types.help.PeerColorOption]:
        return self._inner if self.is_peer_color_option() else None

    def __repr__(self) -> str:
        return f'PeerColorOption({self._inner!r})'


class PeerColorSet(TLObject):
    """
    Boxed TL type ``help.PeerColorSet`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x26219A58: types.help.PeerColorSet,
        0x767D61EB: types.help.PeerColorProfileSet,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerColorSet':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_color_set(self) -> bool:
        return isinstance(self._inner, types.help.PeerColorSet)

    def as_peer_color_set(self) -> Optional[types.help.PeerColorSet]:
        return self._inner if self.is_peer_color_set() else None

    def is_peer_color_profile_set(self) -> bool:
        return isinstance(self._inner, types.help.PeerColorProfileSet)

    def as_peer_color_profile_set(self) -> Optional[types.help.PeerColorProfileSet]:
        return self._inner if self.is_peer_color_profile_set() else None

    def __repr__(self) -> str:
        return f'PeerColorSet({self._inner!r})'


class PeerColors(TLObject):
    """
    Boxed TL type ``help.PeerColors`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2BA1F5CE: types.help.PeerColorsNotModified,
        0x00F8ED08: types.help.PeerColors,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerColors':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.help.PeerColorsNotModified)

    def as_not_modified(self) -> Optional[types.help.PeerColorsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_peer_colors(self) -> bool:
        return isinstance(self._inner, types.help.PeerColors)

    def as_peer_colors(self) -> Optional[types.help.PeerColors]:
        return self._inner if self.is_peer_colors() else None

    def __repr__(self) -> str:
        return f'PeerColors({self._inner!r})'


class PremiumPromo(TLObject):
    """
    Boxed TL type ``help.PremiumPromo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5334759C: types.help.PremiumPromo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PremiumPromo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_premium_promo(self) -> bool:
        return isinstance(self._inner, types.help.PremiumPromo)

    def as_premium_promo(self) -> Optional[types.help.PremiumPromo]:
        return self._inner if self.is_premium_promo() else None

    def __repr__(self) -> str:
        return f'PremiumPromo({self._inner!r})'


class PromoData(TLObject):
    """
    Boxed TL type ``help.PromoData`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x98F6AC75: types.help.PromoDataEmpty,
        0x08A4D87A: types.help.PromoData,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PromoData':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.help.PromoDataEmpty)

    def as_empty(self) -> Optional[types.help.PromoDataEmpty]:
        return self._inner if self.is_empty() else None

    def is_promo_data(self) -> bool:
        return isinstance(self._inner, types.help.PromoData)

    def as_promo_data(self) -> Optional[types.help.PromoData]:
        return self._inner if self.is_promo_data() else None

    def __repr__(self) -> str:
        return f'PromoData({self._inner!r})'


class RecentMeUrls(TLObject):
    """
    Boxed TL type ``help.RecentMeUrls`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0E0310D7: types.help.RecentMeUrls,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RecentMeUrls':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_recent_me_urls(self) -> bool:
        return isinstance(self._inner, types.help.RecentMeUrls)

    def as_recent_me_urls(self) -> Optional[types.help.RecentMeUrls]:
        return self._inner if self.is_recent_me_urls() else None

    def __repr__(self) -> str:
        return f'RecentMeUrls({self._inner!r})'


class Support(TLObject):
    """
    Boxed TL type ``help.Support`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x17C6B5F6: types.help.Support,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Support':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_support(self) -> bool:
        return isinstance(self._inner, types.help.Support)

    def as_support(self) -> Optional[types.help.Support]:
        return self._inner if self.is_support() else None

    def __repr__(self) -> str:
        return f'Support({self._inner!r})'


class SupportName(TLObject):
    """
    Boxed TL type ``help.SupportName`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8C05F1C9: types.help.SupportName,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SupportName':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_support_name(self) -> bool:
        return isinstance(self._inner, types.help.SupportName)

    def as_support_name(self) -> Optional[types.help.SupportName]:
        return self._inner if self.is_support_name() else None

    def __repr__(self) -> str:
        return f'SupportName({self._inner!r})'


class TermsOfService(TLObject):
    """
    Boxed TL type ``help.TermsOfService`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x780A0310: types.help.TermsOfService,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TermsOfService':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_terms_of_service(self) -> bool:
        return isinstance(self._inner, types.help.TermsOfService)

    def as_terms_of_service(self) -> Optional[types.help.TermsOfService]:
        return self._inner if self.is_terms_of_service() else None

    def __repr__(self) -> str:
        return f'TermsOfService({self._inner!r})'


class TermsOfServiceUpdate(TLObject):
    """
    Boxed TL type ``help.TermsOfServiceUpdate`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE3309F7F: types.help.TermsOfServiceUpdateEmpty,
        0x28ECF961: types.help.TermsOfServiceUpdate,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TermsOfServiceUpdate':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.help.TermsOfServiceUpdateEmpty)

    def as_empty(self) -> Optional[types.help.TermsOfServiceUpdateEmpty]:
        return self._inner if self.is_empty() else None

    def is_terms_of_service_update(self) -> bool:
        return isinstance(self._inner, types.help.TermsOfServiceUpdate)

    def as_terms_of_service_update(self) -> Optional[types.help.TermsOfServiceUpdate]:
        return self._inner if self.is_terms_of_service_update() else None

    def __repr__(self) -> str:
        return f'TermsOfServiceUpdate({self._inner!r})'


class TimezonesList(TLObject):
    """
    Boxed TL type ``help.TimezonesList`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x970708CC: types.help.TimezonesListNotModified,
        0x7B74ED71: types.help.TimezonesList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TimezonesList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.help.TimezonesListNotModified)

    def as_not_modified(self) -> Optional[types.help.TimezonesListNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_timezones_list(self) -> bool:
        return isinstance(self._inner, types.help.TimezonesList)

    def as_timezones_list(self) -> Optional[types.help.TimezonesList]:
        return self._inner if self.is_timezones_list() else None

    def __repr__(self) -> str:
        return f'TimezonesList({self._inner!r})'


class UserInfo(TLObject):
    """
    Boxed TL type ``help.UserInfo`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF3AE2EED: types.help.UserInfoEmpty,
        0x01EB3758: types.help.UserInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UserInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.help.UserInfoEmpty)

    def as_empty(self) -> Optional[types.help.UserInfoEmpty]:
        return self._inner if self.is_empty() else None

    def is_user_info(self) -> bool:
        return isinstance(self._inner, types.help.UserInfo)

    def as_user_info(self) -> Optional[types.help.UserInfo]:
        return self._inner if self.is_user_info() else None

    def __repr__(self) -> str:
        return f'UserInfo({self._inner!r})'


class AffectedFoundMessages(TLObject):
    """
    Boxed TL type ``messages.AffectedFoundMessages`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEF8D3E6C: types.messages.AffectedFoundMessages,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AffectedFoundMessages':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_affected_found_messages(self) -> bool:
        return isinstance(self._inner, types.messages.AffectedFoundMessages)

    def as_affected_found_messages(self) -> Optional[types.messages.AffectedFoundMessages]:
        return self._inner if self.is_affected_found_messages() else None

    def __repr__(self) -> str:
        return f'AffectedFoundMessages({self._inner!r})'


class AffectedHistory(TLObject):
    """
    Boxed TL type ``messages.AffectedHistory`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB45C69D1: types.messages.AffectedHistory,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AffectedHistory':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_affected_history(self) -> bool:
        return isinstance(self._inner, types.messages.AffectedHistory)

    def as_affected_history(self) -> Optional[types.messages.AffectedHistory]:
        return self._inner if self.is_affected_history() else None

    def __repr__(self) -> str:
        return f'AffectedHistory({self._inner!r})'


class AffectedMessages(TLObject):
    """
    Boxed TL type ``messages.AffectedMessages`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x84D19185: types.messages.AffectedMessages,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AffectedMessages':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_affected_messages(self) -> bool:
        return isinstance(self._inner, types.messages.AffectedMessages)

    def as_affected_messages(self) -> Optional[types.messages.AffectedMessages]:
        return self._inner if self.is_affected_messages() else None

    def __repr__(self) -> str:
        return f'AffectedMessages({self._inner!r})'


class AllStickers(TLObject):
    """
    Boxed TL type ``messages.AllStickers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE86602C3: types.messages.AllStickersNotModified,
        0xCDBBCEBB: types.messages.AllStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AllStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.AllStickersNotModified)

    def as_not_modified(self) -> Optional[types.messages.AllStickersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_all_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.AllStickers)

    def as_all_stickers(self) -> Optional[types.messages.AllStickers]:
        return self._inner if self.is_all_stickers() else None

    def __repr__(self) -> str:
        return f'AllStickers({self._inner!r})'


class ArchivedStickers(TLObject):
    """
    Boxed TL type ``messages.ArchivedStickers`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4FCBA9C8: types.messages.ArchivedStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ArchivedStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_archived_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.ArchivedStickers)

    def as_archived_stickers(self) -> Optional[types.messages.ArchivedStickers]:
        return self._inner if self.is_archived_stickers() else None

    def __repr__(self) -> str:
        return f'ArchivedStickers({self._inner!r})'


class AvailableEffects(TLObject):
    """
    Boxed TL type ``messages.AvailableEffects`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD1ED9A5B: types.messages.AvailableEffectsNotModified,
        0xBDDB616E: types.messages.AvailableEffects,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AvailableEffects':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.AvailableEffectsNotModified)

    def as_not_modified(self) -> Optional[types.messages.AvailableEffectsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_available_effects(self) -> bool:
        return isinstance(self._inner, types.messages.AvailableEffects)

    def as_available_effects(self) -> Optional[types.messages.AvailableEffects]:
        return self._inner if self.is_available_effects() else None

    def __repr__(self) -> str:
        return f'AvailableEffects({self._inner!r})'


class AvailableReactions(TLObject):
    """
    Boxed TL type ``messages.AvailableReactions`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9F071957: types.messages.AvailableReactionsNotModified,
        0x768E3AAD: types.messages.AvailableReactions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AvailableReactions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.AvailableReactionsNotModified)

    def as_not_modified(self) -> Optional[types.messages.AvailableReactionsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_available_reactions(self) -> bool:
        return isinstance(self._inner, types.messages.AvailableReactions)

    def as_available_reactions(self) -> Optional[types.messages.AvailableReactions]:
        return self._inner if self.is_available_reactions() else None

    def __repr__(self) -> str:
        return f'AvailableReactions({self._inner!r})'


class BotApp(TLObject):
    """
    Boxed TL type ``messages.BotApp`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEB50ADF5: types.messages.BotApp,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotApp':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_app(self) -> bool:
        return isinstance(self._inner, types.messages.BotApp)

    def as_bot_app(self) -> Optional[types.messages.BotApp]:
        return self._inner if self.is_bot_app() else None

    def __repr__(self) -> str:
        return f'BotApp({self._inner!r})'


class BotCallbackAnswer(TLObject):
    """
    Boxed TL type ``messages.BotCallbackAnswer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x36585EA4: types.messages.BotCallbackAnswer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotCallbackAnswer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_callback_answer(self) -> bool:
        return isinstance(self._inner, types.messages.BotCallbackAnswer)

    def as_bot_callback_answer(self) -> Optional[types.messages.BotCallbackAnswer]:
        return self._inner if self.is_bot_callback_answer() else None

    def __repr__(self) -> str:
        return f'BotCallbackAnswer({self._inner!r})'


class BotPreparedInlineMessage(TLObject):
    """
    Boxed TL type ``messages.BotPreparedInlineMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8ECF0511: types.messages.BotPreparedInlineMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotPreparedInlineMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_prepared_inline_message(self) -> bool:
        return isinstance(self._inner, types.messages.BotPreparedInlineMessage)

    def as_bot_prepared_inline_message(self) -> Optional[types.messages.BotPreparedInlineMessage]:
        return self._inner if self.is_bot_prepared_inline_message() else None

    def __repr__(self) -> str:
        return f'BotPreparedInlineMessage({self._inner!r})'


class BotResults(TLObject):
    """
    Boxed TL type ``messages.BotResults`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE021F2F6: types.messages.BotResults,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BotResults':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bot_results(self) -> bool:
        return isinstance(self._inner, types.messages.BotResults)

    def as_bot_results(self) -> Optional[types.messages.BotResults]:
        return self._inner if self.is_bot_results() else None

    def __repr__(self) -> str:
        return f'BotResults({self._inner!r})'


class ChatAdminsWithInvites(TLObject):
    """
    Boxed TL type ``messages.ChatAdminsWithInvites`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB69B72D7: types.messages.ChatAdminsWithInvites,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatAdminsWithInvites':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_admins_with_invites(self) -> bool:
        return isinstance(self._inner, types.messages.ChatAdminsWithInvites)

    def as_chat_admins_with_invites(self) -> Optional[types.messages.ChatAdminsWithInvites]:
        return self._inner if self.is_chat_admins_with_invites() else None

    def __repr__(self) -> str:
        return f'ChatAdminsWithInvites({self._inner!r})'


class ChatFull(TLObject):
    """
    Boxed TL type ``messages.ChatFull`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE5D7D19C: types.messages.ChatFull,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatFull':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_full(self) -> bool:
        return isinstance(self._inner, types.messages.ChatFull)

    def as_chat_full(self) -> Optional[types.messages.ChatFull]:
        return self._inner if self.is_chat_full() else None

    def __repr__(self) -> str:
        return f'ChatFull({self._inner!r})'


class ChatInviteImporters(TLObject):
    """
    Boxed TL type ``messages.ChatInviteImporters`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x81B6B00A: types.messages.ChatInviteImporters,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChatInviteImporters':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chat_invite_importers(self) -> bool:
        return isinstance(self._inner, types.messages.ChatInviteImporters)

    def as_chat_invite_importers(self) -> Optional[types.messages.ChatInviteImporters]:
        return self._inner if self.is_chat_invite_importers() else None

    def __repr__(self) -> str:
        return f'ChatInviteImporters({self._inner!r})'


class Chats(TLObject):
    """
    Boxed TL type ``messages.Chats`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x64FF9FD5: types.messages.Chats,
        0x9CD81144: types.messages.ChatsSlice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Chats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_chats(self) -> bool:
        return isinstance(self._inner, types.messages.Chats)

    def as_chats(self) -> Optional[types.messages.Chats]:
        return self._inner if self.is_chats() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.messages.ChatsSlice)

    def as_slice(self) -> Optional[types.messages.ChatsSlice]:
        return self._inner if self.is_slice() else None

    def __repr__(self) -> str:
        return f'Chats({self._inner!r})'


class CheckedHistoryImportPeer(TLObject):
    """
    Boxed TL type ``messages.CheckedHistoryImportPeer`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA24DE717: types.messages.CheckedHistoryImportPeer,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CheckedHistoryImportPeer':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_checked_history_import_peer(self) -> bool:
        return isinstance(self._inner, types.messages.CheckedHistoryImportPeer)

    def as_checked_history_import_peer(self) -> Optional[types.messages.CheckedHistoryImportPeer]:
        return self._inner if self.is_checked_history_import_peer() else None

    def __repr__(self) -> str:
        return f'CheckedHistoryImportPeer({self._inner!r})'


class DhConfig(TLObject):
    """
    Boxed TL type ``messages.DhConfig`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC0E24635: types.messages.DhConfigNotModified,
        0x2C221EDD: types.messages.DhConfig,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DhConfig':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.DhConfigNotModified)

    def as_not_modified(self) -> Optional[types.messages.DhConfigNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_dh_config(self) -> bool:
        return isinstance(self._inner, types.messages.DhConfig)

    def as_dh_config(self) -> Optional[types.messages.DhConfig]:
        return self._inner if self.is_dh_config() else None

    def __repr__(self) -> str:
        return f'DhConfig({self._inner!r})'


class DialogFilters(TLObject):
    """
    Boxed TL type ``messages.DialogFilters`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2AD93719: types.messages.DialogFilters,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DialogFilters':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialog_filters(self) -> bool:
        return isinstance(self._inner, types.messages.DialogFilters)

    def as_dialog_filters(self) -> Optional[types.messages.DialogFilters]:
        return self._inner if self.is_dialog_filters() else None

    def __repr__(self) -> str:
        return f'DialogFilters({self._inner!r})'


class Dialogs(TLObject):
    """
    Boxed TL type ``messages.Dialogs`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x15BA6C40: types.messages.Dialogs,
        0x71E094F3: types.messages.DialogsSlice,
        0xF0E3E596: types.messages.DialogsNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Dialogs':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_dialogs(self) -> bool:
        return isinstance(self._inner, types.messages.Dialogs)

    def as_dialogs(self) -> Optional[types.messages.Dialogs]:
        return self._inner if self.is_dialogs() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.messages.DialogsSlice)

    def as_slice(self) -> Optional[types.messages.DialogsSlice]:
        return self._inner if self.is_slice() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.DialogsNotModified)

    def as_not_modified(self) -> Optional[types.messages.DialogsNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'Dialogs({self._inner!r})'


class DiscussionMessage(TLObject):
    """
    Boxed TL type ``messages.DiscussionMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA6341782: types.messages.DiscussionMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'DiscussionMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_discussion_message(self) -> bool:
        return isinstance(self._inner, types.messages.DiscussionMessage)

    def as_discussion_message(self) -> Optional[types.messages.DiscussionMessage]:
        return self._inner if self.is_discussion_message() else None

    def __repr__(self) -> str:
        return f'DiscussionMessage({self._inner!r})'


class EmojiGameInfo(TLObject):
    """
    Boxed TL type ``messages.EmojiGameInfo`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x59E65335: types.messages.EmojiGameUnavailable,
        0x44E56023: types.messages.EmojiGameDiceInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiGameInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_game_unavailable(self) -> bool:
        return isinstance(self._inner, types.messages.EmojiGameUnavailable)

    def as_emoji_game_unavailable(self) -> Optional[types.messages.EmojiGameUnavailable]:
        return self._inner if self.is_emoji_game_unavailable() else None

    def is_emoji_game_dice_info(self) -> bool:
        return isinstance(self._inner, types.messages.EmojiGameDiceInfo)

    def as_emoji_game_dice_info(self) -> Optional[types.messages.EmojiGameDiceInfo]:
        return self._inner if self.is_emoji_game_dice_info() else None

    def __repr__(self) -> str:
        return f'EmojiGameInfo({self._inner!r})'


class EmojiGameOutcome(TLObject):
    """
    Boxed TL type ``messages.EmojiGameOutcome`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDA2AD647: types.messages.EmojiGameOutcome,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiGameOutcome':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_emoji_game_outcome(self) -> bool:
        return isinstance(self._inner, types.messages.EmojiGameOutcome)

    def as_emoji_game_outcome(self) -> Optional[types.messages.EmojiGameOutcome]:
        return self._inner if self.is_emoji_game_outcome() else None

    def __repr__(self) -> str:
        return f'EmojiGameOutcome({self._inner!r})'


class EmojiGroups(TLObject):
    """
    Boxed TL type ``messages.EmojiGroups`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6FB4AD87: types.messages.EmojiGroupsNotModified,
        0x881FB94B: types.messages.EmojiGroups,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EmojiGroups':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.EmojiGroupsNotModified)

    def as_not_modified(self) -> Optional[types.messages.EmojiGroupsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_emoji_groups(self) -> bool:
        return isinstance(self._inner, types.messages.EmojiGroups)

    def as_emoji_groups(self) -> Optional[types.messages.EmojiGroups]:
        return self._inner if self.is_emoji_groups() else None

    def __repr__(self) -> str:
        return f'EmojiGroups({self._inner!r})'


class ExportedChatInvite(TLObject):
    """
    Boxed TL type ``messages.ExportedChatInvite`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1871BE50: types.messages.ExportedChatInvite,
        0x222600EF: types.messages.ExportedChatInviteReplaced,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedChatInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_chat_invite(self) -> bool:
        return isinstance(self._inner, types.messages.ExportedChatInvite)

    def as_exported_chat_invite(self) -> Optional[types.messages.ExportedChatInvite]:
        return self._inner if self.is_exported_chat_invite() else None

    def is_replaced(self) -> bool:
        return isinstance(self._inner, types.messages.ExportedChatInviteReplaced)

    def as_replaced(self) -> Optional[types.messages.ExportedChatInviteReplaced]:
        return self._inner if self.is_replaced() else None

    def __repr__(self) -> str:
        return f'ExportedChatInvite({self._inner!r})'


class ExportedChatInvites(TLObject):
    """
    Boxed TL type ``messages.ExportedChatInvites`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xBDC62DCC: types.messages.ExportedChatInvites,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedChatInvites':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_chat_invites(self) -> bool:
        return isinstance(self._inner, types.messages.ExportedChatInvites)

    def as_exported_chat_invites(self) -> Optional[types.messages.ExportedChatInvites]:
        return self._inner if self.is_exported_chat_invites() else None

    def __repr__(self) -> str:
        return f'ExportedChatInvites({self._inner!r})'


class FavedStickers(TLObject):
    """
    Boxed TL type ``messages.FavedStickers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9E8FA6D3: types.messages.FavedStickersNotModified,
        0x2CB51097: types.messages.FavedStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FavedStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.FavedStickersNotModified)

    def as_not_modified(self) -> Optional[types.messages.FavedStickersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_faved_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.FavedStickers)

    def as_faved_stickers(self) -> Optional[types.messages.FavedStickers]:
        return self._inner if self.is_faved_stickers() else None

    def __repr__(self) -> str:
        return f'FavedStickers({self._inner!r})'


class FeaturedStickers(TLObject):
    """
    Boxed TL type ``messages.FeaturedStickers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC6DC0C66: types.messages.FeaturedStickersNotModified,
        0xBE382906: types.messages.FeaturedStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FeaturedStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.FeaturedStickersNotModified)

    def as_not_modified(self) -> Optional[types.messages.FeaturedStickersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_featured_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.FeaturedStickers)

    def as_featured_stickers(self) -> Optional[types.messages.FeaturedStickers]:
        return self._inner if self.is_featured_stickers() else None

    def __repr__(self) -> str:
        return f'FeaturedStickers({self._inner!r})'


class ForumTopics(TLObject):
    """
    Boxed TL type ``messages.ForumTopics`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x367617D3: types.messages.ForumTopics,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ForumTopics':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_forum_topics(self) -> bool:
        return isinstance(self._inner, types.messages.ForumTopics)

    def as_forum_topics(self) -> Optional[types.messages.ForumTopics]:
        return self._inner if self.is_forum_topics() else None

    def __repr__(self) -> str:
        return f'ForumTopics({self._inner!r})'


class FoundStickerSets(TLObject):
    """
    Boxed TL type ``messages.FoundStickerSets`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0D54B65D: types.messages.FoundStickerSetsNotModified,
        0x8AF09DD2: types.messages.FoundStickerSets,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FoundStickerSets':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.FoundStickerSetsNotModified)

    def as_not_modified(self) -> Optional[types.messages.FoundStickerSetsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_found_sticker_sets(self) -> bool:
        return isinstance(self._inner, types.messages.FoundStickerSets)

    def as_found_sticker_sets(self) -> Optional[types.messages.FoundStickerSets]:
        return self._inner if self.is_found_sticker_sets() else None

    def __repr__(self) -> str:
        return f'FoundStickerSets({self._inner!r})'


class FoundStickers(TLObject):
    """
    Boxed TL type ``messages.FoundStickers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6010C534: types.messages.FoundStickersNotModified,
        0x82C9E290: types.messages.FoundStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FoundStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.FoundStickersNotModified)

    def as_not_modified(self) -> Optional[types.messages.FoundStickersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_found_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.FoundStickers)

    def as_found_stickers(self) -> Optional[types.messages.FoundStickers]:
        return self._inner if self.is_found_stickers() else None

    def __repr__(self) -> str:
        return f'FoundStickers({self._inner!r})'


class HighScores(TLObject):
    """
    Boxed TL type ``messages.HighScores`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9A3BFD99: types.messages.HighScores,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'HighScores':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_high_scores(self) -> bool:
        return isinstance(self._inner, types.messages.HighScores)

    def as_high_scores(self) -> Optional[types.messages.HighScores]:
        return self._inner if self.is_high_scores() else None

    def __repr__(self) -> str:
        return f'HighScores({self._inner!r})'


class HistoryImport(TLObject):
    """
    Boxed TL type ``messages.HistoryImport`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1662AF0B: types.messages.HistoryImport,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'HistoryImport':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_history_import(self) -> bool:
        return isinstance(self._inner, types.messages.HistoryImport)

    def as_history_import(self) -> Optional[types.messages.HistoryImport]:
        return self._inner if self.is_history_import() else None

    def __repr__(self) -> str:
        return f'HistoryImport({self._inner!r})'


class HistoryImportParsed(TLObject):
    """
    Boxed TL type ``messages.HistoryImportParsed`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5E0FB7B9: types.messages.HistoryImportParsed,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'HistoryImportParsed':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_history_import_parsed(self) -> bool:
        return isinstance(self._inner, types.messages.HistoryImportParsed)

    def as_history_import_parsed(self) -> Optional[types.messages.HistoryImportParsed]:
        return self._inner if self.is_history_import_parsed() else None

    def __repr__(self) -> str:
        return f'HistoryImportParsed({self._inner!r})'


class InactiveChats(TLObject):
    """
    Boxed TL type ``messages.InactiveChats`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA927FEC5: types.messages.InactiveChats,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InactiveChats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_inactive_chats(self) -> bool:
        return isinstance(self._inner, types.messages.InactiveChats)

    def as_inactive_chats(self) -> Optional[types.messages.InactiveChats]:
        return self._inner if self.is_inactive_chats() else None

    def __repr__(self) -> str:
        return f'InactiveChats({self._inner!r})'


class InvitedUsers(TLObject):
    """
    Boxed TL type ``messages.InvitedUsers`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7F5DEFA6: types.messages.InvitedUsers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'InvitedUsers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_invited_users(self) -> bool:
        return isinstance(self._inner, types.messages.InvitedUsers)

    def as_invited_users(self) -> Optional[types.messages.InvitedUsers]:
        return self._inner if self.is_invited_users() else None

    def __repr__(self) -> str:
        return f'InvitedUsers({self._inner!r})'


class MessageEditData(TLObject):
    """
    Boxed TL type ``messages.MessageEditData`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x26B5DDE6: types.messages.MessageEditData,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageEditData':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_edit_data(self) -> bool:
        return isinstance(self._inner, types.messages.MessageEditData)

    def as_message_edit_data(self) -> Optional[types.messages.MessageEditData]:
        return self._inner if self.is_message_edit_data() else None

    def __repr__(self) -> str:
        return f'MessageEditData({self._inner!r})'


class MessageReactionsList(TLObject):
    """
    Boxed TL type ``messages.MessageReactionsList`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x31BD492D: types.messages.MessageReactionsList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageReactionsList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_reactions_list(self) -> bool:
        return isinstance(self._inner, types.messages.MessageReactionsList)

    def as_message_reactions_list(self) -> Optional[types.messages.MessageReactionsList]:
        return self._inner if self.is_message_reactions_list() else None

    def __repr__(self) -> str:
        return f'MessageReactionsList({self._inner!r})'


class MessageViews(TLObject):
    """
    Boxed TL type ``messages.MessageViews`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB6C4F543: types.messages.MessageViews,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageViews':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_views(self) -> bool:
        return isinstance(self._inner, types.messages.MessageViews)

    def as_message_views(self) -> Optional[types.messages.MessageViews]:
        return self._inner if self.is_message_views() else None

    def __repr__(self) -> str:
        return f'MessageViews({self._inner!r})'


class Messages(TLObject):
    """
    Boxed TL type ``messages.Messages`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1D73E7EA: types.messages.Messages,
        0x5F206716: types.messages.MessagesSlice,
        0xC776BA4E: types.messages.ChannelMessages,
        0x74535F21: types.messages.MessagesNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Messages':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_messages(self) -> bool:
        return isinstance(self._inner, types.messages.Messages)

    def as_messages(self) -> Optional[types.messages.Messages]:
        return self._inner if self.is_messages() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.messages.MessagesSlice)

    def as_slice(self) -> Optional[types.messages.MessagesSlice]:
        return self._inner if self.is_slice() else None

    def is_channel_messages(self) -> bool:
        return isinstance(self._inner, types.messages.ChannelMessages)

    def as_channel_messages(self) -> Optional[types.messages.ChannelMessages]:
        return self._inner if self.is_channel_messages() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.MessagesNotModified)

    def as_not_modified(self) -> Optional[types.messages.MessagesNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'Messages({self._inner!r})'


class MyStickers(TLObject):
    """
    Boxed TL type ``messages.MyStickers`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFAFF629D: types.messages.MyStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MyStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_my_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.MyStickers)

    def as_my_stickers(self) -> Optional[types.messages.MyStickers]:
        return self._inner if self.is_my_stickers() else None

    def __repr__(self) -> str:
        return f'MyStickers({self._inner!r})'


class PeerDialogs(TLObject):
    """
    Boxed TL type ``messages.PeerDialogs`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3371C354: types.messages.PeerDialogs,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerDialogs':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_dialogs(self) -> bool:
        return isinstance(self._inner, types.messages.PeerDialogs)

    def as_peer_dialogs(self) -> Optional[types.messages.PeerDialogs]:
        return self._inner if self.is_peer_dialogs() else None

    def __repr__(self) -> str:
        return f'PeerDialogs({self._inner!r})'


class PeerSettings(TLObject):
    """
    Boxed TL type ``messages.PeerSettings`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6880B94D: types.messages.PeerSettings,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerSettings':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_settings(self) -> bool:
        return isinstance(self._inner, types.messages.PeerSettings)

    def as_peer_settings(self) -> Optional[types.messages.PeerSettings]:
        return self._inner if self.is_peer_settings() else None

    def __repr__(self) -> str:
        return f'PeerSettings({self._inner!r})'


class PreparedInlineMessage(TLObject):
    """
    Boxed TL type ``messages.PreparedInlineMessage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFF57708D: types.messages.PreparedInlineMessage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PreparedInlineMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_prepared_inline_message(self) -> bool:
        return isinstance(self._inner, types.messages.PreparedInlineMessage)

    def as_prepared_inline_message(self) -> Optional[types.messages.PreparedInlineMessage]:
        return self._inner if self.is_prepared_inline_message() else None

    def __repr__(self) -> str:
        return f'PreparedInlineMessage({self._inner!r})'


class QuickReplies(TLObject):
    """
    Boxed TL type ``messages.QuickReplies`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC68D6695: types.messages.QuickReplies,
        0x5F91EB5B: types.messages.QuickRepliesNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'QuickReplies':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_quick_replies(self) -> bool:
        return isinstance(self._inner, types.messages.QuickReplies)

    def as_quick_replies(self) -> Optional[types.messages.QuickReplies]:
        return self._inner if self.is_quick_replies() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.QuickRepliesNotModified)

    def as_not_modified(self) -> Optional[types.messages.QuickRepliesNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'QuickReplies({self._inner!r})'


class Reactions(TLObject):
    """
    Boxed TL type ``messages.Reactions`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB06FDBDF: types.messages.ReactionsNotModified,
        0xEAFDF716: types.messages.Reactions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Reactions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.ReactionsNotModified)

    def as_not_modified(self) -> Optional[types.messages.ReactionsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_reactions(self) -> bool:
        return isinstance(self._inner, types.messages.Reactions)

    def as_reactions(self) -> Optional[types.messages.Reactions]:
        return self._inner if self.is_reactions() else None

    def __repr__(self) -> str:
        return f'Reactions({self._inner!r})'


class RecentStickers(TLObject):
    """
    Boxed TL type ``messages.RecentStickers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x0B17F890: types.messages.RecentStickersNotModified,
        0x88D37C56: types.messages.RecentStickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'RecentStickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.RecentStickersNotModified)

    def as_not_modified(self) -> Optional[types.messages.RecentStickersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_recent_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.RecentStickers)

    def as_recent_stickers(self) -> Optional[types.messages.RecentStickers]:
        return self._inner if self.is_recent_stickers() else None

    def __repr__(self) -> str:
        return f'RecentStickers({self._inner!r})'


class SavedDialogs(TLObject):
    """
    Boxed TL type ``messages.SavedDialogs`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF83AE221: types.messages.SavedDialogs,
        0x44BA9DD9: types.messages.SavedDialogsSlice,
        0xC01F6FE8: types.messages.SavedDialogsNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedDialogs':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_dialogs(self) -> bool:
        return isinstance(self._inner, types.messages.SavedDialogs)

    def as_saved_dialogs(self) -> Optional[types.messages.SavedDialogs]:
        return self._inner if self.is_saved_dialogs() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.messages.SavedDialogsSlice)

    def as_slice(self) -> Optional[types.messages.SavedDialogsSlice]:
        return self._inner if self.is_slice() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.SavedDialogsNotModified)

    def as_not_modified(self) -> Optional[types.messages.SavedDialogsNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'SavedDialogs({self._inner!r})'


class SavedGifs(TLObject):
    """
    Boxed TL type ``messages.SavedGifs`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE8025CA2: types.messages.SavedGifsNotModified,
        0x84A02A0D: types.messages.SavedGifs,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedGifs':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.SavedGifsNotModified)

    def as_not_modified(self) -> Optional[types.messages.SavedGifsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_saved_gifs(self) -> bool:
        return isinstance(self._inner, types.messages.SavedGifs)

    def as_saved_gifs(self) -> Optional[types.messages.SavedGifs]:
        return self._inner if self.is_saved_gifs() else None

    def __repr__(self) -> str:
        return f'SavedGifs({self._inner!r})'


class SavedReactionTags(TLObject):
    """
    Boxed TL type ``messages.SavedReactionTags`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x889B59EF: types.messages.SavedReactionTagsNotModified,
        0x3259950A: types.messages.SavedReactionTags,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedReactionTags':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.SavedReactionTagsNotModified)

    def as_not_modified(self) -> Optional[types.messages.SavedReactionTagsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_saved_reaction_tags(self) -> bool:
        return isinstance(self._inner, types.messages.SavedReactionTags)

    def as_saved_reaction_tags(self) -> Optional[types.messages.SavedReactionTags]:
        return self._inner if self.is_saved_reaction_tags() else None

    def __repr__(self) -> str:
        return f'SavedReactionTags({self._inner!r})'


class SearchCounter(TLObject):
    """
    Boxed TL type ``messages.SearchCounter`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE844EBFF: types.messages.SearchCounter,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SearchCounter':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_search_counter(self) -> bool:
        return isinstance(self._inner, types.messages.SearchCounter)

    def as_search_counter(self) -> Optional[types.messages.SearchCounter]:
        return self._inner if self.is_search_counter() else None

    def __repr__(self) -> str:
        return f'SearchCounter({self._inner!r})'


class SearchResultsCalendar(TLObject):
    """
    Boxed TL type ``messages.SearchResultsCalendar`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x147EE23C: types.messages.SearchResultsCalendar,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SearchResultsCalendar':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_search_results_calendar(self) -> bool:
        return isinstance(self._inner, types.messages.SearchResultsCalendar)

    def as_search_results_calendar(self) -> Optional[types.messages.SearchResultsCalendar]:
        return self._inner if self.is_search_results_calendar() else None

    def __repr__(self) -> str:
        return f'SearchResultsCalendar({self._inner!r})'


class SearchResultsPositions(TLObject):
    """
    Boxed TL type ``messages.SearchResultsPositions`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x53B22BAF: types.messages.SearchResultsPositions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SearchResultsPositions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_search_results_positions(self) -> bool:
        return isinstance(self._inner, types.messages.SearchResultsPositions)

    def as_search_results_positions(self) -> Optional[types.messages.SearchResultsPositions]:
        return self._inner if self.is_search_results_positions() else None

    def __repr__(self) -> str:
        return f'SearchResultsPositions({self._inner!r})'


class SentEncryptedMessage(TLObject):
    """
    Boxed TL type ``messages.SentEncryptedMessage`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x560F8935: types.messages.SentEncryptedMessage,
        0x9493FF32: types.messages.SentEncryptedFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SentEncryptedMessage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sent_encrypted_message(self) -> bool:
        return isinstance(self._inner, types.messages.SentEncryptedMessage)

    def as_sent_encrypted_message(self) -> Optional[types.messages.SentEncryptedMessage]:
        return self._inner if self.is_sent_encrypted_message() else None

    def is_sent_encrypted_file(self) -> bool:
        return isinstance(self._inner, types.messages.SentEncryptedFile)

    def as_sent_encrypted_file(self) -> Optional[types.messages.SentEncryptedFile]:
        return self._inner if self.is_sent_encrypted_file() else None

    def __repr__(self) -> str:
        return f'SentEncryptedMessage({self._inner!r})'


class SponsoredMessages(TLObject):
    """
    Boxed TL type ``messages.SponsoredMessages`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFFDA656D: types.messages.SponsoredMessages,
        0x1839490F: types.messages.SponsoredMessagesEmpty,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SponsoredMessages':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sponsored_messages(self) -> bool:
        return isinstance(self._inner, types.messages.SponsoredMessages)

    def as_sponsored_messages(self) -> Optional[types.messages.SponsoredMessages]:
        return self._inner if self.is_sponsored_messages() else None

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.messages.SponsoredMessagesEmpty)

    def as_empty(self) -> Optional[types.messages.SponsoredMessagesEmpty]:
        return self._inner if self.is_empty() else None

    def __repr__(self) -> str:
        return f'SponsoredMessages({self._inner!r})'


class StickerSet(TLObject):
    """
    Boxed TL type ``messages.StickerSet`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6E153F16: types.messages.StickerSet,
        0xD3F924EB: types.messages.StickerSetNotModified,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StickerSet':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_sticker_set(self) -> bool:
        return isinstance(self._inner, types.messages.StickerSet)

    def as_sticker_set(self) -> Optional[types.messages.StickerSet]:
        return self._inner if self.is_sticker_set() else None

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.StickerSetNotModified)

    def as_not_modified(self) -> Optional[types.messages.StickerSetNotModified]:
        return self._inner if self.is_not_modified() else None

    def __repr__(self) -> str:
        return f'StickerSet({self._inner!r})'


class StickerSetInstallResult(TLObject):
    """
    Boxed TL type ``messages.StickerSetInstallResult`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x38641628: types.messages.StickerSetInstallResultSuccess,
        0x35E410A8: types.messages.StickerSetInstallResultArchive,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StickerSetInstallResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_success(self) -> bool:
        return isinstance(self._inner, types.messages.StickerSetInstallResultSuccess)

    def as_success(self) -> Optional[types.messages.StickerSetInstallResultSuccess]:
        return self._inner if self.is_success() else None

    def is_archive(self) -> bool:
        return isinstance(self._inner, types.messages.StickerSetInstallResultArchive)

    def as_archive(self) -> Optional[types.messages.StickerSetInstallResultArchive]:
        return self._inner if self.is_archive() else None

    def __repr__(self) -> str:
        return f'StickerSetInstallResult({self._inner!r})'


class Stickers(TLObject):
    """
    Boxed TL type ``messages.Stickers`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF1749A22: types.messages.StickersNotModified,
        0x30A6EC7E: types.messages.Stickers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Stickers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.messages.StickersNotModified)

    def as_not_modified(self) -> Optional[types.messages.StickersNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_stickers(self) -> bool:
        return isinstance(self._inner, types.messages.Stickers)

    def as_stickers(self) -> Optional[types.messages.Stickers]:
        return self._inner if self.is_stickers() else None

    def __repr__(self) -> str:
        return f'Stickers({self._inner!r})'


class TranscribedAudio(TLObject):
    """
    Boxed TL type ``messages.TranscribedAudio`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCFB9D957: types.messages.TranscribedAudio,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TranscribedAudio':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_transcribed_audio(self) -> bool:
        return isinstance(self._inner, types.messages.TranscribedAudio)

    def as_transcribed_audio(self) -> Optional[types.messages.TranscribedAudio]:
        return self._inner if self.is_transcribed_audio() else None

    def __repr__(self) -> str:
        return f'TranscribedAudio({self._inner!r})'


class TranslatedText(TLObject):
    """
    Boxed TL type ``messages.TranslatedText`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x33DB32F8: types.messages.TranslateResult,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'TranslatedText':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_translate_result(self) -> bool:
        return isinstance(self._inner, types.messages.TranslateResult)

    def as_translate_result(self) -> Optional[types.messages.TranslateResult]:
        return self._inner if self.is_translate_result() else None

    def __repr__(self) -> str:
        return f'TranslatedText({self._inner!r})'


class VotesList(TLObject):
    """
    Boxed TL type ``messages.VotesList`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4899484E: types.messages.VotesList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'VotesList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_votes_list(self) -> bool:
        return isinstance(self._inner, types.messages.VotesList)

    def as_votes_list(self) -> Optional[types.messages.VotesList]:
        return self._inner if self.is_votes_list() else None

    def __repr__(self) -> str:
        return f'VotesList({self._inner!r})'


class WebPage(TLObject):
    """
    Boxed TL type ``messages.WebPage`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFD5E12BD: types.messages.WebPage,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebPage':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_page(self) -> bool:
        return isinstance(self._inner, types.messages.WebPage)

    def as_web_page(self) -> Optional[types.messages.WebPage]:
        return self._inner if self.is_web_page() else None

    def __repr__(self) -> str:
        return f'WebPage({self._inner!r})'


class WebPagePreview(TLObject):
    """
    Boxed TL type ``messages.WebPagePreview`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8C9A88AC: types.messages.WebPagePreview,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebPagePreview':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_page_preview(self) -> bool:
        return isinstance(self._inner, types.messages.WebPagePreview)

    def as_web_page_preview(self) -> Optional[types.messages.WebPagePreview]:
        return self._inner if self.is_web_page_preview() else None

    def __repr__(self) -> str:
        return f'WebPagePreview({self._inner!r})'


class BankCardData(TLObject):
    """
    Boxed TL type ``payments.BankCardData`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3E24E573: types.payments.BankCardData,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BankCardData':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_bank_card_data(self) -> bool:
        return isinstance(self._inner, types.payments.BankCardData)

    def as_bank_card_data(self) -> Optional[types.payments.BankCardData]:
        return self._inner if self.is_bank_card_data() else None

    def __repr__(self) -> str:
        return f'BankCardData({self._inner!r})'


class CheckCanSendGiftResult(TLObject):
    """
    Boxed TL type ``payments.CheckCanSendGiftResult`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x374FA7AD: types.payments.CheckCanSendGiftResultOk,
        0xD5E58274: types.payments.CheckCanSendGiftResultFail,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CheckCanSendGiftResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_ok(self) -> bool:
        return isinstance(self._inner, types.payments.CheckCanSendGiftResultOk)

    def as_ok(self) -> Optional[types.payments.CheckCanSendGiftResultOk]:
        return self._inner if self.is_ok() else None

    def is_fail(self) -> bool:
        return isinstance(self._inner, types.payments.CheckCanSendGiftResultFail)

    def as_fail(self) -> Optional[types.payments.CheckCanSendGiftResultFail]:
        return self._inner if self.is_fail() else None

    def __repr__(self) -> str:
        return f'CheckCanSendGiftResult({self._inner!r})'


class CheckedGiftCode(TLObject):
    """
    Boxed TL type ``payments.CheckedGiftCode`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEB983F8F: types.payments.CheckedGiftCode,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CheckedGiftCode':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_checked_gift_code(self) -> bool:
        return isinstance(self._inner, types.payments.CheckedGiftCode)

    def as_checked_gift_code(self) -> Optional[types.payments.CheckedGiftCode]:
        return self._inner if self.is_checked_gift_code() else None

    def __repr__(self) -> str:
        return f'CheckedGiftCode({self._inner!r})'


class ConnectedStarRefBots(TLObject):
    """
    Boxed TL type ``payments.ConnectedStarRefBots`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x98D5EA1D: types.payments.ConnectedStarRefBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ConnectedStarRefBots':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_connected_star_ref_bots(self) -> bool:
        return isinstance(self._inner, types.payments.ConnectedStarRefBots)

    def as_connected_star_ref_bots(self) -> Optional[types.payments.ConnectedStarRefBots]:
        return self._inner if self.is_connected_star_ref_bots() else None

    def __repr__(self) -> str:
        return f'ConnectedStarRefBots({self._inner!r})'


class ExportedInvoice(TLObject):
    """
    Boxed TL type ``payments.ExportedInvoice`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAED0CBD9: types.payments.ExportedInvoice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedInvoice':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_invoice(self) -> bool:
        return isinstance(self._inner, types.payments.ExportedInvoice)

    def as_exported_invoice(self) -> Optional[types.payments.ExportedInvoice]:
        return self._inner if self.is_exported_invoice() else None

    def __repr__(self) -> str:
        return f'ExportedInvoice({self._inner!r})'


class GiveawayInfo(TLObject):
    """
    Boxed TL type ``payments.GiveawayInfo`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4367DAA0: types.payments.GiveawayInfo,
        0xE175E66F: types.payments.GiveawayInfoResults,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GiveawayInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_giveaway_info(self) -> bool:
        return isinstance(self._inner, types.payments.GiveawayInfo)

    def as_giveaway_info(self) -> Optional[types.payments.GiveawayInfo]:
        return self._inner if self.is_giveaway_info() else None

    def is_results(self) -> bool:
        return isinstance(self._inner, types.payments.GiveawayInfoResults)

    def as_results(self) -> Optional[types.payments.GiveawayInfoResults]:
        return self._inner if self.is_results() else None

    def __repr__(self) -> str:
        return f'GiveawayInfo({self._inner!r})'


class PaymentForm(TLObject):
    """
    Boxed TL type ``payments.PaymentForm`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA0058751: types.payments.PaymentForm,
        0x7BF6B15C: types.payments.PaymentFormStars,
        0xB425CFE1: types.payments.PaymentFormStarGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentForm':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_payment_form(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentForm)

    def as_payment_form(self) -> Optional[types.payments.PaymentForm]:
        return self._inner if self.is_payment_form() else None

    def is_stars(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentFormStars)

    def as_stars(self) -> Optional[types.payments.PaymentFormStars]:
        return self._inner if self.is_stars() else None

    def is_star_gift(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentFormStarGift)

    def as_star_gift(self) -> Optional[types.payments.PaymentFormStarGift]:
        return self._inner if self.is_star_gift() else None

    def __repr__(self) -> str:
        return f'PaymentForm({self._inner!r})'


class PaymentReceipt(TLObject):
    """
    Boxed TL type ``payments.PaymentReceipt`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x70C4FE03: types.payments.PaymentReceipt,
        0xDABBF83A: types.payments.PaymentReceiptStars,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentReceipt':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_payment_receipt(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentReceipt)

    def as_payment_receipt(self) -> Optional[types.payments.PaymentReceipt]:
        return self._inner if self.is_payment_receipt() else None

    def is_stars(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentReceiptStars)

    def as_stars(self) -> Optional[types.payments.PaymentReceiptStars]:
        return self._inner if self.is_stars() else None

    def __repr__(self) -> str:
        return f'PaymentReceipt({self._inner!r})'


class PaymentResult(TLObject):
    """
    Boxed TL type ``payments.PaymentResult`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4E5F810D: types.payments.PaymentResult,
        0xD8411139: types.payments.PaymentVerificationNeeded,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PaymentResult':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_payment_result(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentResult)

    def as_payment_result(self) -> Optional[types.payments.PaymentResult]:
        return self._inner if self.is_payment_result() else None

    def is_payment_verification_needed(self) -> bool:
        return isinstance(self._inner, types.payments.PaymentVerificationNeeded)

    def as_payment_verification_needed(self) -> Optional[types.payments.PaymentVerificationNeeded]:
        return self._inner if self.is_payment_verification_needed() else None

    def __repr__(self) -> str:
        return f'PaymentResult({self._inner!r})'


class ResaleStarGifts(TLObject):
    """
    Boxed TL type ``payments.ResaleStarGifts`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x947A12DF: types.payments.ResaleStarGifts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ResaleStarGifts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_resale_star_gifts(self) -> bool:
        return isinstance(self._inner, types.payments.ResaleStarGifts)

    def as_resale_star_gifts(self) -> Optional[types.payments.ResaleStarGifts]:
        return self._inner if self.is_resale_star_gifts() else None

    def __repr__(self) -> str:
        return f'ResaleStarGifts({self._inner!r})'


class SavedInfo(TLObject):
    """
    Boxed TL type ``payments.SavedInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xFB8FE43C: types.payments.SavedInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_info(self) -> bool:
        return isinstance(self._inner, types.payments.SavedInfo)

    def as_saved_info(self) -> Optional[types.payments.SavedInfo]:
        return self._inner if self.is_saved_info() else None

    def __repr__(self) -> str:
        return f'SavedInfo({self._inner!r})'


class SavedStarGifts(TLObject):
    """
    Boxed TL type ``payments.SavedStarGifts`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x95F389B1: types.payments.SavedStarGifts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedStarGifts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_saved_star_gifts(self) -> bool:
        return isinstance(self._inner, types.payments.SavedStarGifts)

    def as_saved_star_gifts(self) -> Optional[types.payments.SavedStarGifts]:
        return self._inner if self.is_saved_star_gifts() else None

    def __repr__(self) -> str:
        return f'SavedStarGifts({self._inner!r})'


class StarGiftActiveAuctions(TLObject):
    """
    Boxed TL type ``payments.StarGiftActiveAuctions`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDB33DAD0: types.payments.StarGiftActiveAuctionsNotModified,
        0xAEF6ABBC: types.payments.StarGiftActiveAuctions,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftActiveAuctions':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftActiveAuctionsNotModified)

    def as_not_modified(self) -> Optional[types.payments.StarGiftActiveAuctionsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_star_gift_active_auctions(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftActiveAuctions)

    def as_star_gift_active_auctions(self) -> Optional[types.payments.StarGiftActiveAuctions]:
        return self._inner if self.is_star_gift_active_auctions() else None

    def __repr__(self) -> str:
        return f'StarGiftActiveAuctions({self._inner!r})'


class StarGiftAuctionAcquiredGifts(TLObject):
    """
    Boxed TL type ``payments.StarGiftAuctionAcquiredGifts`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7D5BD1F0: types.payments.StarGiftAuctionAcquiredGifts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAuctionAcquiredGifts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_auction_acquired_gifts(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftAuctionAcquiredGifts)

    def as_star_gift_auction_acquired_gifts(self) -> Optional[types.payments.StarGiftAuctionAcquiredGifts]:
        return self._inner if self.is_star_gift_auction_acquired_gifts() else None

    def __repr__(self) -> str:
        return f'StarGiftAuctionAcquiredGifts({self._inner!r})'


class StarGiftAuctionState(TLObject):
    """
    Boxed TL type ``payments.StarGiftAuctionState`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6B39F4EC: types.payments.StarGiftAuctionState,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftAuctionState':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_auction_state(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftAuctionState)

    def as_star_gift_auction_state(self) -> Optional[types.payments.StarGiftAuctionState]:
        return self._inner if self.is_star_gift_auction_state() else None

    def __repr__(self) -> str:
        return f'StarGiftAuctionState({self._inner!r})'


class StarGiftCollections(TLObject):
    """
    Boxed TL type ``payments.StarGiftCollections`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA0BA4F17: types.payments.StarGiftCollectionsNotModified,
        0x8A2932F3: types.payments.StarGiftCollections,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftCollections':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftCollectionsNotModified)

    def as_not_modified(self) -> Optional[types.payments.StarGiftCollectionsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_star_gift_collections(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftCollections)

    def as_star_gift_collections(self) -> Optional[types.payments.StarGiftCollections]:
        return self._inner if self.is_star_gift_collections() else None

    def __repr__(self) -> str:
        return f'StarGiftCollections({self._inner!r})'


class StarGiftUpgradeAttributes(TLObject):
    """
    Boxed TL type ``payments.StarGiftUpgradeAttributes`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x46C6E36F: types.payments.StarGiftUpgradeAttributes,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftUpgradeAttributes':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_upgrade_attributes(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftUpgradeAttributes)

    def as_star_gift_upgrade_attributes(self) -> Optional[types.payments.StarGiftUpgradeAttributes]:
        return self._inner if self.is_star_gift_upgrade_attributes() else None

    def __repr__(self) -> str:
        return f'StarGiftUpgradeAttributes({self._inner!r})'


class StarGiftUpgradePreview(TLObject):
    """
    Boxed TL type ``payments.StarGiftUpgradePreview`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3DE1DFED: types.payments.StarGiftUpgradePreview,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftUpgradePreview':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_upgrade_preview(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftUpgradePreview)

    def as_star_gift_upgrade_preview(self) -> Optional[types.payments.StarGiftUpgradePreview]:
        return self._inner if self.is_star_gift_upgrade_preview() else None

    def __repr__(self) -> str:
        return f'StarGiftUpgradePreview({self._inner!r})'


class StarGiftWithdrawalUrl(TLObject):
    """
    Boxed TL type ``payments.StarGiftWithdrawalUrl`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x84AA3A9C: types.payments.StarGiftWithdrawalUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGiftWithdrawalUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_star_gift_withdrawal_url(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftWithdrawalUrl)

    def as_star_gift_withdrawal_url(self) -> Optional[types.payments.StarGiftWithdrawalUrl]:
        return self._inner if self.is_star_gift_withdrawal_url() else None

    def __repr__(self) -> str:
        return f'StarGiftWithdrawalUrl({self._inner!r})'


class StarGifts(TLObject):
    """
    Boxed TL type ``payments.StarGifts`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA388A368: types.payments.StarGiftsNotModified,
        0x2ED82995: types.payments.StarGifts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarGifts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.payments.StarGiftsNotModified)

    def as_not_modified(self) -> Optional[types.payments.StarGiftsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_star_gifts(self) -> bool:
        return isinstance(self._inner, types.payments.StarGifts)

    def as_star_gifts(self) -> Optional[types.payments.StarGifts]:
        return self._inner if self.is_star_gifts() else None

    def __repr__(self) -> str:
        return f'StarGifts({self._inner!r})'


class StarsRevenueAdsAccountUrl(TLObject):
    """
    Boxed TL type ``payments.StarsRevenueAdsAccountUrl`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x394E7F21: types.payments.StarsRevenueAdsAccountUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsRevenueAdsAccountUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_revenue_ads_account_url(self) -> bool:
        return isinstance(self._inner, types.payments.StarsRevenueAdsAccountUrl)

    def as_stars_revenue_ads_account_url(self) -> Optional[types.payments.StarsRevenueAdsAccountUrl]:
        return self._inner if self.is_stars_revenue_ads_account_url() else None

    def __repr__(self) -> str:
        return f'StarsRevenueAdsAccountUrl({self._inner!r})'


class StarsRevenueStats(TLObject):
    """
    Boxed TL type ``payments.StarsRevenueStats`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6C207376: types.payments.StarsRevenueStats,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsRevenueStats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_revenue_stats(self) -> bool:
        return isinstance(self._inner, types.payments.StarsRevenueStats)

    def as_stars_revenue_stats(self) -> Optional[types.payments.StarsRevenueStats]:
        return self._inner if self.is_stars_revenue_stats() else None

    def __repr__(self) -> str:
        return f'StarsRevenueStats({self._inner!r})'


class StarsRevenueWithdrawalUrl(TLObject):
    """
    Boxed TL type ``payments.StarsRevenueWithdrawalUrl`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1DAB80B7: types.payments.StarsRevenueWithdrawalUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsRevenueWithdrawalUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_revenue_withdrawal_url(self) -> bool:
        return isinstance(self._inner, types.payments.StarsRevenueWithdrawalUrl)

    def as_stars_revenue_withdrawal_url(self) -> Optional[types.payments.StarsRevenueWithdrawalUrl]:
        return self._inner if self.is_stars_revenue_withdrawal_url() else None

    def __repr__(self) -> str:
        return f'StarsRevenueWithdrawalUrl({self._inner!r})'


class StarsStatus(TLObject):
    """
    Boxed TL type ``payments.StarsStatus`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x6C9CE8ED: types.payments.StarsStatus,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StarsStatus':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stars_status(self) -> bool:
        return isinstance(self._inner, types.payments.StarsStatus)

    def as_stars_status(self) -> Optional[types.payments.StarsStatus]:
        return self._inner if self.is_stars_status() else None

    def __repr__(self) -> str:
        return f'StarsStatus({self._inner!r})'


class SuggestedStarRefBots(TLObject):
    """
    Boxed TL type ``payments.SuggestedStarRefBots`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xB4D5D859: types.payments.SuggestedStarRefBots,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SuggestedStarRefBots':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_suggested_star_ref_bots(self) -> bool:
        return isinstance(self._inner, types.payments.SuggestedStarRefBots)

    def as_suggested_star_ref_bots(self) -> Optional[types.payments.SuggestedStarRefBots]:
        return self._inner if self.is_suggested_star_ref_bots() else None

    def __repr__(self) -> str:
        return f'SuggestedStarRefBots({self._inner!r})'


class UniqueStarGift(TLObject):
    """
    Boxed TL type ``payments.UniqueStarGift`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x416C56E8: types.payments.UniqueStarGift,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UniqueStarGift':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unique_star_gift(self) -> bool:
        return isinstance(self._inner, types.payments.UniqueStarGift)

    def as_unique_star_gift(self) -> Optional[types.payments.UniqueStarGift]:
        return self._inner if self.is_unique_star_gift() else None

    def __repr__(self) -> str:
        return f'UniqueStarGift({self._inner!r})'


class UniqueStarGiftValueInfo(TLObject):
    """
    Boxed TL type ``payments.UniqueStarGiftValueInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x512FE446: types.payments.UniqueStarGiftValueInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UniqueStarGiftValueInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_unique_star_gift_value_info(self) -> bool:
        return isinstance(self._inner, types.payments.UniqueStarGiftValueInfo)

    def as_unique_star_gift_value_info(self) -> Optional[types.payments.UniqueStarGiftValueInfo]:
        return self._inner if self.is_unique_star_gift_value_info() else None

    def __repr__(self) -> str:
        return f'UniqueStarGiftValueInfo({self._inner!r})'


class ValidatedRequestedInfo(TLObject):
    """
    Boxed TL type ``payments.ValidatedRequestedInfo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD1451883: types.payments.ValidatedRequestedInfo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ValidatedRequestedInfo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_validated_requested_info(self) -> bool:
        return isinstance(self._inner, types.payments.ValidatedRequestedInfo)

    def as_validated_requested_info(self) -> Optional[types.payments.ValidatedRequestedInfo]:
        return self._inner if self.is_validated_requested_info() else None

    def __repr__(self) -> str:
        return f'ValidatedRequestedInfo({self._inner!r})'


class ExportedGroupCallInvite(TLObject):
    """
    Boxed TL type ``phone.ExportedGroupCallInvite`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x204BD158: types.phone.ExportedGroupCallInvite,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ExportedGroupCallInvite':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_exported_group_call_invite(self) -> bool:
        return isinstance(self._inner, types.phone.ExportedGroupCallInvite)

    def as_exported_group_call_invite(self) -> Optional[types.phone.ExportedGroupCallInvite]:
        return self._inner if self.is_exported_group_call_invite() else None

    def __repr__(self) -> str:
        return f'ExportedGroupCallInvite({self._inner!r})'


class GroupCall(TLObject):
    """
    Boxed TL type ``phone.GroupCall`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9E727AAD: types.phone.GroupCall,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCall':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call(self) -> bool:
        return isinstance(self._inner, types.phone.GroupCall)

    def as_group_call(self) -> Optional[types.phone.GroupCall]:
        return self._inner if self.is_group_call() else None

    def __repr__(self) -> str:
        return f'GroupCall({self._inner!r})'


class GroupCallStars(TLObject):
    """
    Boxed TL type ``phone.GroupCallStars`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9D1DBD26: types.phone.GroupCallStars,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallStars':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_stars(self) -> bool:
        return isinstance(self._inner, types.phone.GroupCallStars)

    def as_group_call_stars(self) -> Optional[types.phone.GroupCallStars]:
        return self._inner if self.is_group_call_stars() else None

    def __repr__(self) -> str:
        return f'GroupCallStars({self._inner!r})'


class GroupCallStreamChannels(TLObject):
    """
    Boxed TL type ``phone.GroupCallStreamChannels`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xD0E482B2: types.phone.GroupCallStreamChannels,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallStreamChannels':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_stream_channels(self) -> bool:
        return isinstance(self._inner, types.phone.GroupCallStreamChannels)

    def as_group_call_stream_channels(self) -> Optional[types.phone.GroupCallStreamChannels]:
        return self._inner if self.is_group_call_stream_channels() else None

    def __repr__(self) -> str:
        return f'GroupCallStreamChannels({self._inner!r})'


class GroupCallStreamRtmpUrl(TLObject):
    """
    Boxed TL type ``phone.GroupCallStreamRtmpUrl`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2DBF3432: types.phone.GroupCallStreamRtmpUrl,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupCallStreamRtmpUrl':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_call_stream_rtmp_url(self) -> bool:
        return isinstance(self._inner, types.phone.GroupCallStreamRtmpUrl)

    def as_group_call_stream_rtmp_url(self) -> Optional[types.phone.GroupCallStreamRtmpUrl]:
        return self._inner if self.is_group_call_stream_rtmp_url() else None

    def __repr__(self) -> str:
        return f'GroupCallStreamRtmpUrl({self._inner!r})'


class GroupParticipants(TLObject):
    """
    Boxed TL type ``phone.GroupParticipants`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xF47751B6: types.phone.GroupParticipants,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'GroupParticipants':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_group_participants(self) -> bool:
        return isinstance(self._inner, types.phone.GroupParticipants)

    def as_group_participants(self) -> Optional[types.phone.GroupParticipants]:
        return self._inner if self.is_group_participants() else None

    def __repr__(self) -> str:
        return f'GroupParticipants({self._inner!r})'


class JoinAsPeers(TLObject):
    """
    Boxed TL type ``phone.JoinAsPeers`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAFE5623F: types.phone.JoinAsPeers,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'JoinAsPeers':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_join_as_peers(self) -> bool:
        return isinstance(self._inner, types.phone.JoinAsPeers)

    def as_join_as_peers(self) -> Optional[types.phone.JoinAsPeers]:
        return self._inner if self.is_join_as_peers() else None

    def __repr__(self) -> str:
        return f'JoinAsPeers({self._inner!r})'


class PhoneCall(TLObject):
    """
    Boxed TL type ``phone.PhoneCall`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEC82E140: types.phone.PhoneCall,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PhoneCall':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_phone_call(self) -> bool:
        return isinstance(self._inner, types.phone.PhoneCall)

    def as_phone_call(self) -> Optional[types.phone.PhoneCall]:
        return self._inner if self.is_phone_call() else None

    def __repr__(self) -> str:
        return f'PhoneCall({self._inner!r})'


class Photo(TLObject):
    """
    Boxed TL type ``photos.Photo`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x20212CA8: types.photos.Photo,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Photo':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_photo(self) -> bool:
        return isinstance(self._inner, types.photos.Photo)

    def as_photo(self) -> Optional[types.photos.Photo]:
        return self._inner if self.is_photo() else None

    def __repr__(self) -> str:
        return f'Photo({self._inner!r})'


class Photos(TLObject):
    """
    Boxed TL type ``photos.Photos`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x8DCA6AA5: types.photos.Photos,
        0x15051F54: types.photos.PhotosSlice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Photos':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_photos(self) -> bool:
        return isinstance(self._inner, types.photos.Photos)

    def as_photos(self) -> Optional[types.photos.Photos]:
        return self._inner if self.is_photos() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.photos.PhotosSlice)

    def as_slice(self) -> Optional[types.photos.PhotosSlice]:
        return self._inner if self.is_slice() else None

    def __repr__(self) -> str:
        return f'Photos({self._inner!r})'


class BoostsList(TLObject):
    """
    Boxed TL type ``premium.BoostsList`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x86F8613C: types.premium.BoostsList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BoostsList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_boosts_list(self) -> bool:
        return isinstance(self._inner, types.premium.BoostsList)

    def as_boosts_list(self) -> Optional[types.premium.BoostsList]:
        return self._inner if self.is_boosts_list() else None

    def __repr__(self) -> str:
        return f'BoostsList({self._inner!r})'


class BoostsStatus(TLObject):
    """
    Boxed TL type ``premium.BoostsStatus`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x4959427A: types.premium.BoostsStatus,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BoostsStatus':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_boosts_status(self) -> bool:
        return isinstance(self._inner, types.premium.BoostsStatus)

    def as_boosts_status(self) -> Optional[types.premium.BoostsStatus]:
        return self._inner if self.is_boosts_status() else None

    def __repr__(self) -> str:
        return f'BoostsStatus({self._inner!r})'


class MyBoosts(TLObject):
    """
    Boxed TL type ``premium.MyBoosts`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x9AE228E2: types.premium.MyBoosts,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MyBoosts':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_my_boosts(self) -> bool:
        return isinstance(self._inner, types.premium.MyBoosts)

    def as_my_boosts(self) -> Optional[types.premium.MyBoosts]:
        return self._inner if self.is_my_boosts() else None

    def __repr__(self) -> str:
        return f'MyBoosts({self._inner!r})'


class EligibilityToJoin(TLObject):
    """
    Boxed TL type ``smsjobs.EligibilityToJoin`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDC8B44CF: types.smsjobs.EligibleToJoin,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'EligibilityToJoin':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_eligible_to_join(self) -> bool:
        return isinstance(self._inner, types.smsjobs.EligibleToJoin)

    def as_eligible_to_join(self) -> Optional[types.smsjobs.EligibleToJoin]:
        return self._inner if self.is_eligible_to_join() else None

    def __repr__(self) -> str:
        return f'EligibilityToJoin({self._inner!r})'


class Status(TLObject):
    """
    Boxed TL type ``smsjobs.Status`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x2AEE9191: types.smsjobs.Status,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Status':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_status(self) -> bool:
        return isinstance(self._inner, types.smsjobs.Status)

    def as_status(self) -> Optional[types.smsjobs.Status]:
        return self._inner if self.is_status() else None

    def __repr__(self) -> str:
        return f'Status({self._inner!r})'


class BroadcastStats(TLObject):
    """
    Boxed TL type ``stats.BroadcastStats`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x396CA5FC: types.stats.BroadcastStats,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'BroadcastStats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_broadcast_stats(self) -> bool:
        return isinstance(self._inner, types.stats.BroadcastStats)

    def as_broadcast_stats(self) -> Optional[types.stats.BroadcastStats]:
        return self._inner if self.is_broadcast_stats() else None

    def __repr__(self) -> str:
        return f'BroadcastStats({self._inner!r})'


class MegagroupStats(TLObject):
    """
    Boxed TL type ``stats.MegagroupStats`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEF7FF916: types.stats.MegagroupStats,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MegagroupStats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_megagroup_stats(self) -> bool:
        return isinstance(self._inner, types.stats.MegagroupStats)

    def as_megagroup_stats(self) -> Optional[types.stats.MegagroupStats]:
        return self._inner if self.is_megagroup_stats() else None

    def __repr__(self) -> str:
        return f'MegagroupStats({self._inner!r})'


class MessageStats(TLObject):
    """
    Boxed TL type ``stats.MessageStats`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x7FE91C14: types.stats.MessageStats,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'MessageStats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_message_stats(self) -> bool:
        return isinstance(self._inner, types.stats.MessageStats)

    def as_message_stats(self) -> Optional[types.stats.MessageStats]:
        return self._inner if self.is_message_stats() else None

    def __repr__(self) -> str:
        return f'MessageStats({self._inner!r})'


class PublicForwards(TLObject):
    """
    Boxed TL type ``stats.PublicForwards`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x93037E20: types.stats.PublicForwards,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PublicForwards':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_public_forwards(self) -> bool:
        return isinstance(self._inner, types.stats.PublicForwards)

    def as_public_forwards(self) -> Optional[types.stats.PublicForwards]:
        return self._inner if self.is_public_forwards() else None

    def __repr__(self) -> str:
        return f'PublicForwards({self._inner!r})'


class StoryStats(TLObject):
    """
    Boxed TL type ``stats.StoryStats`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x50CD067C: types.stats.StoryStats,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryStats':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_stats(self) -> bool:
        return isinstance(self._inner, types.stats.StoryStats)

    def as_story_stats(self) -> Optional[types.stats.StoryStats]:
        return self._inner if self.is_story_stats() else None

    def __repr__(self) -> str:
        return f'StoryStats({self._inner!r})'


class SuggestedShortName(TLObject):
    """
    Boxed TL type ``stickers.SuggestedShortName`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x85FEA03F: types.stickers.SuggestedShortName,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SuggestedShortName':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_suggested_short_name(self) -> bool:
        return isinstance(self._inner, types.stickers.SuggestedShortName)

    def as_suggested_short_name(self) -> Optional[types.stickers.SuggestedShortName]:
        return self._inner if self.is_suggested_short_name() else None

    def __repr__(self) -> str:
        return f'SuggestedShortName({self._inner!r})'


class FileType(TLObject):
    """
    Boxed TL type ``storage.FileType`` — union of 10 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAA963B05: types.storage.FileUnknown,
        0x40BC6F52: types.storage.FilePartial,
        0x007EFE0E: types.storage.FileJpeg,
        0xCAE1AADF: types.storage.FileGif,
        0x0A4F63C0: types.storage.FilePng,
        0xAE1E508D: types.storage.FilePdf,
        0x528A0677: types.storage.FileMp3,
        0x4B09EBBC: types.storage.FileMov,
        0xB3CEA0E4: types.storage.FileMp4,
        0x1081464C: types.storage.FileWebp,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FileType':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_file_unknown(self) -> bool:
        return isinstance(self._inner, types.storage.FileUnknown)

    def as_file_unknown(self) -> Optional[types.storage.FileUnknown]:
        return self._inner if self.is_file_unknown() else None

    def is_file_partial(self) -> bool:
        return isinstance(self._inner, types.storage.FilePartial)

    def as_file_partial(self) -> Optional[types.storage.FilePartial]:
        return self._inner if self.is_file_partial() else None

    def is_file_jpeg(self) -> bool:
        return isinstance(self._inner, types.storage.FileJpeg)

    def as_file_jpeg(self) -> Optional[types.storage.FileJpeg]:
        return self._inner if self.is_file_jpeg() else None

    def is_file_gif(self) -> bool:
        return isinstance(self._inner, types.storage.FileGif)

    def as_file_gif(self) -> Optional[types.storage.FileGif]:
        return self._inner if self.is_file_gif() else None

    def is_file_png(self) -> bool:
        return isinstance(self._inner, types.storage.FilePng)

    def as_file_png(self) -> Optional[types.storage.FilePng]:
        return self._inner if self.is_file_png() else None

    def is_file_pdf(self) -> bool:
        return isinstance(self._inner, types.storage.FilePdf)

    def as_file_pdf(self) -> Optional[types.storage.FilePdf]:
        return self._inner if self.is_file_pdf() else None

    def is_file_mp3(self) -> bool:
        return isinstance(self._inner, types.storage.FileMp3)

    def as_file_mp3(self) -> Optional[types.storage.FileMp3]:
        return self._inner if self.is_file_mp3() else None

    def is_file_mov(self) -> bool:
        return isinstance(self._inner, types.storage.FileMov)

    def as_file_mov(self) -> Optional[types.storage.FileMov]:
        return self._inner if self.is_file_mov() else None

    def is_file_mp4(self) -> bool:
        return isinstance(self._inner, types.storage.FileMp4)

    def as_file_mp4(self) -> Optional[types.storage.FileMp4]:
        return self._inner if self.is_file_mp4() else None

    def is_file_webp(self) -> bool:
        return isinstance(self._inner, types.storage.FileWebp)

    def as_file_webp(self) -> Optional[types.storage.FileWebp]:
        return self._inner if self.is_file_webp() else None

    def __repr__(self) -> str:
        return f'FileType({self._inner!r})'


class Albums(TLObject):
    """
    Boxed TL type ``stories.Albums`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x564EDAEB: types.stories.AlbumsNotModified,
        0xC3987A3A: types.stories.Albums,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Albums':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.stories.AlbumsNotModified)

    def as_not_modified(self) -> Optional[types.stories.AlbumsNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_albums(self) -> bool:
        return isinstance(self._inner, types.stories.Albums)

    def as_albums(self) -> Optional[types.stories.Albums]:
        return self._inner if self.is_albums() else None

    def __repr__(self) -> str:
        return f'Albums({self._inner!r})'


class AllStories(TLObject):
    """
    Boxed TL type ``stories.AllStories`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x1158FE3E: types.stories.AllStoriesNotModified,
        0x6EFC5E81: types.stories.AllStories,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'AllStories':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.stories.AllStoriesNotModified)

    def as_not_modified(self) -> Optional[types.stories.AllStoriesNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_all_stories(self) -> bool:
        return isinstance(self._inner, types.stories.AllStories)

    def as_all_stories(self) -> Optional[types.stories.AllStories]:
        return self._inner if self.is_all_stories() else None

    def __repr__(self) -> str:
        return f'AllStories({self._inner!r})'


class CanSendStoryCount(TLObject):
    """
    Boxed TL type ``stories.CanSendStoryCount`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xC387C04E: types.stories.CanSendStoryCount,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CanSendStoryCount':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_can_send_story_count(self) -> bool:
        return isinstance(self._inner, types.stories.CanSendStoryCount)

    def as_can_send_story_count(self) -> Optional[types.stories.CanSendStoryCount]:
        return self._inner if self.is_can_send_story_count() else None

    def __repr__(self) -> str:
        return f'CanSendStoryCount({self._inner!r})'


class FoundStories(TLObject):
    """
    Boxed TL type ``stories.FoundStories`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE2DE7737: types.stories.FoundStories,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'FoundStories':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_found_stories(self) -> bool:
        return isinstance(self._inner, types.stories.FoundStories)

    def as_found_stories(self) -> Optional[types.stories.FoundStories]:
        return self._inner if self.is_found_stories() else None

    def __repr__(self) -> str:
        return f'FoundStories({self._inner!r})'


class PeerStories(TLObject):
    """
    Boxed TL type ``stories.PeerStories`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xCAE68768: types.stories.PeerStories,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'PeerStories':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_peer_stories(self) -> bool:
        return isinstance(self._inner, types.stories.PeerStories)

    def as_peer_stories(self) -> Optional[types.stories.PeerStories]:
        return self._inner if self.is_peer_stories() else None

    def __repr__(self) -> str:
        return f'PeerStories({self._inner!r})'


class Stories(TLObject):
    """
    Boxed TL type ``stories.Stories`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x63C3DD0A: types.stories.Stories,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Stories':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_stories(self) -> bool:
        return isinstance(self._inner, types.stories.Stories)

    def as_stories(self) -> Optional[types.stories.Stories]:
        return self._inner if self.is_stories() else None

    def __repr__(self) -> str:
        return f'Stories({self._inner!r})'


class StoryReactionsList(TLObject):
    """
    Boxed TL type ``stories.StoryReactionsList`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xAA5F789C: types.stories.StoryReactionsList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryReactionsList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_reactions_list(self) -> bool:
        return isinstance(self._inner, types.stories.StoryReactionsList)

    def as_story_reactions_list(self) -> Optional[types.stories.StoryReactionsList]:
        return self._inner if self.is_story_reactions_list() else None

    def __repr__(self) -> str:
        return f'StoryReactionsList({self._inner!r})'


class StoryViews(TLObject):
    """
    Boxed TL type ``stories.StoryViews`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xDE9EED1D: types.stories.StoryViews,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryViews':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_views(self) -> bool:
        return isinstance(self._inner, types.stories.StoryViews)

    def as_story_views(self) -> Optional[types.stories.StoryViews]:
        return self._inner if self.is_story_views() else None

    def __repr__(self) -> str:
        return f'StoryViews({self._inner!r})'


class StoryViewsList(TLObject):
    """
    Boxed TL type ``stories.StoryViewsList`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x59D78FC5: types.stories.StoryViewsList,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'StoryViewsList':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_story_views_list(self) -> bool:
        return isinstance(self._inner, types.stories.StoryViewsList)

    def as_story_views_list(self) -> Optional[types.stories.StoryViewsList]:
        return self._inner if self.is_story_views_list() else None

    def __repr__(self) -> str:
        return f'StoryViewsList({self._inner!r})'


class ChannelDifference(TLObject):
    """
    Boxed TL type ``updates.ChannelDifference`` — union of 3 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3E11AFFB: types.updates.ChannelDifferenceEmpty,
        0xA4BCC6FE: types.updates.ChannelDifferenceTooLong,
        0x2064674E: types.updates.ChannelDifference,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'ChannelDifference':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.updates.ChannelDifferenceEmpty)

    def as_empty(self) -> Optional[types.updates.ChannelDifferenceEmpty]:
        return self._inner if self.is_empty() else None

    def is_too_long(self) -> bool:
        return isinstance(self._inner, types.updates.ChannelDifferenceTooLong)

    def as_too_long(self) -> Optional[types.updates.ChannelDifferenceTooLong]:
        return self._inner if self.is_too_long() else None

    def is_channel_difference(self) -> bool:
        return isinstance(self._inner, types.updates.ChannelDifference)

    def as_channel_difference(self) -> Optional[types.updates.ChannelDifference]:
        return self._inner if self.is_channel_difference() else None

    def __repr__(self) -> str:
        return f'ChannelDifference({self._inner!r})'


class Difference(TLObject):
    """
    Boxed TL type ``updates.Difference`` — union of 4 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x5D75A138: types.updates.DifferenceEmpty,
        0x00F49CA0: types.updates.Difference,
        0xA8FB1981: types.updates.DifferenceSlice,
        0x4AFE8F6D: types.updates.DifferenceTooLong,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Difference':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_empty(self) -> bool:
        return isinstance(self._inner, types.updates.DifferenceEmpty)

    def as_empty(self) -> Optional[types.updates.DifferenceEmpty]:
        return self._inner if self.is_empty() else None

    def is_difference(self) -> bool:
        return isinstance(self._inner, types.updates.Difference)

    def as_difference(self) -> Optional[types.updates.Difference]:
        return self._inner if self.is_difference() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.updates.DifferenceSlice)

    def as_slice(self) -> Optional[types.updates.DifferenceSlice]:
        return self._inner if self.is_slice() else None

    def is_too_long(self) -> bool:
        return isinstance(self._inner, types.updates.DifferenceTooLong)

    def as_too_long(self) -> Optional[types.updates.DifferenceTooLong]:
        return self._inner if self.is_too_long() else None

    def __repr__(self) -> str:
        return f'Difference({self._inner!r})'


class State(TLObject):
    """
    Boxed TL type ``updates.State`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xA56C2A3E: types.updates.State,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'State':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_state(self) -> bool:
        return isinstance(self._inner, types.updates.State)

    def as_state(self) -> Optional[types.updates.State]:
        return self._inner if self.is_state() else None

    def __repr__(self) -> str:
        return f'State({self._inner!r})'


class CdnFile(TLObject):
    """
    Boxed TL type ``upload.CdnFile`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xEEA8E46E: types.upload.CdnFileReuploadNeeded,
        0xA99FCA4F: types.upload.CdnFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'CdnFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_reupload_needed(self) -> bool:
        return isinstance(self._inner, types.upload.CdnFileReuploadNeeded)

    def as_reupload_needed(self) -> Optional[types.upload.CdnFileReuploadNeeded]:
        return self._inner if self.is_reupload_needed() else None

    def is_cdn_file(self) -> bool:
        return isinstance(self._inner, types.upload.CdnFile)

    def as_cdn_file(self) -> Optional[types.upload.CdnFile]:
        return self._inner if self.is_cdn_file() else None

    def __repr__(self) -> str:
        return f'CdnFile({self._inner!r})'


class File(TLObject):
    """
    Boxed TL type ``upload.File`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x096A18D5: types.upload.File,
        0xF18CDA44: types.upload.FileCdnRedirect,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'File':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_file(self) -> bool:
        return isinstance(self._inner, types.upload.File)

    def as_file(self) -> Optional[types.upload.File]:
        return self._inner if self.is_file() else None

    def is_cdn_redirect(self) -> bool:
        return isinstance(self._inner, types.upload.FileCdnRedirect)

    def as_cdn_redirect(self) -> Optional[types.upload.FileCdnRedirect]:
        return self._inner if self.is_cdn_redirect() else None

    def __repr__(self) -> str:
        return f'File({self._inner!r})'


class WebFile(TLObject):
    """
    Boxed TL type ``upload.WebFile`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x21E753BC: types.upload.WebFile,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'WebFile':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_web_file(self) -> bool:
        return isinstance(self._inner, types.upload.WebFile)

    def as_web_file(self) -> Optional[types.upload.WebFile]:
        return self._inner if self.is_web_file() else None

    def __repr__(self) -> str:
        return f'WebFile({self._inner!r})'


class SavedMusic(TLObject):
    """
    Boxed TL type ``users.SavedMusic`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0xE3878AA4: types.users.SavedMusicNotModified,
        0x34A2F297: types.users.SavedMusic,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'SavedMusic':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_not_modified(self) -> bool:
        return isinstance(self._inner, types.users.SavedMusicNotModified)

    def as_not_modified(self) -> Optional[types.users.SavedMusicNotModified]:
        return self._inner if self.is_not_modified() else None

    def is_saved_music(self) -> bool:
        return isinstance(self._inner, types.users.SavedMusic)

    def as_saved_music(self) -> Optional[types.users.SavedMusic]:
        return self._inner if self.is_saved_music() else None

    def __repr__(self) -> str:
        return f'SavedMusic({self._inner!r})'


class UserFull(TLObject):
    """
    Boxed TL type ``users.UserFull`` — union of 1 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x3B6D152E: types.users.UserFull,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'UserFull':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_user_full(self) -> bool:
        return isinstance(self._inner, types.users.UserFull)

    def as_user_full(self) -> Optional[types.users.UserFull]:
        return self._inner if self.is_user_full() else None

    def __repr__(self) -> str:
        return f'UserFull({self._inner!r})'


class Users(TLObject):
    """
    Boxed TL type ``users.Users`` — union of 2 constructor(s).
    """
    CONSTRUCTOR_ID: int = 0  # not a single constructor
    __slots__ = ('_inner',)

    def __init__(self, inner: TLObject) -> None:
        self._inner = inner

    def unwrap(self):
        return self._inner

    _REGISTRY: dict[int, type] = {
        0x62D706B8: types.users.Users,
        0x315A4974: types.users.UsersSlice,
    }

    def _serialize(self, buf: ByteBuffer) -> None:
        buf.write_u32(self._inner.CONSTRUCTOR_ID)
        self._inner._serialize(buf)

    @classmethod
    def _deserialize(cls, reader: ByteReader) -> 'Users':
        cid = reader.read_u32()
        if cid not in cls._REGISTRY:
            raise UnknownConstructorError(cid)
        inner = cls._REGISTRY[cid]._deserialize(reader)
        return cls(inner)

    def is_users(self) -> bool:
        return isinstance(self._inner, types.users.Users)

    def as_users(self) -> Optional[types.users.Users]:
        return self._inner if self.is_users() else None

    def is_slice(self) -> bool:
        return isinstance(self._inner, types.users.UsersSlice)

    def as_slice(self) -> Optional[types.users.UsersSlice]:
        return self._inner if self.is_slice() else None

    def __repr__(self) -> str:
        return f'Users({self._inner!r})'
